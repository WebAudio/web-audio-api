<!DOCTYPE html>
<html>
<head>
  <title>Web Audio API</title>
  <meta charset=utf-8>
  <link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-WD"/>
  <script src='respec-w3c-common' async class='remove'></script>
  <script class='remove'>
    var respecConfig = {
        specStatus: "ED",
        shortName:  "webaudio",
        edDraftURI: "http://webaudio.github.io/web-audio-api/",
        editors: [
              {   name:       "Paul Adenot",
                  company:    "Mozilla Foundation",
                  companyURL: "http://mozilla.org/",
                  mailto:     "padenot@mozilla.com" },
              {
                  name:       "Chris Wilson",
                  company:    "Google, Inc.",
                  companyURL: "http://google.com",
                  mailto:     "cwilso@google.com" },
        ],
        previousMaturity: "WD",
        previousPublishDate:  "2012-12-13",
        previousURI:  "http://www.w3.org/TR/2012/WD-webaudio-20121213/",
        wg:           "Audio Working Group",
        wgURI:        "http://www.w3.org/2011/audio/",
        wgPublicList: "public-audio",
        wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
        tocIntroductory: true,
        copyrightStart: 2013,
        otherLinks: [
          {
            key: "Repository",
            href: "https://github.com/WebAudio/web-audio-api" },
          {
            key: "Bug tracker",
            href: "https://github.com/WebAudio/web-audio-api/issues?state=open" },
          {
            key: "Previous editor",
            data : [{value: "Chris Rogers (Until August 2013)"}]
          }
        ]
    };
  </script>
  <script>
    function findBadLink () {
      var old = document.querySelectorAll(".badLink");
      for (var i = 0 ; i < old.length; i++) {
        nodes[i].style.backgroundColor = "";
        nodes[i].classList.remove("badLink");
      }
      var nodes = document.querySelectorAll('a');
  
      for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].href) {
              var id =  nodes[i].href.split("/");
              id = id[id.length - 1];
              if (id.length != 0) {
                  if (id[0] == "#") {
                      if (document.querySelectorAll(id).length == 0) {
                        nodes[i].style.backgroundColor = "red";
                        nodes[i].classList.add("badLink");
                        console.log(nodes[i].textContent);
                    }
                 }
              }
          } else {
            nodes[i].style.backgroundColor = "red";
            nodes[i].classList.add("badLink");
          }
      }
    }
  </script>
</head>

<body>

<section id="abstract">
<p>This specification describes a high-level JavaScript <acronym
title="Application Programming Interface">API</acronym> for processing and
synthesizing audio in web applications. The primary paradigm is of an audio
routing graph, where a number of <a>AudioNode</a> objects are connected
together to define the overall audio rendering. The actual processing will
primarily take place in the underlying implementation (typically optimized
Assembly / C / C++ code), but <a href="#JavaScriptProcessing">direct
JavaScript processing and synthesis</a> is also supported. </p>

<p>The <a href="#introduction">introductory</a> section covers the motivation
behind this specification.</p>

<p>This API is designed to be used in conjunction with other APIs and elements
on the web platform, notably: XMLHttpRequest
(using the <code>responseType</code> and <code>response</code> attributes). For
games and interactive applications, it is anticipated to be used with the
<code>canvas</code> 2D and WebGL 3D graphics APIs. </p>
</section>

<section id="sotd">
</section>

<section class="introductory">
<h2>Introduction</h2>
<section>

<p>Audio on the web has been fairly primitive up to this point and until very
recently has had to be delivered through plugins such as Flash and QuickTime.
The introduction of the <code>audio</code> element in HTML5 is very important,
allowing for basic streaming audio playback. But, it is not powerful enough to
handle more complex audio applications. For sophisticated web-based games or
interactive applications, another solution is required. It is a goal of this
specification to include the capabilities found in modern game audio engines as
well as some of the mixing, processing, and filtering tasks that are found in
modern desktop audio production applications. </p>

<p>The APIs have been designed with a wide variety of <a
href="#ExampleApplications">use cases</a> in mind. Ideally, it should
be able to support <i>any</i> use case which could reasonably be implemented
with an optimized C++ engine controlled via JavaScript and run in a browser.
That said, modern desktop audio software can have very advanced capabilities,
some of which would be difficult or impossible to build with this system.
Apple's Logic Audio is one such application which has support for external MIDI
controllers, arbitrary plugin audio effects and synthesizers, highly optimized
direct-to-disk audio file reading/writing, tightly integrated time-stretching,
and so on. Nevertheless, the proposed system will be quite capable of
supporting a large range of reasonably complex games and interactive
applications, including musical ones. And it can be a very good complement to
the more advanced graphics features offered by WebGL. The API has been designed
so that more advanced capabilities can be added at a later time. </p>
</section>

<section>
<h2 id="Features">Features</h2>

<p>The API supports these primary features: </p>
<ul>
  <li><a href="#ModularRouting">Modular routing</a> for simple or
    complex mixing/effect architectures, including <a
    href="#mixer-gain-structure">multiple sends and submixes</a>.</li>
  <li><a href="#AudioParam">Sample-accurate scheduled sound
    playback</a> with low <a href="#latency">latency</a> for musical
    applications requiring a very high degree of rhythmic precision such as
    drum machines and sequencers. This also includes the possibility of <a
    href="#DynamicLifetime">dynamic creation</a> of effects. </li>
  <li>Automation of audio parameters for envelopes, fade-ins / fade-outs,
    granular effects, filter sweeps, LFOs etc. </li>
  <li>Flexible handling of channels in an audio stream, allowing them to be split and merged.</li>

  <li>Processing of audio sources from an <code>audio</code> or
    <code>video</code> <a href="#MediaElementAudioSourceNode">media
    element</a>. </li>
  
    <li>Processing live audio input using a <a href="#MediaStreamAudioSourceNode">MediaStream</a>
    from getUserMedia().
     </li>
    
     <li>Integration with WebRTC
  <ul>
  

   <li>Processing audio received from a remote peer using a
   <a>MediaStreamAudioSourceNode</a> and [[!webrtc]].
    </li>

  <li>Sending a generated or processed audio stream to a remote peer using a
  <a>MediaStreamAudioDestinationNode</a> and [[!webrtc]].
     </li>

     </ul>
     </li>

  <li>Audio stream synthesis and processing <a
    href="#JavaScriptProcessing">directly in JavaScript</a>. </li>
  <li><a href="#Spatialization">Spatialized audio</a> supporting a wide
    range of 3D games and immersive environments:
    <ul>
      <li>Panning models: equal-power, HRTF, pass-through </li>
      <li>Distance Attenuation </li>
      <li>Sound Cones </li>
      <li>Obstruction / Occlusion </li>
      <li>Doppler Shift </li>
      <li>Source / Listener based</li>
    </ul>
  </li>
  <li>A <a href="#Convolution">convolution engine</a> for a wide range
    of linear effects, especially very high-quality room effects. Here are some
    examples of possible effects:
    <ul>
      <li>Small / large room </li>
      <li>Cathedral </li>
      <li>Concert hall </li>
      <li>Cave </li>
      <li>Tunnel </li>
      <li>Hallway </li>
      <li>Forest </li>
      <li>Amphitheater </li>
      <li>Sound of a distant room through a doorway </li>
      <li>Extreme filters</li>
      <li>Strange backwards effects</li>
      <li>Extreme comb filter effects </li>
    </ul>
  </li>
  <li>Dynamics compression for overall control and sweetening of the mix </li>
  <li>Efficient <a href="#the-analysernode-interface">real-time time-domain and
    frequency analysis / music visualizer support</a></li>
  <li>Efficient biquad filters for lowpass, highpass, and other common filters.
  </li>
  <li>A Waveshaping effect for distortion and other non-linear effects</li>
  <li>Oscillators</li>

</ul>

<section>
<h2 id="ModularRouting">Modular Routing</h2>

<p>Modular routing allows arbitrary connections between different <a>AudioNode</a>
objects. Each node can
have <dfn>inputs</dfn> and/or <dfn>outputs</dfn>. A <dfn>source node</dfn> has no inputs
and a single output. A <dfn>destination node</dfn>  has
one input and no outputs, the most common example being <a
href="#AudioDestinationNode"><code>AudioDestinationNode</code></a> the final destination to the audio
hardware. Other nodes such as filters can be placed between the source and destination nodes.
The developer doesn't have to worry about low-level stream format details
when two objects are connected together; <a href="#channel-up-mixing-and-down-mixing">the right
thing just happens</a>. For example, if a mono audio stream is connected to a
stereo input it should just mix to left and right channels <a
href="#channel-up-mixing-and-down-mixing">appropriately</a>. </p>

<p>In the simplest case, a single source can be routed directly to the output.
All routing occurs within an <a
href="#AudioContext"><code>AudioContext</code></a> containing a single
<a href="#AudioDestinationNode"><code>AudioDestinationNode</code></a>:
</p>
<figure>
  <img alt="modular routing" src="images/modular-routing1.png">
  <figcaption>A simple example of modular routing.</figcaption>
</figure>

<p>Illustrating this simple routing, here's a simple example playing a single
sound: </p>

<pre class="highlight example">

var context = new AudioContext();

function playSound() {
    var source = context.createBufferSource();
    source.buffer = dogBarkingBuffer;
    source.connect(context.destination);
    source.start(0);
}
</pre>

<p>Here's a more complex example with three sources and a convolution reverb
send with a dynamics compressor at the final output stage: </p>
<figure>
  <img alt="modular routing2" src="images/modular-routing2.png" /> 
  <figcaption>A more complex example of modular rounting.</figcaption>
</figure>

<pre class="highlight example">

var context = 0;
var compressor = 0;
var reverb = 0;

var source1 = 0;
var source2 = 0;
var source3 = 0;

var lowpassFilter = 0;
var waveShaper = 0;
var panner = 0;

var dry1 = 0;
var dry2 = 0;
var dry3 = 0;

var wet1 = 0;
var wet2 = 0;
var wet3 = 0;

var masterDry = 0;
var masterWet = 0;

function setupRoutingGraph () {
    context = new AudioContext();

    // Create the effects nodes.
    lowpassFilter = context.createBiquadFilter();
    waveShaper = context.createWaveShaper();
    panner = context.createPanner();
    compressor = context.createDynamicsCompressor();
    reverb = context.createConvolver();

    // Create master wet and dry.
    masterDry = context.createGain();
    masterWet = context.createGain();

    // Connect final compressor to final destination.
    compressor.connect(context.destination);

    // Connect master dry and wet to compressor.
    masterDry.connect(compressor);
    masterWet.connect(compressor);

    // Connect reverb to master wet.
    reverb.connect(masterWet);

    // Create a few sources.
    source1 = context.createBufferSource();
    source2 = context.createBufferSource();
    source3 = context.createOscillator();

    source1.buffer = manTalkingBuffer;
    source2.buffer = footstepsBuffer;
    source3.frequency.value = 440;

    // Connect source1
    dry1 = context.createGain();
    wet1 = context.createGain();
    source1.connect(lowpassFilter);
    lowpassFilter.connect(dry1);
    lowpassFilter.connect(wet1);
    dry1.connect(masterDry);
    wet1.connect(reverb);

    // Connect source2
    dry2 = context.createGain();
    wet2 = context.createGain();
    source2.connect(waveShaper);
    waveShaper.connect(dry2);
    waveShaper.connect(wet2);
    dry2.connect(masterDry);
    wet2.connect(reverb);

    // Connect source3
    dry3 = context.createGain();
    wet3 = context.createGain();
    source3.connect(panner);
    panner.connect(dry3);
    panner.connect(wet3);
    dry3.connect(masterDry);
    wet3.connect(reverb);
    
    // Start the sources now.
    source1.start(0);
    source2.start(0);
    source3.start(0);
}
</pre>
</section>
</section>

<section>
<h2 id="APIOverview">API Overview</h2>

<p>The interfaces defined are: </p>
<ul>
  <li>An <a class="dfnref" href="#AudioContext">AudioContext</a>
    interface, which contains an audio signal graph representing connections
    betweens <a>AudioNode</a>s. </li>
  <li>An <a>AudioNode</a> interface,
    which represents audio sources, audio outputs, and intermediate processing
    modules. <a>AudioNode</a>s can be dynamically connected together in a <a
    href="#ModularRouting">modular fashion</a>. <code>AudioNodes</code>
    exist in the context of an <code>AudioContext</code> </li>
  <li>An <a>AudioDestinationNode</a> interface, an
    <a>AudioNode</a> subclass representing the final destination for all rendered
    audio. </li>
  <li>An <a>AudioBuffer</a>
    interface, for working with memory-resident audio assets. These can
    represent one-shot sounds, or longer audio clips. </li>
  <li>An <a>AudioBufferSourceNode</a> interface,
    an <a>AudioNode</a> which generates audio from an AudioBuffer. </li>
  <li>A <a>MediaElementAudioSourceNode</a>
    interface, an <a>AudioNode</a> which is the audio source from an
    <code>audio</code>, <code>video</code>, or other media element. </li>
  <li>A <a>MediaStreamAudioSourceNode</a>
    interface, an <a>AudioNode</a> which is the audio source from a
    MediaStream such as live audio input, or from a remote peer. </li>
  <li>A <a>MediaStreamAudioDestinationNode</a>
    interface, an <a>AudioNode</a> which is the audio destination to a
    MediaStream sent to a remote peer. </li>
  <li>A <a>ScriptProcessorNode</a> interface, an
    <a>AudioNode</a> for generating or processing audio directly in JavaScript. </li>
  <li>An <a>AudioProcessingEvent</a> interface,
    which is an event type used with <a>ScriptProcessorNode</a> objects.
  </li>
  <li>An <a>AudioParam</a> interface,
    for controlling an individual aspect of an <a>AudioNode</a>'s functioning, such as
    volume. </li>
  <li>An <a>GainNode</a>
    interface, for explicit gain control. Because inputs to <a>AudioNode</a>s support
    multiple connections (as a unity-gain summing junction), mixers can be <a
    href="#mixer-gain-structure">easily built</a> with GainNodes.
  </li>
  <li>A <a>BiquadFilterNode</a>
    interface, an <a>AudioNode</a> for common low-order filters such as:
    <ul>
      <li>Low Pass</li>
      <li>High Pass </li>
      <li>Band Pass </li>
      <li>Low Shelf </li>
      <li>High Shelf </li>
      <li>Peaking </li>
      <li>Notch </li>
      <li>Allpass </li>
    </ul>
  </li>
  <li>A <a>DelayNode</a> interface, an
    <a>AudioNode</a> which applies a dynamically adjustable variable delay. </li>
  <li>An <a>PannerNode</a>
    interface, for spatializing / positioning audio in 3D space. </li>
  <li>An <a>AudioListener</a>
    interface, which works with an <code>PannerNode</code> for
    spatialization. </li>
  <li>A <a>ConvolverNode</a>
    interface, an <a>AudioNode</a> for applying a <a href="#Convolution">real-time linear effect</a> (such as the sound
    of a concert hall). </li>
  <li>A <a>AnalyserNode</a> interface,
    for use with music visualizers, or other visualization applications. </li>
  <li>A <a>ChannelSplitterNode</a> interface,
    for accessing the individual channels of an audio stream in the routing
    graph. </li>
  <li>A <a>ChannelMergerNode</a> interface, for
    combining channels from multiple audio streams into a single audio stream.
  </li>
  <li>A <a>DynamicsCompressorNode</a> interface, an
    <a>AudioNode</a> for dynamics compression. </li>
  <li>A <a>WaveShaperNode</a>
    interface, an <a>AudioNode</a> which applies a non-linear waveshaping effect for
    distortion and other more subtle warming effects. </li>
  <li>A <a>OscillatorNode</a>
    interface, an audio source generating a periodic waveform. </li>
</ul>
</section>
</section>

<section id="conformance">
<p>The following conformance classes are defined by this specification: </p>
<dl>
  <dt><dfn id="dfn-conforming-implementation">conforming
  implementation</dfn></dt>
    <dd><p>A user agent is considered to be a <a class="dfnref"
      href="#dfn-conforming-implementation">conforming implementation</a> if it
      satisfies all of the MUST-, REQUIRED- and SHALL-level criteria in this specification that
      apply to implementations. </p>
    </dd>
</dl>
</section>

<section id=audioapi>
<h2 id="API">The Audio API</h2>

<section>
<h2 id="AudioContext">The AudioContext Interface</h2>

<p>This interface represents a set of <a>AudioNode</a> objects and their
connections. It allows for arbitrary routing of signals to the <a>AudioDestinationNode</a>
(what the user ultimately hears). Nodes are created from the context and are
then <a href="#ModularRouting">connected</a> together. In most use
cases, only a single <a>AudioContext</a> is used per document.</p>

<dl title="[Constructor] interface AudioContext : EventTarget" class="idl"
  data-merge="DecodeSuccessCallback DecodeErrorCallback">
  <dt>readonly attribute AudioDestinationNode destination</dt>
  <dd><p>An <a
    href="#AudioDestinationNode"><code>AudioDestinationNode</code></a>
    with a single input representing the final destination for all audio.
    Usually this will represent the actual audio hardware.
    All <a>AudioNode</a>s actively rendering
    audio will directly or indirectly connect to <code>destination</code>.</p>
  </dd>
  <dt> readonly attribute float sampleRate</dt>
  <dd><p>The sample rate (in sample-frames per second) at which the
    <a>AudioContext</a> handles audio. It is assumed that all <a>AudioNode</a>s in the
    context run at this rate. In making this assumption, sample-rate
    converters or "varispeed" processors are not supported in real-time
    processing.</p>
  </dd>
  <dt> readonly attribute double currentTime</dt>
  <dd><p>This is a time in seconds which starts at zero when the context is
    created and increases in real-time. All scheduled times are relative to
    it. This is not a "transport" time which can be started, paused, and
    re-positioned. It is always moving forward. A GarageBand-like timeline
    transport system can be very easily built on top of this (in JavaScript).
    This time corresponds to an ever-increasing hardware timestamp. </p>
  </dd>
  <dt> readonly attribute AudioListener listener </dt>
  <dd><p>An <a href="#AudioListener"><code>AudioListener</code></a>
    which is used for 3D <a
    href="#Spatialization">spatialization</a>.</p>
  </dd>

  <dt>AudioBuffer createBuffer()</dt>
  <dd> Creates an AudioBuffer of the given size. The audio data in the buffer will
  be zero-initialized (silent).  An NOT_SUPPORTED_ERR exception MUST be thrown
  if any of the arguments is negative, zero, or outside its nominal range.
  <dl class="parameters">
      <dt>unsigned long numberOfChannels</dt>
      <dd> Determines how many channels the buffer will have. An implementation
      must support at least 32 channels.</dd>
      <dt>unsigned long length</dt>
      <dd>Determines the size of the buffer in sample-frames.</dd>
      <dt>float sampleRate</dt>
      <dd>Describes the sample-rate of the linear PCM audio data in the buffer in
      sample-frames per second.  An implementation must support sample-rates in
      at least the range 22050 to 96000.</dd>
  </dl>
  </dd>

    <dt> void decodeAudioData() </dt>
    <dd>
      Asynchronously decodes the audio file data contained in the ArrayBuffer.
    The ArrayBuffer can, for example, be loaded from an XMLHttpRequest's
    <code>response</code> attribute after setting the <code>responseType</code>
    to "arraybuffer".  Audio file data can be in any of the formats supported by
    the <code>audio</code> element.
    <dl class=parameters>
      <dt> ArrayBuffer audioData </dt>
      <dd> An ArrayBuffer containing compressed audio data </dd>
      <dt> DecodeSuccessCallback successCallback </dt>
      <dd>
        A callback function which will be invoked when the decoding is finished.
        The single argument to this callback is an AudioBuffer representing the
        decoded PCM audio data.
      </dd>
      <dt> optional DecodeErrorCallback errorCallback </dt>
      <dd>
        A callback function which will be invoked if there is an error
        decoding the audio file.
      </dd>

    </dl>
      <p>
      The following steps must be performed:
      </p>
      <ol>
      <li>Temporarily neuter the <dfn>audioData</dfn> ArrayBuffer in such a way that JavaScript code may not
      access or modify the data.</li>
      <li>Queue a decoding operation to be performed on another thread.</li>
      <li>The decoding thread will attempt to decode the encoded <dfn>audioData</dfn> into linear PCM.
      If a decoding error is encountered due to the audio format not being recognized or supported, or
      because of corrupted/unexpected/inconsistent data then the <dfn>audioData</dfn> neutered state
      will be restored to normal and the <dfn>errorCallback</dfn> will be
      scheduled to run on the main thread's event loop and these steps will be terminated.</li>
      <li>The decoding thread will take the result, representing the decoded linear PCM audio data,
      and resample it to the sample-rate of the <a>AudioContext</a> if it is different from the sample-rate
      of <dfn>audioData</dfn>.  The final result (after possibly sample-rate converting) will be stored
      in an AudioBuffer.
      </li>
      <li>The <dfn>audioData</dfn> neutered state will be restored to normal
      </li>
      <li>
      The <dfn>successCallback</dfn> function will be scheduled to run on the main thread's event loop
      given the AudioBuffer from step (4) as an argument.
      </li>
      </ol>
    </dd>


    <dt> AudioBufferSourceNode createBufferSource() </dt>
    <dd>Creates an <a>AudioBufferSourceNode</a>.
    </dd>

    <dt>MediaElementAudioSourceNode createMediaElementSource()</dt>
    <dd>
    Creates a <a href="#MediaElementAudioSourceNode">MediaElementAudioSourceNode</a>
    given an HTMLMediaElement.  As a consequence of calling this method, audio
    playback from the HTMLMediaElement will be re-routed into the processing graph
    of the <a>AudioContext</a>.
      <dl class=parameters>
        <dt> HTMLMediaElement mediaElement </dt>
        <dd> The media element that will be re-routed. </dd>
      </dl>
    </dd>

    <dt> MediaStreamAudioSourceNode createMediaStreamSource() </dt>
    <dd>
    <dl class=parameters>
      <dt>MediaStream mediaStream</dt>
      <dd> The media stream that will act as source. </dd>
    </dl>
    </dd>

    <dt> MediaStreamAudioDestinationNode createMediaStreamDestination() </dt>
    <dd>Creates a <a>MediaStreamAudioDestinationNode</a> </dd>

    <dt> ScriptProcessorNode createScriptProcessor()</dt>
    <dd>
    <p>
      Creates a <a>ScriptProcessorNode</a> for direct audio processing using
      JavaScript.  An INDEX_SIZE_ERR exception MUST be thrown if
      <a>bufferSize</a> or <a>numberOfInputChannels</a> or
      <a>numberOfOutputChannels</a> are outside the valid range.
    </p>
      <dl class=parameters>
        <dt> optional unsigned long bufferSize = 0 </dt>
        <dd>
          The <a>bufferSize</a> parameter determines the buffer size in units of
          sample-frames.  If it's not passed in, or if the value is 0, then the
          implementation will choose the best buffer size for the given
          environment, which will be constant power of 2 throughout the lifetime
          of the node. Otherwise if the author explicitly specifies the
          bufferSize, it must be one of the following values: 256, 512, 1024,
          2048, 4096, 8192, 16384. This value controls how frequently the
          <a>audioprocess</a> event is dispatched and how many sample-frames
          need to be processed each call. Lower values for <a>bufferSize</a>
          will result in a lower (better) <a href="#latency">latency</a>. Higher
          values will be necessary to avoid audio breakup and
          <a href="#audio-glitching">glitches</a>.
          It is recommended for authors to not specify this buffer size and
          allow the implementation to pick a good buffer size to balance between
          <a href="#latency">latency</a> and audio quality.
          </dd>
        <dt> optional unsigned long numberOfInputChannels = 2 </dt>
        <dd>
          This parameter determines the number of channels for this node's
          input. Values of up to 32 must be supported.
        </dd>
        <dt> optional unsigned long numberOfOutputChannels = 2 </dt>
        <dd>
          This parameter determines the number of channels for this node's
          output. Values of up to 32 must be supported.
        </dd>
      </dl>
      It is invalid for both <a>numberOfInputChannels</a> and
      <a>numberOfOutputChannels</a> to be zero.
    </dd>

    <dt> AnalyserNode createAnalyser() </dt>
    <dd>Create an <a>AnalyserNode</a>.</dd>
    <dt> GainNode createGain() </dt>
    <dd>Create an <a>GainNode</a>.</dd>
    <dt> DelayNode createDelay() </dt>
    <dd>
        Creates a <a>DelayNode</a> representing a variable delay line. The
        initial default delay time will be 0 seconds.
      <dl class=parameters>
        <dt> optional double maxDelayTime = 1.0 </dt>
        <dd>
          The <dfn>maxDelayTime</dfn> parameter is optional and specifies the
          maximum delay time in seconds allowed for the delay line.  If
          specified, this value MUST be greater than zero and less than three
          minutes or a NOT_SUPPORTED_ERR exception MUST be thrown.
        </dd>
      </dl>
    </dd>
    <dt> BiquadFilterNode createBiquadFilter() </dt>
    <dd>Creates a <a>BiquadFilterNode</a>
      representing a second order filter which can be configured as one of
      several common filter types.
    </dd>
    <dt> WaveShaperNode createWaveShaper() </dt>
    <dd>
      Creates a <a>WaveShaperNode</a> representing a non-linear distortion.
    </dd>
    <dt> PannerNode createPanner() </dt>
    <dd>
      Creates an <a>PannerNode</a>.
    </dd>
    <dt> ConvolverNode createConvolver() </dt>
    <dd>
      Creates a <a>ConvolverNode</a>.
    </dd>
    <dt> ChannelSplitterNode createChannelSplitter() </dt>
    <dd>
      Creates an <a>ChannelSplitterNode</a>
      representing a channel splitter. An INDEX_SIZE_ERR exception MUST be thrown
      for invalid parameter values.
      <dl class=parameters>
        <dt> optional unsigned long numberOfOutputs = 6 </dt>
        <dd>
          The number of outputs.  Values of up to 32 must be supported.  If not
          specified, then 6 will be used.
        </dd>
      </dl>
    </dd>
    <dt> ChannelMergerNode createChannelMerger() </dt>
    <dd>
      Creates a <a>ChannelMergerNode</a> representing a channel merger.  An
      INDEX_SIZE_ERR exception MUST be thrown for invalid parameter values.
      <dl class=parameters>
        <dt> optional unsigned long numberOfInputs = 6 </dt>
        <dd>
          The <dfn>numberOfInputs</dfn> parameter determines the number of inputs.
          Values of up to 32 must be supported.  If not specified, then 6 will be
          used.
        </dd>
      </dl>
    </dd>

    <dt> DynamicsCompressorNode createDynamicsCompressor() </dt>
    <dd>Creates a <a>DynamicsCompressorNode</a></dd>

    <dt> OscillatorNode createOscillator() </dt>
    <dd>Creates an <a>OscillatorNode</a></dd>
    <dt> PeriodicWave createPeriodicWave() </dt>
    <dd>
    Creates a <a>PeriodicWave</a> representing a waveform containing arbitrary
    harmonic content.  The <code>real</code> and <code>imag</code> parameters
    must be of type <code>Float32Array</code> of equal lengths greater than zero
    and less than or equal to 4096 or an INDEX_SIZE_ERR exception MUST be
    thrown.  These parameters specify the Fourier coefficients of a
    <a href="http://en.wikipedia.org/wiki/Fourier_series">Fourier series</a>
    representing the partials of a periodic waveform.  The created
    <a>PeriodicWave</a> will be used with an <a>OscillatorNode</a> and will
    represent a <em>normalized</em> time-domain waveform having maximum absolute
    peak value of 1.  Another way of saying this is that the generated waveform of
    an <a>OscillatorNode</a> will have maximum peak value at 0dBFS. Conveniently,
    this corresponds to the full-range of the signal values used by the Web Audio
    API.  Because the PeriodicWave will be normalized on creation, the
    <code>real</code> and <code>imag</code> parameters represent <em>relative</em>
    values.

    <dl class=parameters>
      <dt> Float32Array real </dt>
      <dd>
        The <dfn id="dfn-real">real</dfn> parameter represents an array of
        <code>cosine</code> terms (traditionally the A terms).  In audio
        terminology, the first element (index 0) is the DC-offset of the periodic
        waveform and is usually set to zero.  The second element (index 1)
        represents the fundamental frequency.  The third element represents the
        first overtone, and so on.
      </dd>
      <dt>Float32Array imag</dt>
      <dd>
        The <dfn id="dfn-imag">imag</dfn> parameter represents an array of
        <code>sine</code> terms (traditionally the B terms).  The first element
        (index 0) should be set to zero (and will be ignored) since this term does
        not exist in the Fourier series.  The second element (index 1) represents
        the fundamental frequency.  The third element represents the first
        overtone, and so on.
      </dd>
    </dl>
    </dd>
</dl>
<dl title="callback DecodeSuccessCallback = void" class="idl">
  <dt> AudioBuffer decodedData </dt>
  <dd> The AudioBuffer containing the decoded audio data. </dd>
</dl>

<dl title="callback DecodeErrorCallback = void" class="idl"> </dl>


<h3 id="lifetime-AudioContext">Lifetime</h3>

<p>
Once created, an <code>AudioContext</code> will continue to play sound until it has no more sound to play, or
the page goes away.
</p>

</section>
<section>
<h2 id="OfflineAudioContext">The OfflineAudioContext Interface</h2>
<p>
OfflineAudioContext is a particular type of <a>AudioContext</a> for rendering/mixing-down (potentially) faster than real-time.
It does not render to the audio hardware, but instead renders as quickly as possible, calling a completion event handler
with the result provided as an AudioBuffer.
</p>

<dl title='[Constructor(unsigned long numberOfChannels, unsigned long length,
  float sampleRate)] interface OfflineAudioContext : AudioContext' class='idl'>
  <dt>void startRendering()</dt>
  <dd><p>Given the current connections and scheduled changes, starts rendering audio.  The
  <code>oncomplete</code> handler will be called once the rendering has finished.
  This method must only be called one time or an INVALID_STATE_ERR exception MUST be thrown.</p>
  </dd>
  <dt>attribute EventHandler oncomplete</dt>
    <dd><p>An EventHandler of type <a href="#OfflineAudioCompletionEvent">OfflineAudioCompletionEvent</a>.</p>
    </dd>
</dl>

<section>
<h2 id="OfflineAudioCompletionEvent">The OfflineAudioCompletionEvent Interface</h2>

<p>This is an <code>Event</code> object which is dispatched to <a
href="#OfflineAudioContext"><code>OfflineAudioContext</code></a>. </p>

<dl title="interface OfflineAudioCompletionEvent : Event" class="idl">
  <dt>readonly attribute AudioBuffer renderedBuffer</dt>
  <dd><p>An AudioBuffer containing the rendered audio data once an OfflineAudioContext has finished rendering.
  It will have a number of channels equal to the <code>numberOfChannels</code> parameter
  of the OfflineAudioContext constructor.</p>
  </dd>
</dl>

</section>
</section>


<section>
<h2>The AudioNode Interface</h2>

<p>AudioNodes are the building blocks of an <a
href="#AudioContext"><code>AudioContext</code></a>. This interface
represents audio sources, the audio destination, and intermediate processing
modules. These modules can be connected together to form <a
href="#ModularRouting">processing graphs</a> for rendering audio to the
audio hardware. Each node can have <dfn>inputs</dfn> and/or <dfn>outputs</dfn>.
A <dfn>source node</dfn> has no inputs
and a single output. An <a
href="#AudioDestinationNode"><code>AudioDestinationNode</code></a> has
one input and no outputs and represents the final destination to the audio
hardware. Most processing nodes such as filters will have one input and one
output.  Each type of <code>AudioNode</code> differs in the details of how it processes or synthesizes audio.  But, in general, <code>AudioNodes</code>
will process its inputs (if it has any), and generate audio for its outputs (if it has any).
 </p>
 
<p>
Each <dfn>output</dfn> has one or more <dfn>channels</dfn>.  The exact number of channels depends on the details of the specific <a>AudioNode</a>.
</p>

<p>
An output may connect to one or more <code>AudioNode</code> inputs, thus <em>fan-out</em> is supported.  An input initially has no connections,
but may be connected from one
or more <code>AudioNode</code> outputs, thus <em>fan-in</em> is supported.  When the <code>connect()</code> method is called to connect
an output of an <a>AudioNode</a> to an input of an <a>AudioNode</a>, we call that a <dfn>connection</dfn> to the input.
</p>

<p>
Each <a>AudioNode</a> <dfn>input</dfn> has a specific number of channels at any given time.  This number can change depending on the <dfn>connection(s)</dfn>
made to the input.  If the input has no connections then it has one channel which is silent.
</p>

<p>
For each <dfn>input</dfn>, an <code>AudioNode</code> performs a mixing (usually an up-mixing) of all connections to that input.

Please see <a href="#mixer-gain-structure"></a> for more informative details,
and the <a href="#channel-up-mixing-and-down-mixing"></a>
  section for normative requirements.

</p>

<p>
For performance reasons, practical implementations will need to use block processing, with each <code>AudioNode</code> processing a
fixed number of sample-frames of size <em>block-size</em>.  In order to get uniform behavior across implementations, we will define this
value explicitly.  <em>block-size</em> is defined to be 128 sample-frames which corresponds to roughly 3ms at a sample-rate of 44.1KHz.
</p>

<p>
AudioNodes are <em>EventTarget</em>s, as described in <cite><a href="http://dom.spec.whatwg.org/">DOM</a></cite>
[[!DOM]].  This means that it is possible to dispatch events to <a>AudioNode</a>s the same
way that other EventTargets accept events.
</p>

<dl title="enum ChannelCountMode" class="idl">
  <dt>max</dt>
  <dd><a>computedNumberOfChannels</a> is computed as the maximum of the number of channels of all connections. In this mode channelCount is ignored</dd>
  <dt>clamped-max</dt>
  <dd>Same as “max” up to a limit of the channelCount</dd>
  <dt>explicit</dt>
  <dd><a>computedNumberOfChannels</a> is the exact value as specified in channelCount</dd>
</dl>

<dl title="enum ChannelInterpretation" class="idl">
  <dt>speakers</dt>
  <dd>
    use <a href="#ChannelLayouts">up-down-mix equations for mono/stereo/quad/5.1</a>. In cases where
    the number of channels do not match any of these basic speaker layouts, revert
    to "discrete".
  </dd>
  <dt>discrete</dt>
  <dd>
    Up-mix by filling channels until they run out then zero out remaining
    channels. down-mix by filling as many channels as possible, then dropping
    remaining channels.
  </dd>
</dl>

<dl title="interface AudioNode : EventTarget" class="idl">
  <dt>void connect()</dt>
  <dd>
    <dl class=parameters>
      <dt>AudioNode destination</dt>
      <dd> The <code>destination</code> parameter is the <a>AudioNode</a> to connect to. </dd>
      <dt>optional unsigned long output = 0 </dt>
      <dd>
        The <code>output</code> parameter is an index describing which output of the
        <a>AudioNode</a> from which to connect. If this paremeter is out-of-bound, an
        INDEX_SIZE_ERR exception MUST be thrown.
        It is possible to connect an <a>AudioNode</a> output to more than one input
        with multiple calls to connect(). Thus, "fan-out" is supported.
      </dd>
      <dt>optional unsigned long input = 0</dt>
      <dd>
        The <code>input</code> parameter is an index describing which input of
        the destination <a>AudioNode</a> to connect to. If this parameter is out-of
        ound, an INDEX_SIZE_ERR exception MUST be thrown.  It is possible to
        connect an <a>AudioNode</a> to another <a>AudioNode</a> which creates a
        <em>cycle</em>.  In other words, an <a>AudioNode</a> may connect to another
        <a>AudioNode</a>, which in turn connects back to the first
        <a>AudioNode</a>.  This is allowed only if there is at least one
        <a>DelayNode</a> in the <em>cycle</em> or a NOT_SUPPORTED_ERR exception
        MUST be thrown.
      </dd>

    </dl>
    <p>
      There can only be one connection between a given output of one specific
      node and a given input of another specific node.  Multiple connections
      with the same termini are ignored.  For example:
    </p>

    <pre class="highlight example">
    nodeA.connect(nodeB);
    nodeA.connect(nodeB);
    </pre>

    <p>
      will have the same effect as
    </p>

    <pre class="highlight example">
      nodeA.connect(nodeB);
    </pre>
  </dd>
  <dt>
    void connect()
  </dt>
  <dd>
    Connects the <a>AudioNode</a> to an <a>AudioParam</a>, controlling the parameter
    value with an audio-rate signal.

    <dl class=parameters>
      <dt> AudioParam destination </dt>
      <dd>The <code>destination</code> parameter is the <a>AudioParam</a> to connect to.</dd>
      <dt> optional unsigned long output = 0 </dt>
      <dd>
        The <code>output</code> parameter is an index describing which output of the
        <a>AudioNode</a> from which to connect. If the <code> parameter</code> is
        out-of-bound, an INDEX_SIZE_ERR exception MUST be thrown.
      </dd>
    </dl>

    <p>It is possible to connect an <a>AudioNode</a> output to more than one
    <a>AudioParam</a> with multiple calls to connect(). Thus, "fan-out" is supported.
    </p> <p>It is possible to connect more than one <a>AudioNode</a> output to a
    single <a>AudioParam</a> with multiple calls to connect().  Thus, "fan-in" is
    supported. </p> <p>An <a>AudioParam</a> will take the rendered audio data from
    any <a>AudioNode</a> output connected to it and <a href="#down-mix">convert it to
    mono</a> by down-mixing if it is not already mono, then mix it together
    with other such outputs and finally will mix with the <em>intrinsic</em>
    parameter value (the <code>value</code> the <a>AudioParam</a> would normally have
    without any audio connections), including any timeline changes scheduled
    for the parameter. </p>

    <p> There can only be one connection between a given output of one
    specific node and a specific <a>AudioParam</a>.  Multiple connections with the
    same termini are ignored.  For example: </p>

    <pre class="highlight">
      nodeA.connect(param);
      nodeA.connect(param);
    </pre>

    will have the same effect as

    <pre>
      nodeA.connect(param);
    </pre>
  </dd>
  <dt>void disconnect()</dt>
  <dd>
  <dl>
    <dt>optional unsigned long output = 0</dt>
    <dd>
      The <dfn>output</dfn> parameter is an index describing which output of
      the <a>AudioNode</a> to disconnect. If the <dfn>output</dfn> parameter is
      out-of-bounds, an INDEX_SIZE_ERR exception MUST be thrown.
    </dd>
  </dl>
  </dd>

  <dt>readonly attribute AudioContext context</dt>
  <dd>The <a>AudioContext</a> which owns this <a>AudioNode</a>.</dd>
  <dt>readonly attribute unsigned long numberOfInputs</dt>
  <dd>
    The number of inputs feeding into the <a>AudioNode</a>. For <dfn>source
    nodes</dfn>, this will be 0.
  </dd>
  <dt>readonly attribute unsigned long numberOfOutputs</dt>
  <dd>
    The number of outputs coming out of the <a>AudioNode</a>. This will be 0
    for an <a>AudioDestinationNode</a>.
  </dd>

  <dt>attribute unsigned long <dfn>channelCount</dfn></dt>
  <dd>
    <p>The number of channels used when up-mixing and down-mixing connections
    to any inputs to the node.  The default value is 2 except for specific
    nodes where its value is specially determined.  This attribute has no
    effect for nodes with no inputs.  If this value is set to zero, the
    implementation MUST throw a NOT_SUPPORTED_ERR exception.</p>
    <p>See the <a href="#channel-up-mixing-and-down-mixing"></a>
    section for more information on this attribute.</p>
  </dd>
  <dt>attribute ChannelCountMode channelCountMode</dt>
  <dd>
    <p>
      Determines how channels will be counted when up-mixing and down-mixing
      connections to any inputs to the node .  This attribute has no effect
      for nodes with no inputs.
    </p>
    <p>
      See the <a href="#channel-up-mixing-and-down-mixing"></a> section
      for more information on this attribute.
    </p>
  </dd>
  <dt>attribute ChannelInterpretation channelInterpretation</dt>
  <dd>
    <p>
      Determines how individual channels will be treated when up-mixing and
      down-mixing connections to any inputs to the node.  This attribute has
      no effect for nodes with no inputs.
    </p>
    <p>
      See the <a href="#channel-up-mixing-and-down-mixing"></a> section
      for more information on this attribute.
    </p>
  </dd>
</dl>

<section>
  <h3 id="lifetime-AudioNode" class="informative">Lifetime</h3>

  <p>
    An implementation may choose any method to avoid unnecessary resource usage
    and unbounded memory growth of unused/finished nodes.  The following is a
    description to help guide the general expectation of how node lifetime would
    be managed.
  </p>
  
  <p>
    An <code>AudioNode</code> will live as long as there are any references to it.
    There are several types of references:
  </p>
  
  <ol>
  <li>A <em>normal</em> JavaScript reference obeying normal garbage collection rules. </li>
  <li>A <em>playing</em> reference for both <code>AudioBufferSourceNodes</code> and <code>OscillatorNodes</code>.
  These nodes maintain a <em>playing</em>
  reference to themselves while they are currently playing.</li>
  <li>A <em>connection</em> reference which occurs if another <code>AudioNode</code> is connected to it.   </li>
  <li>A <em>tail-time</em> reference which an <code>AudioNode</code> maintains on itself as long as it has
  any internal processing state which has not yet been emitted.  For example, a <code>ConvolverNode</code> has
  a tail which continues to play even after receiving silent input (think about clapping your hands in a large concert
    hall and continuing to hear the sound reverberate throughout the hall).  Some <code>AudioNodes</code> have this
    property.  Please see details for specific nodes.</li>
  </ol>
  
  <p>
  Any <code>AudioNodes</code> which are connected in a cycle <em>and</em> are directly or indirectly connected to the
  <code>AudioDestinationNode</code> of the <code>AudioContext</code> will stay alive as long as the <code>AudioContext</code> is alive.
  </p>
  
  <p>
  When an <code>AudioNode</code> has no references it will be deleted.  But before it is deleted, it will disconnect itself
  from any other <code>AudioNodes</code> which it is connected to.  In this way it releases all connection references (3) it has to other nodes.
  </p>
  
  <p>
  Regardless of any of the above references, it can be assumed that the <code>AudioNode</code> will be deleted when its <code>AudioContext</code> is deleted.
  </p>
</section>
</section>


<section>
<h2 id="AudioDestinationNode">The AudioDestinationNode Interface</h2>

<p>This is an <a>AudioNode</a> representing the final audio destination and is
what the user will ultimately hear. It can often be considered as an audio
output device which is connected to speakers. All rendered audio to be heard
will be routed to this node, a "terminal" node in the <a>AudioContext</a>'s routing
graph. There is only a single AudioDestinationNode per <a>AudioContext</a>, provided
through the <code>destination</code> attribute of <a>AudioContext</a>. </p>
<pre>
      numberOfInputs  : 1
      numberOfOutputs : 0

      channelCount = 2;
      channelCountMode = "explicit";
      channelInterpretation = "speakers";
</pre>

<dl title="interface AudioDestinationNode : AudioNode" class="idl">
  <dt>readonly attribute unsigned long maxChannelCount</dt>
  <dd>
    <p>
    The maximum number of channels that the <code><a
        href="#widl-AudioNode-channelCount">channelCount</a></code> attribute
    can be set to.  An <a>AudioDestinationNode</a> representing the audio
    hardware end-point (the normal case) can potentially output more than 2
    channels of audio if the audio hardware is multi-channel.
    <code>maxChannelCount</code> is the maximum number of channels that this
    hardware is capable of supporting.  If this value is 0, then this indicates
    that <a href="#widl-AudioNode-channelCount">channelCount</a> may not be
    changed.  This will be the case for an <a>AudioDestinationNode</a> in an
    <a>OfflineAudioContext</a> and also for basic implementations with hardware
    support for stereo output only.
    </p>

    <p>
      <a href="#widl-AudioNode-channelCount">channelCount</a> defaults to 2 for
      a destination in a normal <a>AudioContext</a>, and may be set to any
      non-zero value less than or equal to <code>maxChannelCount</code>.  An
      <a>INDEX_SIZE_ERR</a> exception MUST be thrown if this value is not within
      the valid range.  Giving a concrete example, if the audio hardware
      supports 8-channel output, then we may set <a
      href="#widl-AudioNode-channelCount">channelCount</a> to 8, and render
      8-channels of output.
    </p>

    <p>
      For an <code><a>AudioDestinationNode</a></code> in an
      <code><a>OfflineAudioContext</a></code>, the <code><a
      href="#widl-AudioNode-channelCount">channelCount</a></code> is determined
      when the offline context is created and this value may not be changed.
    </p>
  </dd>
</dl>

</section>

<section>
<h2 id="AudioParam">The AudioParam Interface</h2>

<p>
  <a>AudioParam</a> controls an individual aspect of an <a>AudioNode</a>'s functioning,
  such as volume.  The parameter can be set immediately to a particular value
  using the <code>value</code> attribute. Or, value changes can be scheduled to
  happen at very precise times (in the coordinate system of
  <a>AudioContext</a>'s <a href="#widl-AudioContext-currentTime">currentTime</a>
  attribute), for envelopes, volume fades, LFOs, filter sweeps,
  grain windows, etc. In this way, arbitrary timeline-based automation curves
  can be set on any <a>AudioParam</a>.  Additionally, audio signals from the outputs of
  <a>AudioNode</a>s can be connected to an <a>AudioParam</a>, summing with the
  <em>intrinsic</em> parameter value.
</p>

<p>
  Some synthesis and processing <code>AudioNodes</code> have
  <code>AudioParams</code> as attributes whose values must be taken into account
  on a per-audio-sample basis.  For other <code>AudioParams</code>,
  sample-accuracy is not important and the value changes can be sampled more
  coarsely.  Each individual <code>AudioParam</code> will specify that it is
  either an <em>a-rate</em> parameter which means that its values must be taken
  into account on a per-audio-sample basis, or it is a <em>k-rate</em>
  parameter.
</p>

<p>
  Implementations must use block processing, with each <a>AudioNode</a>
  processing 128 sample-frames in each block.
</p>

<p>
  For each 128 sample-frame block, the value of a <em>k-rate</em> parameter must
  be sampled at the time of the very first sample-frame, and that value must be
  used for the entire block.  <em>a-rate</em> parameters must be sampled for
  each sample-frame of the block.
</p>

<p>
  An <code>AudioParam</code> maintains a time-ordered event list which is
  initially empty.  The times are in the time coordinate system of
  the <a>AudioContext</a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.  The events define a mapping from time to value.
  The following methods can change the event list by adding a new event into the
  list of a type specific to the method.  Each event has a time associated with
  it, and the events will always be kept in time-order in the list.  These
  methods will be called <em>automation</em> methods:
</p>

<ul>
<li>setValueAtTime() - <em>SetValue</em></li>
<li>linearRampToValueAtTime() - <em>LinearRampToValue</em></li>
<li>exponentialRampToValueAtTime() - <em>ExponentialRampToValue</em></li>
<li>setTargetAtTime() - <em>SetTarget</em></li>
<li>setValueCurveAtTime() - <em>SetValueCurve</em></li>
</ul>

<p>
The following rules will apply when calling these methods:
</p>
<ul>
  <li>
    If one of these events is added at a time where there is already an event
    of the exact same type, then the new event will replace the old one.
  </li>
  <li>
    If one of these events is added at a time where there is already one or more
    events of a different type, then it will be placed in the list after them, but
    before events whose times are after the event.
  </li>
  <li>
    If setValueCurveAtTime() is called for time T and duration D and there are any
    events having a time greater than T, but less than T + D, then a
    NOT_SUPPORTED_ERR exception MUST be thrown.  In other words, it's not ok to
    schedule a value curve during a time period containing other events.
  </li>
  <li>
    Similarly a NOT_SUPPORTED_ERR exception MUST be thrown if any
    <em>automation</em> method is called at a time which is inside of the time
    interval of a <em>SetValueCurve</em> event at time T and duration D.
  </li>
</ul>

<dl title="interface AudioParam" class="idl">
  <dt> attribute float value </dt>
  <dd>
    <p>
      The parameter's floating-point value.  This attribute is initialized to
      the <code>defaultValue</code>.  If <code>value</code> is set during a time
      when there are any automation events scheduled then it will be ignored and
      no exception will be thrown.
    </p>
  </dd>
  <dt> readonly attribute float defaultValue </dt>
  <dd>
    Initial value for the <code>value</code> attribute.
  </dd>

  <dt> void setValueAtTime(float value, double startTime) </dt>
  <dd>
    <p>
      Schedules a parameter value change at the given time.
    </p>
    <p>
      The <dfn id="dfn-value_2">value</dfn> parameter is the value the parameter
      will change to at the given time.
    </p>
    <p>
      The <dfn id="dfn-startTime_2">startTime</dfn> parameter is the time
      in the same time coordinate system as the <a>AudioContext</a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.
    </p>
    <p>
      If there are no more events after this <em>SetValue</em> event, then for t
      &gt;= startTime,  v(t) = value.  In other words, the value will remain
      constant.
    </p>
    <p>
      If the next event (having time T1) after this <em>SetValue</em> event is
      not of type <em>LinearRampToValue</em> or <em>ExponentialRampToValue</em>,
      then, for t:
    </p>
    <pre>
      startTime &lt;= t &lt; T1,  v(t) = value
    </pre>
    <p>
       In other words, the value will remain constant during this time interval,
       allowing the creation of "step" functions.
    </p>
    <p>
      If the next event after this <em>SetValue</em> event is of type
      <em>LinearRampToValue</em> or <em>ExponentialRampToValue</em> then please
      see details below.
    </p>
  </dd>
  <dt> void linearRampToValueAtTime(float value, double endTime) </dt>
  <dd>
    <p>
      Schedules a linear continuous change in parameter value from the previous
      scheduled parameter value to the given value.</p> <p>The <dfn
      id="dfn-value_3">value</dfn> parameter is the value the parameter will
      linearly ramp to at the given time.</p> <p>The <dfn
      id="dfn-endTime_3">endTime</dfn> parameter is the time in the same time
      coordinate system as the <a>AudioContext</a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.
    </p>

    <p>
      The value during the time interval T0 &lt;= t &lt; T1 (where T0 is the time
      of the previous event and T1 is the endTime parameter passed into this
      method) will be calculated as:
    </p>
    <pre>
      v(t) = V0 + (V1 - V0) * ((t - T0) / (T1 - T0))
    </pre>
    <p>
      Where V0 is the value at the time T0 and V1 is the value parameter passed
      into this method.
    </p>
    <p>
      If there are no more events after this LinearRampToValue event then for t
      &gt;= T1, v(t) = V1.
    </p>
  </dd>
  <dt> void exponentialRampToValueAtTime(float value, double endTime) </dt>
  <dd>
    <p>
      Schedules an exponential continuous change in parameter value from
      the previous scheduled parameter value to the given value. Parameters
      representing filter frequencies and playback rate are best changed
      exponentially because of the way humans perceive sound.
    </p>
    <p>
      The <dfn id="dfn-value_4">value</dfn> parameter is the value the parameter
      will exponentially ramp to at the given time.  A NOT_SUPPORTED_ERR exception
      MUST be thrown if this value is less than or equal to 0, or if the value at
      the time of the previous event is less than or equal to 0.
    </p>
    <p>
      The <dfn id="dfn-endTime_4">endTime</dfn> parameter is the time in the same
      time coordinate system as the <a>AudioContext</a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.
    </p>
    <p>
      The value during the time interval T0 &lt;= t &lt; T1 (where T0 is the time
      of the previous event and T1 is the endTime parameter passed into this
      method) will be calculated as:
    </p>
    <pre>
        v(t) = V0 * (V1 / V0) ^ ((t - T0) / (T1 - T0))
    </pre>
    <p>
      Where V0 is the value at the time T0 and V1 is the value parameter passed into
      this method.
    </p>
    <p>
      If there are no more events after this ExponentialRampToValue event then for t
      &gt;= T1, v(t) = V1
    </p>
  </dd>
  <dt> void setTargetAtTime(float target, double startTime, double timeConstant) </dt>
  <dd>
    <p>
      Start exponentially approaching the target value at the given time
      with a rate having the given time constant. Among other uses, this is
      useful for implementing the "decay" and "release" portions of an ADSR
      envelope. Please note that the parameter value does not immediately
      change to the target value at the given time, but instead gradually
      changes to the target value.
    </p>
    <p>
      The <dfn id="dfn-target">target</dfn> parameter is the value
      the parameter will <em>start</em> changing to at the given time.
    </p>
    <p>
      The <dfn id="dfn-startTime">startTime</dfn> parameter is the time in the
      same time coordinate system as the <a>AudioContext</a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.
    </p>
    <p>
      The <dfn id="dfn-timeConstant">timeConstant</dfn> parameter is the
      time-constant value of first-order filter (exponential) approach to the
      target value. The larger this value is, the slower the transition will
      be.
    </p>
    <p>
      More precisely, <em>timeConstant</em> is the time it takes a first-order
      linear continuous time-invariant system to reach the value 1 - 1/e (around
      63.2%) given a step input response (transition from 0 to 1 value).
    </p>
    <p>
      During the time interval: <em>T0</em> &lt;= t &lt; <em>T1</em>, where T0
      is the <em>startTime</em> parameter and T1 represents the time of the
      event following this event (or <em>infinity</em> if there are no following
      events):
    </p>
    <pre>
    v(t) = V1 + (V0 - V1) * exp(-(t - T0) / <em>timeConstant</em>)
    </pre>
    <p>
      Where V0 is the initial value (the .value attribute) at T0 (the
      <em>startTime</em> parameter) and V1 is equal to the <em>target</em>
      parameter.
    </p>
    </dd>
  <dt> void setValueCurveAtTime(Float32Array values, double startTime, double duration) </dt>
    <dd>
      <p>
        Sets an array of arbitrary parameter values starting at the given
        time for the given duration. The number of values will be scaled to fit
        into the desired duration.
      </p>
      <p>
        The <dfn id="dfn-values">values</dfn> parameter is a Float32Array
        representing a parameter value curve. These values will apply starting at
        the given time and lasting for the given duration. 
      </p>
      <p>
        The <dfn id="dfn-startTime_5">startTime</dfn> parameter is the time in the
        same time coordinate system as the <a>AudioContext</a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.
      </p>
      <p>
        The <dfn id="dfn-duration_5">duration</dfn> parameter is the amount of
        time in seconds (after the <em>time</em> parameter) where values will be
        calculated according to the <em>values</em> parameter.
      </p>
      <p>
        During the time interval: <em>startTime</em> &lt;= t &lt;
        <em>startTime</em> + <em>duration</em>, values will be calculated:
      </p>
      <pre>
        v(t) = values[N * (t - startTime) / duration]
      </pre>
      <p>
        where <em>N</em> is the length of the <em>values</em> array.
      </p>
      <p>
        After the end of the curve time interval (t &gt;= <em>startTime</em> +
        <em>duration</em>), the value will remain constant at the final curve
        value, until there is another automation event (if any).
      </p>
    </dd>
  <dt> void cancelScheduledValues(double startTime) </dt>
    <dd>
      <p>
        Cancels all scheduled parameter changes with times greater than or
        equal to startTime.
      </p>
      <p>
        The <dfn>startTime</dfn> parameter is the starting time at and after
        which any previously scheduled parameter changes will be cancelled.  It
        is a time in the same time coordinate system as
        the <a>AudioContext</a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.
      </p>
    </dd>
</dl>

<section>
<h3>Computation of Value</h3>

<p>
<dfn>computedValue</dfn> is the final value controlling the audio DSP and is computed by the audio rendering thread during each rendering time quantum.
  It must be internally computed as follows:
</p>

<ol>
<li>An <em>intrinsic</em> parameter value will be calculated at each time, which is either the value set directly to the <code>value</code> attribute,
or, if there are any scheduled parameter changes (automation events) with times before or at this time,
the value as calculated from these events.  If the <code>value</code> attribute
is set after any automation events have been scheduled, then these events will be removed.  When read, the <code>value</code> attribute
always returns the <em>intrinsic</em> value for the current time.  If automation events are removed from a given time range, then the
<em>intrinsic</em> value will remain unchanged and stay at its previous value until either the <code>value</code> attribute is directly set, or automation events are added
for the time range.
</li>

<li>
An <a>AudioParam</a> will take the rendered audio data from any <a>AudioNode</a> output connected to it and <a href="#down-mix">convert it to mono</a> by down-mixing if it is not
already mono, then mix it together with other such outputs.  If there are no <a>AudioNode</a>s connected to it, then this value is 0, having no
effect on the <em>computedValue</em>.
</li>

<li>
The <em>computedValue</em> is the sum of the <em>intrinsic</em> value and the value calculated from (2).
</li>

</ol>
</section>


<section>
<h3 id="example1-AudioParam">AudioParam Automation Example</h3>

<figure>
  <img alt="AudioParam automation" src="images/audioparam-automation1.png">
  <figcaption>An example of parameter automation.</figcaption>
</figure>
<pre class="code example"><code class="es-code highlight">
var t0 = 0;
var t1 = 0.1;
var t2 = 0.2;
var t3 = 0.3;
var t4 = 0.4;
var t5 = 0.6;
var t6 = 0.7;
var t7 = 1.0;

var curveLength = 44100;
var curve = new Float32Array(curveLength);
for (var i = 0; i &lt; curveLength; ++i)
    curve[i] = Math.sin(Math.PI * i / curveLength);

param.setValueAtTime(0.2, t0);
param.setValueAtTime(0.3, t1);
param.setValueAtTime(0.4, t2);
param.linearRampToValueAtTime(1, t3);
param.linearRampToValueAtTime(0.15, t4);
param.exponentialRampToValueAtTime(0.75, t5);
param.exponentialRampToValueAtTime(0.05, t6);
param.setValueCurveAtTime(curve, t6, t7 - t6);
</code></pre>
</section>
</section>

<section>
<h2 id="GainNode">The GainNode Interface</h2>
<p>
  Changing the gain of an audio signal is a fundamental operation in audio
  applications.  The <code>GainNode</code> is one of the building blocks for
  creating <a href="#mixer-gain-structure">mixers</a>.  This interface is an
  <a>AudioNode</a> with a single input and single output:
</p>
<pre>
  numberOfInputs  : 1
  numberOfOutputs : 1

  channelCountMode = "max";
  channelInterpretation = "speakers";
</pre>

<p>
  It multiplies the input audio signal by the (possibly time-varying)
  <code>gain</code> attribute, copying the result to the output.  By default, it
  will take the input and pass it through to the output unchanged, which
  represents a constant gain change of 1.
</p>

<p>
  As with other <code>AudioParams</code>, the <code>gain</code> parameter
  represents a mapping from time (in the coordinate system of
  the <a>AudioContext</a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute) to floating-point value.

  Every PCM audio sample in the input is multiplied by the <code>gain</code>
  parameter's value for the specific time corresponding to that audio sample.
  This multiplied value represents the PCM audio sample for the output.
</p>

<p>
  The number of channels of the output will always equal the number of channels
  of the input, with each channel of the input being multiplied by the
  <code>gain</code> values and being copied into the corresponding channel of
  the output.
</p>

<p>
  The implementation must make gain changes to the audio stream smoothly,
  without introducing noticeable clicks or glitches. This process is called
  "de-zippering".
</p>

<dl title="interface GainNode : AudioNode" class="idl">
  <dt>readonly attribute AudioParam gain</dt>
  <dd>
    Represents the amount of gain to apply. Its default <code>value</code> is 1
    (no gain change). The nominal <code>minValue</code> is 0, but may be set
    negative for phase inversion.  The nominal <code>maxValue</code> is 1, but
    higher values are allowed (no
    exception thrown).This parameter is <em>a-rate</em>
  </dd>
</dl>
</section>

<section>
<h2 id="DelayNode">The DelayNode Interface</h2>

<p>A delay-line is a fundamental building block in audio applications. This
interface is an <a>AudioNode</a> with a single input and single output: </p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>

<p>
  The number of channels of the output always equals the number of channels of the
  input.
</p>

<p>
  It delays the incoming audio signal by a certain amount. Specifically, at each
  time <em>t</em>, input signal <em>input(t)</em>, delay time
  <em>delayTime(t)</em> and output signal <em>output(t)</em>, the output will be
  <em> output(t) = input(t - delayTime(t))</em>. The default
  <code>delayTime</code> is 0 seconds (no delay). When the delay time is
  changed, the implementation must make the transition smoothly, without
  introducing noticeable clicks or glitches to the audio stream.
</p>

<dl title="interface DelayNode : AudioNode" class="idl">
  <dt> readonly attribute AudioParam delayTime </dt>
  <dd>
    An <a>AudioParam</a> object representing the amount of delay (in seconds)
    to apply. Its default <code>value</code> is 0 (no delay). The minimum value is
    0 and the maximum value is determined by the <code>maxDelayTime</code>
    argument to the <code>AudioContext</code> method <code>createDelay</code>.
    This parameter is <em>a-rate</em>.
  </dd>
</dl>

</section>

<section>
<h2 id="AudioBuffer">The AudioBuffer Interface</h2>

<p>
  This interface represents a memory-resident audio asset (for one-shot sounds
  and other short audio clips). Its format is non-interleaved IEEE 32-bit linear
  PCM with a nominal range of -1 -&gt; +1. It can contain one or more channels.
  Typically, it would be expected that the length of the PCM data would be
  fairly short (usually somewhat less than a minute).  For longer sounds, such
  as music soundtracks, streaming should be used with the <code>audio</code>
  element and <code>MediaElementAudioSourceNode</code>.
</p>

<p>
An AudioBuffer may be used by one or more <a>AudioContext</a>s.
</p>

<dl title="interface AudioBuffer" class="idl">
    <dt> readonly attribute float sampleRate </dt>
    <dd> The sample-rate for the PCM audio data in samples per second. </dd>
    <dt> readonly attribute long length </dt>
    <dd> Length of the PCM audio data in sample-frames. </dd>
    <dt> readonly attribute double duration </dt>
    <dd> Duration of the PCM audio data in seconds. </dd>
    <dt> readonly attribute long numberOfChannels </dt>
    <dd> The number of discrete audio channels. </dd>
    <dt> Float32Array getChannelData() </dt>
    <dd>
      Returns the <code>Float32Array</code> representing the PCM audio data for
      the specific channel.

      <dl class="parameters">
        <dt>unsigned long channel</dt>
        <dd>
          This parameter is an index representing the particular channel to get data
          for.  An index value of 0 represents the first channel.  This  index value
          MUST be less than <code>numberOfChannels</code> or an INDEX_SIZE_ERR
          exception MUST be thrown.
        </dd>
      </dl>
    </dd>
</dl>

</section>

<section>
<h2 id="AudioBufferSourceNode">The AudioBufferSourceNode Interface</h2>

<p>
  This interface represents an audio source from an in-memory audio asset in an
  <code>AudioBuffer</code>. It is useful for playing short audio assets which
  require a high degree of scheduling flexibility (can playback in rhythmically
  perfect ways). The start() method is used to schedule when sound playback will
  happen.  The playback will stop automatically when the buffer's audio data has
  been completely played (if the <code>loop</code> attribute is false), or when
  the stop() method has been called and the specified time has been reached.
  Please see more details in the start() and stop() description.  start() and
  stop() may not be issued multiple times for a given AudioBufferSourceNode.
</p>
<pre>
  numberOfInputs  : 0
  numberOfOutputs : 1
</pre>

<p>
  The number of channels of the output always equals the number of channels of
  the AudioBuffer assigned to the .buffer attribute, or is one channel of
  silence if .buffer is NULL.
</p>

<dl title="interface AudioBufferSourceNode : AudioNode" class="idl">
  <dt>attribute AudioBuffer? buffer</dt>
  <dd> Represents the audio asset to be played. </dd>

  <dt>readonly attribute AudioParam playbackRate</dt>
  <dd>
    The speed at which to render the audio stream. Its default
    <code>value</code> is 1.  This parameter is <em>a-rate</em>.
  </dd>

  <dt>attribute boolean loop</dt>
  <dd>
    Indicates if the audio data should play in a loop.  The default value is
    false.
  </dd>
  <dt>attribute double loopStart</dt>
  <dd>
    An optional value in seconds where looping should begin if the
    <code>loop</code> attribute is true.  Its default <code>value</code> is 0,
    and it may usefully be set to any value between 0 and the duration of the
    buffer.
  </dd>
  <dt>attribute double loopEnd</dt>
  <dd>
    An optional value in seconds where looping should end if the
    <code>loop</code> attribute is true.  Its default <code>value</code> is 0,
    and it may usefully be set to any value between 0 and the duration of the
    buffer.
  </dd>

  <dt>
    void start()
  </dt>
  <dd>
    Schedules a sound to playback at an exact time.
    <dl class="parameters">
      <dt>optional double when = 0</dt>
      <dd>
        The <a>when</a> parameter describes at what time (in seconds) the sound
        should start playing. It is in the same time coordinate system as
        the <a>AudioContext</a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute. If 0 is passed in for this value or if the
        value is less than <b>currentTime</b>, then the sound will start playing
        immediately.  <code>start</code> may only be called one time and must be
        called before <code>stop</code> is called or an INVALID_STATE_ERR
        exception MUST be thrown.
      </dd>
      <dt>optional double offset = 0</dt>
      <dd>
        The <dfn id="dfn-offset">offset</dfn> parameter describes the offset
        time in the buffer (in seconds) where playback will begin. If 0 is
        passed in for this value, then playback will start from the beginning of
        the buffer.
      </dd>
      <dt>optional double duration</dt>
      <dd>
        The <a>duration</a> parameter describes the
        duration of the portion (in seconds) to be played.  If this parameter is
        not passed, the duration will be equal to the total duration of the
        AudioBuffer minus the <code>offset</code> parameter.  Thus if neither
        <code>offset</code> nor <code>duration</code> are specified then the
        implied duration is the total duration of the AudioBuffer.
      </dd>
    </dl>
  </dd>

  <dt> void stop() </dt>
  <dd>
    Schedules a sound to stop playback at an exact time.
    <dl class="parameters">
      <dt>optional double when = 0</dt>
      <dd>
        The <a>when</a> parameter describes at what time (in seconds) the sound
        should stop playing.  It is in the same time coordinate system as
        the <a>AudioContext</a>'s
        <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.  If 0
        is passed in for this value or if the value
        is less than <a>currentTime</a>, then the sound will stop playing
        immediately.  <code>stop</code> must only be called one time and only after
        a call to <code>start</code> or <code>stop</code>, or an INVALID_STATE_ERR
        exception MUST be thrown.
      </dd>
    </dl>
  </dd>

  <dt> attribute EventHandler onended </dt>
  <dd>
  A property used to set the <code>EventHandler</code> (described in <cite>
    <a href="http://www.whatwg.org/specs/web-apps/current-work/#eventhandler">
    HTML</a></cite>[[!HTML]]) for the ended event that is dispatched to
    <a>AudioBufferSourceNode</a>
    node types.  When the playback of the buffer for an
    <a>AudioBufferSourceNode</a> is finished, an event of type <code>Event
      </code> (described in <cite> <a
  href="http://www.whatwg.org/specs/web-apps/current-work/#event">HTML</a>
  </cite>[[!HTML]]) will be dispatched to the event handler.
  </dd>
</dl>

<section>
<h3 id="looping-AudioBufferSourceNode">Looping</h3>
<p>
If the <code>loop</code> attribute is true when <code>start()</code> is called, then playback will continue indefinitely
until <code>stop()</code> is called and the stop time is reached.  We'll call this "loop" mode.  Playback always starts at the point in the buffer indicated
by the <code>offset</code> argument of <code>start()</code>, and in <em>loop</em> mode will continue playing until it reaches the <em>actualLoopEnd</em> position
in the buffer (or the end of the buffer), at which point it will wrap back around to the <em>actualLoopStart</em> position in the buffer, and continue
playing according to this pattern.
</p>

<p>
In <em>loop</em> mode then the <em>actual</em> loop points are calculated as follows from the <code>loopStart</code> and <code>loopEnd</code> attributes:
</p>

<blockquote>
<pre class="highlight">
if ((loopStart || loopEnd) &amp;&amp; loopStart &gt;= 0 &amp;&amp; loopEnd &gt; 0 &amp;&amp; loopStart &lt; loopEnd) {
    actualLoopStart = loopStart;
    actualLoopEnd = min(loopEnd, buffer.length);
} else {
    actualLoopStart = 0;
    actualLoopEnd = buffer.length;
}
</pre>
</blockquote>

<p>
Note that the default values for <code>loopStart</code> and <code>loopEnd</code> are both 0, which indicates that looping should occur from the very start
Note that the default <code>value</code>s for <code>loopStart</code> and <code>loopEnd</code> are both 0, which indicates that looping should occur from the very start
to the very end of the buffer.
</p>

<p>
Please note that as a low-level implementation detail, the AudioBuffer is at a specific sample-rate (usually the same as the <a>AudioContext</a> sample-rate), and
that the loop times (in seconds) must be converted to the appropriate sample-frame positions in the buffer according to this sample-rate.
</p>

</section>
</section>

<section>
<h2 id="MediaElementAudioSourceNode">The MediaElementAudioSourceNode Interface</h2>

<p>This interface represents an audio source from an <code>audio</code> or
<code>video</code> element. </p>
<pre>
  numberOfInputs  : 0
  numberOfOutputs : 1
</pre>

<p>
The number of channels of the output corresponds to the number of channels of the media referenced by the HTMLMediaElement.
Thus, changes to the media element's .src attribute can change the number of channels output by this node.
If the .src attribute is not set, then the number of channels output will be one silent channel.
</p>

<dl title="interface MediaElementAudioSourceNode : AudioNode" class=idl>
</dl>


<p>A MediaElementAudioSourceNode is created given an HTMLMediaElement using the
AudioContext <code>createMediaElementSource()</code> method. </p>

<p>
The number of channels of the single output equals the number of channels of the audio referenced by
the HTMLMediaElement passed in as the argument to
<code>createMediaElementSource()</code>, or is 1 if the HTMLMediaElement
has no audio.
</p>

<p>
The <A>HTMLMediaElement</A> must behave in an identical fashion after the
MediaElementAudioSourceNode has been created, <em>except</em> that the rendered
audio will no longer be heard directly, but instead will be heard as a
consequence of the <a>MediaElementAudioSourceNode</a> being connected through the
routing graph.  Thus pausing, seeking, volume, <code>.src</code> attribute
changes, and other aspects of the HTMLMediaElement must behave as they normally
would if <em>not</em> used with a MediaElementAudioSourceNode.
</p>

<pre class="highlight example">
var mediaElement = document.getElementById('mediaElementID');
var sourceNode = context.createMediaElementSource(mediaElement);
sourceNode.connect(filterNode);
</pre>
</section>


<section>
<h2>The ScriptProcessorNode Interface</h2>

<p>This interface is an <a>AudioNode</a> which can generate, process, or analyse audio
directly using JavaScript. </p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = numberOfInputChannels;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>

<p>
The <a>ScriptProcessorNode</a> is constructed with a <dfn>bufferSize</dfn> which must
be one of the following values: 256, 512, 1024, 2048, 4096, 8192, 16384.  This
value controls how frequently the <dfn>audioprocess</dfn> event is dispatched
and how many sample-frames need to be processed each call.
<a>audioprocess</a> events are only dispatched if the
<a>ScriptProcessorNode</a> has at least one input or one output connected.
Lower numbers for
<a href="#widl-ScriptProcessorNode-bufferSize">bufferSize</a> will result in a
lower (better) <a href="#latency">latency</a>. Higher numbers will be necessary to avoid
audio breakup and <a href="#audio-glitching">glitches</a>.  This value will be
picked by the implementation if the bufferSize argument to
<code>createScriptProcessor</code> is not passed in, or is set to 0.
</p>

<p>
<dfn>numberOfInputChannels</dfn> and <dfn>numberOfOutputChannels</dfn>
determine the number of input and output channels. It is invalid for both
<code>numberOfInputChannels</code> and <code>numberOfOutputChannels</code> to
be zero.
</p>
<pre class=highlight>
    var node = context.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);
</pre>

<dl title="interface ScriptProcessorNode : AudioNode" class="idl">
  <dt>attribute EventHandler onaudioprocess</dt>
  <dd>
    A property used to set the <code>EventHandler</code> (described in <cite>
    <a href="http://www.whatwg.org/specs/web-apps/current-work/#eventhandler">
    HTML</a></cite>[[!HTML]]) for the audioprocess event that is dispatched to
    <a>ScriptProcessorNode</a>
    node types. An event of type <a>AudioProcessingEvent</a> will be dispatched
    to the event handler.
  </dd>
  <dt> readonly attribute long bufferSize </dt>
  <dd>
    The size of the buffer (in sample-frames) which needs to be processed each
    time <code>onaudioprocess</code> is called. Legal values are (256, 512,
    1024, 2048, 4096, 8192, 16384).
  </dd>
</dl>
</section>

<section>
<h2>The AudioProcessingEvent Interface</h2>

<p>
This is an <code>Event</code> object which is dispatched to
<a>ScriptProcessorNode</></a> nodes.
</p>

<p>
  The event handler processes audio from the input (if any) by accessing the
  audio data from the <code>inputBuffer</code> attribute. The audio data which
  is the result of the processing (or the synthesized data if there are no
  inputs) is then placed into the <code>outputBuffer</code>.
</p>

<dl title="interface AudioProcessingEvent : Event" class="idl">
    <dt> readonly attribute double playbackTime </dt>
    <dd>
      The time when the audio will be played in the same time coordinate system
      as the <a>AudioContext</a>'s <a href="#widl-AudioContext-currentTime">currentTime</a>.
      <code>playbackTime</code> allows for very
      tight synchronization between processing directly in JavaScript with the
      other events in the context's rendering graph.
    </dd>
    <dt> readonly attribute AudioBuffer inputBuffer </dt>
    <dd>
      An AudioBuffer containing the input audio data.  It will have a number of
      channels equal to the <code>numberOfInputChannels</code> parameter of the
      createScriptProcessor() method.  This AudioBuffer is only valid while in
      the scope of the <code>onaudioprocess</code> function.  Its values will be
      meaningless outside of this scope.
      </dd>
    <dt> readonly attribute AudioBuffer outputBuffer </dt>
    <dd>
      An AudioBuffer where the output audio data should be written.  It will
      have a number of channels equal to the <code>numberOfOutputChannels</code>
      parameter of the createScriptProcessor() method.  Script code within the
      scope of the <code>onaudioprocess</code> function is expected to modify
      the <code>Float32Array</code> arrays representing channel data in this
      AudioBuffer.  Any script modifications to this AudioBuffer outside of this
      scope will not produce any audible effects.
    </dd>
</dl>
</section>

<section>
<h2>The PannerNode Interface</h2>

<p>
This interface represents a processing node which
<a href="#Spatialization">positions / spatializes</a> an incoming audio
stream in three-dimensional space. The spatialization is in relation to the <a
>AudioContext</a>'s <a>AudioListener</a> (<code>listener</code> attribute). </p>

<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = 2;
    channelCountMode = "clamped-max";
    channelInterpretation = "speakers";
</pre>

<p>
The audio stream from the input will be either mono or stereo, depending on the
connection(s) to the input.
</p>

<p>
The output of this node is hard-coded to stereo (2 channels) and
<em>currently</em> cannot be configured.
</p>


<p>
  The <a>PanningModelType</a> enum determines which spatialization algorithm will
  be used to position the audio in 3D space. The default is "HRTF".
</p>
<dl title="enum PanningModelType" class=idl>
  <dt>equalpower</dt>
  <dd>
    A simple and efficient spatialization algorithm using equal-power panning.
  </dd>
  <dt>HRTF</dt>
  <dd>
    A higher quality spatialization algorithm using a convolution with measured
    impulse responses from human subjects. This panning method renders stereo
    output.
  </dd>
</dl>

<p>
The <a>DistanceModelType</a> enum determines which algorithm will be used to
reduce the volume of an audio source as it moves away from the listener.  The
default is "inverse".
</p>
<dl title="enum DistanceModelType" class=idl>
  <dt>linear</dt>
  <dd>
  A linear distance model which calculates <em>distanceGain</em> according to:
  <pre>
    1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance)
  </pre>
  </dd>
  <dt>inverse</dt>
  <dd>
  <p>An inverse distance model which calculates <em>distanceGain</em> according to: </p>
  <pre>
    refDistance / (refDistance + rolloffFactor * (distance - refDistance))
  </pre>
  </dd>
  <dt>exponential</dt>
  <dd><p>An exponential distance model which calculates <em>distanceGain</em> according to: </p>
  <pre>
    pow(distance / refDistance, -rolloffFactor)
  </pre>
  </dd>
</dl>

<dl title="interface PannerNode : AudioNode" class=idl>

    <!--<dt>// Default for stereo is HRTF</dt>-->
    <dt>attribute PanningModelType panningModel</dt>
    <dd> Specifies the panning model used by this <a>PannerNode</a>. Defaults to
    <a>"HRTF"</a>.</dd>

    <!--<dt> // Uses a 3D cartesian coordinate system </dt>-->
    <dt>void setPosition(double x, double y, double z)</dt>
    <dd>
    <p>
      Sets the position of the audio source relative to the
      <a>listener</a> attribute. A 3D cartesian coordinate system is used.
    </p>
    <p>
      The <dfn id="dfn-x">x, y, z</dfn> parameters represent the coordinates
      in 3D space.
    </p>
    <p>
      The default value is (0,0,0)
    </p>
    </dd>
    <dt>void setOrientation(double x, double y, double z)</dt>
    <dd>
    <p>
      Describes which direction the audio source is pointing in the 3D
      cartesian coordinate space. Depending on how directional the sound is
      (controlled by the <b>cone</b> attributes), a sound pointing away from
      the listener can be very quiet or completely silent.
    </p>
    <p>
      The <dfn id="dfn-x_2">x, y, z</dfn> parameters represent a direction
      vector in 3D space.
    </p>
    <p>
      The default value is (1,0,0)
    </p>
    </dd>
    <dt>void setVelocity(double x, double y, double z)</dt>
    <dd>
    <p>
      Sets the velocity vector of the audio source. This vector controls both
      the direction of travel and the speed in 3D space. This velocity relative
      to the listener's velocity is used to determine how much doppler shift
      (pitch change) to apply.  The units used for this vector is <em>meters /
      second</em> and is independent of the units used for position and
      orientation vectors.
    </p>
    <p>
      The <dfn id="dfn-x_3">x, y, z</dfn> parameters describe a direction
      vector indicating direction of travel and intensity.
    </p>
    <p>
      The default value is (0,0,0)
    </p>
    </dd>

    <!--<dt> // Distance model and attributes </dt>-->
    <dt>attribute DistanceModelType distanceModel</dt>
    <dd> Specifies the distance model used by this PannerNode. Defaults to
    <a>"inverse"</a>.
    </dd>
    <dt>attribute double refDistance</dt>
    <dd>
      A reference distance for reducing volume as source move further
      from the listener.  The default value is 1.
    </dd>
    <dt>attribute double maxDistance</dt>
    <dd>
      The maximum distance between source and listener, after which the
      volume will not be reduced any further.  The default value is 10000.
    </dd>
    <dt>attribute double rolloffFactor</dt>
    <dd>
      Describes how quickly the volume is reduced as source moves away from
      listener.  The default value is 1.
    </dd>

    <!--<dt> // Directional sound cone </dt>-->
    <dt>attribute double coneInnerAngle</dt>
    <dd>
      A parameter for directional audio sources, this is an angle, inside
      of which there will be no volume reduction.  The default value is 360.
    </dd>
    <dt>attribute double coneOuterAngle</dt>
    <dd>
      A parameter for directional audio sources, this is an angle, outside
      of which the volume will be reduced to a constant value of
      <a>coneOuterGain</a>.  The default value is 360.
    </dd>
    <dt>attribute double coneOuterGain</dt>
    <dd>
      A parameter for directional audio sources, this is the amount of volume
      reduction outside of the <a>coneOuterAngle</a>.  The default value is 0.
    </dd>
</dl>

<section>
  <h3 id="Methods_and_Parameters">Methods and Parameters</h3>
  <dl>
    <dt id="dfn-setPosition">The <code>setPosition</code> method</dt>
  </dl>
  <dl>
    <dt id="dfn-setOrientation">The <code>setOrientation</code> method</dt>
  </dl>
  <dl>
    <dt id="dfn-setVelocity">The <code>setVelocity</code> method</dt>
  </dl>
</section>
</section>

<section>
<h2 id="AudioListener">The AudioListener Interface</h2>

<p>
This interface represents the position and orientation of the person
listening to the audio scene. All <a>PannerNode</a> objects
spatialize in relation to the <a>AudioContext</a>'s <a>listener</a>. See <a
href="#Spatialization">this</a> section for more details about
spatialization.
</p>

<dl title="interface AudioListener" class="idl">
    <dt> attribute double dopplerFactor </dt>
    <dd>
      A constant used to determine the amount of pitch shift to use when
      rendering a doppler effect.  The default value is 1.
    </dd>
    <dt> attribute double speedOfSound </dt>
    <dd>
      The speed of sound used for calculating doppler shift. The default value
      is 343.3.
    </dd>

    <!--<dt> // Uses a 3D cartesian coordinate system </dt>-->
    <dt> void setPosition(double x, double y, double z) </dt>
    <dd>
      <p>
        Sets the position of the listener in a 3D cartesian coordinate
        space. <a>PannerNode</a> objects use this position relative to
        individual audio sources for spatialization.
      </p>
      <p>
        The <code>x, y, z</code> parameters represent
        the coordinates in 3D space.
      </p>
      <p>
        The default value is (0,0,0)
      </p>
    </dd>
    <dt> void setOrientation(double x, double y, double z, double xUp, double yUp, double zUp) </dt>
    <dd>
      <p>
        Describes which direction the listener is pointing in the 3D cartesian
        coordinate space. Both a <b>front</b> vector and an <b>up</b> vector are
        provided.  In simple human terms, the <b>front</b> vector represents
        which direction the person's nose is pointing.  The <b>up</b> vector
        represents the direction the top of a person's head is pointing.  These
        values are expected to be linearly independent (at right angles to each
        other).  For normative requirements of how these values are to be
        interpreted, see the <a href="#Spatialization">spatialization
        section</a>.
      </p>
      <p>
        The <code>x, y, z</code> parameters represent a <b>front</b> direction
        vector in 3D space, with the default value being (0,0,-1).
      </p>
      <p>
        The <code>xUp, yUp, zUp</code> parameters represent an <b>up</b> direction
        vector in 3D space, with the default value being (0,1,0).
      </p>
    </dd>
    <dd> void setVelocity(double x, double y, double z) </dd>
    <dd>
      <p>
        Sets the velocity vector of the listener. This vector controls both the
        direction of travel and the speed in 3D space. This velocity relative to
        an audio source's velocity is used to determine how much doppler shift
        (pitch change) to apply.  The units used for this vector is <em>meters /
        second</em> and is independent of the units used for position and
      orientation vectors.
      </p>
      <p>
        The <code>x, y, z</code> parameters describe a direction vector
        indicating direction of travel and intensity.
      </p>
      <p>The default value is (0,0,0) </p>
    </dd>
</dl>

</section>

<section>
<h2 id="ConvolverNode">The ConvolverNode Interface</h2>

<p>
  This interface represents a processing node which applies a <a
    href="#Convolution">linear convolution effect</a> given an impulse
  response.  Normative requirements for multi-channel convolution matrixing are
  described <a href="#Convolution-reverb-effect">here</a>.
</p>

<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = 2;
    channelCountMode = "clamped-max";
    channelInterpretation = "speakers";
</pre>

<dl title="interface ConvolverNode : AudioNode" class="idl">
  <dt> attribute AudioBuffer? buffer </dt>
    <dd>
      A mono, stereo, or 4-channel <a>AudioBuffer</a> containing the (possibly
      multi-channel) impulse response used by the <a>ConvolverNode</a>.  This
      <a>AudioBuffer</a> must be of the same sample-rate as the <a>AudioContext</a> or
      an NOT_SUPPORTED_ERR exception MUST be thrown.  At the time when this
      attribute is set, the <em>buffer</em> and the state of the
      <em>normalize</em> attribute will be used to configure the
      <a>ConvolverNode</a> with this impulse response having the given
      normalization.  The initial value of this attribute is null.
    </dd>
  <dt> attribute boolean normalize </dt>
    <dd>
      <p>
        Controls whether the impulse response from the buffer will be scaled by an
        equal-power normalization when the <code>buffer</code> atttribute is set.
        Its default value is <code>true</code> in order to achieve a more uniform
        output level from the convolver when loaded with diverse impulse
        responses.  If <code>normalize</code> is set to <code>false</code>, then
        the convolution will be rendered with no pre-processing/scaling of the
        impulse response.  Changes to this value do not take effect until the next
        time the <em>buffer</em> attribute is set.
      </p>
      <p>
        If the <em>normalize</em> attribute is false when the <em>buffer</em>
        attribute is set then the <a>ConvolverNode</a> will perform a linear convolution
        given the exact impulse response contained within the <em>buffer</em>.
      </p>
      <p>
        Otherwise, if the <em>normalize</em> attribute is true when the
        <em>buffer</em> attribute is set then the <a>ConvolverNode</a> will
        first perform a scaled RMS-power analysis of the audio data contained
        within <em>buffer</em> to calculate a <em>normalizationScale</em> given
        this algorithm:
      </p>

      <pre class="highlight">

float calculateNormalizationScale(buffer)
{
    const float GainCalibration = 0.00125;
    const float GainCalibrationSampleRate = 44100;
    const float MinPower = 0.000125;
  
    // Normalize by RMS power.
    size_t numberOfChannels = buffer->numberOfChannels();
    size_t length = buffer->length();

    float power = 0;

    for (size_t i = 0; i &lt; numberOfChannels; ++i) {
        float* sourceP = buffer->channel(i)->data();
        float channelPower = 0;

        int n = length;
        while (n--) {
            float sample = *sourceP++;
            channelPower += sample * sample;
        }

        power += channelPower;
    }

    power = sqrt(power / (numberOfChannels * length));

    // Protect against accidental overload.
    if (isinf(power) || isnan(power) || power &lt; MinPower)
        power = MinPower;

    float scale = 1 / power;

    // Calibrate to make perceived volume same as unprocessed.
    scale *= GainCalibration;

    // Scale depends on sample-rate.
    if (buffer->sampleRate())
        scale *= GainCalibrationSampleRate / buffer->sampleRate();

    // True-stereo compensation.
    if (buffer->numberOfChannels() == 4)
        scale *= 0.5;

    return scale;
}
      </pre>

      <p>
        During processing, the ConvolverNode will then take this calculated
        <em>normalizationScale</em> value and multiply it by the result of the
        linear convolution resulting from processing the input with the impulse
        response (represented by the <em>buffer</em>) to produce the final output.
        Or any mathematically equivalent operation may be used, such as
        pre-multiplying the input by <em>normalizationScale</em>, or
        pre-multiplying a version of the impulse-response by
        <em>normalizationScale</em>.
      </p>
    </dd>
</dl>
</section>

<section>
<h2>The AnalyserNode Interface</h2>

<p>
  This interface represents a node which is able to provide real-time frequency
  and time-domain analysis information. The audio stream will be passed
  un-processed from input to output.
</p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1    <em>Note that this output may be left unconnected.</em>

    channelCount = 1;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>

<dl title="interface AnalyserNode : AudioNode" class="idl">
    <!--<dt> // Real-time frequency-domain data </dt>-->
    <dt> void getFloatFrequencyData() </dt>
    <dd>
      <p>
        Copies the current frequency data into the passed floating-point
        array. If the array has fewer elements than the frequencyBinCount, the
        excess elements will be dropped. If the array has more elements than
        the frequencyBinCount, the excess elements will be ignored.
      </p>
      <dl class="parameters">
        <dt>Float32Array array</dt>
        <dd>
          This parameter is where the frequency-domain analysis data will be
          copied.
        </dd>
      </dl>
    </dd>
    <dt> void getByteFrequencyData() </dt>
    <dd>
      <p>
        Copies the current frequency data into the passed unsigned byte
        array. If the array has fewer elements than the frequencyBinCount, the
        excess elements will be dropped. If the array has more elements than
        the frequencyBinCount, the excess elements will be ignored.
      </p>
      <dl class="parameters">
        <dt>Uint8Array array</dt>
        <dd>
          This parameter is where the frequency-domain analysis data will be
          copied.
        </dd>
      </dl>
    </dd>

    <!--<dt>// Real-time waveform data </dt>-->
    <dt> void getByteTimeDomainData() </dt>
    <dd>
      <p>
        Copies the current time-domain (waveform) data into the passed unsigned
        byte array. If the array has fewer elements than the value of
        <a>fftSize</a>, the excess elements will be dropped. If the array has
        more elements than <a>fftSize</a>, the excess elements will be ignored.
      </p>
      <dl class="parameters">
        <dt>Uint8Array array</dt>
        <dd>
          This parameter is where the time-domain analysis data will be copied.
        </dd>
      </dl>
    </dd>

    <dt> attribute unsigned long fftSize </dt>
    <dd>
      The size of the FFT used for frequency-domain analysis. This must be a
      non-zero power of two in the range 32 to 2048, otherwise an INDEX_SIZE_ERR
      exception MUST be thrown.

      The default value is 2048.
    </dd>
    <dt> readonly attribute unsigned long frequencyBinCount </dt>
    <dd>
      Half the FFT size.
    </dd>

    <dt> attribute double minDecibels </dt>
    <dd>
      The minimum power value in the scaling range for the FFT analysis data for
      conversion to unsigned byte values.  The default value is -100.  If the
      value of this attribute is set to a value more than or equal to
      <code>maxDecibels</code>, an INDEX_SIZE_ERR exception MUST be thrown.
    </dd>
    <dt> attribute double maxDecibels </dt>
  <dd>
    The maximum power value in the scaling range for the FFT analysis data for
    conversion to unsigned byte values.  The default value is -30.  If the value
    of this attribute is set to a value less than or equal to
    <code>minDecibels</code>, an INDEX_SIZE_ERR exception MUST be thrown.
  </dd>

    <dt> attribute double smoothingTimeConstan </dt>
    <dd>
      A value from 0 -&gt; 1 where 0 represents no time averaging
      with the last analysis frame.
      The default value is 0.8.
      If the value of this attribute is set to a value less than 0 or more than 1,
      an INDEX_SIZE_ERR exception MUST be thrown.
    </dd>
</dl>
</section>

<section>
<h2>The ChannelSplitterNode Interface</h2>

<p>
  The <code>ChannelSplitterNode</code> is for use in more advanced applications
  and would often be used in conjunction with <a>ChannelMergerNode</a>.
</p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : Variable N (defaults to 6) // number of "active" (non-silent) outputs is determined by number of channels in the input

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>

<p>
  This interface represents an <a>AudioNode</a> for accessing the individual channels
  of an audio stream in the routing graph. It has a single input, and a number
  of "active" outputs which equals the number of channels in the input audio
  stream.  For example, if a stereo input is connected to an
  <a>ChannelSplitterNode</a> then the number of active outputs will be two
  (one from the left channel and one from the right). There are always a total
  number of N outputs (determined by the <a>numberOfOutputs</a> parameter
  to the <a>AudioContext</a> method <a>createChannelSplitter()</a>), The default
  number is 6 if this value is not provided. Any outputs which are not "active"
  will output silence and would typically not be connected to anything.
</p>

<h3>Example:</h3>
<figure>
  <img alt="channel splitter" src="images/channel-splitter.png" />
  <figcaption>A diagram of a ChannelSplitter</figcaption>
</figure>

<p>
  Please note that in this example, the splitter does <b>not</b> interpret the
  channel identities (such as left, right, etc.), but simply splits out channels
  in the order that they are input.
</p>

<p>
  One application for <code>ChannelSplitterNode</code> is for doing "matrix
  mixing" where individual gain control of each channel is desired.
</p>

<dl title="interface ChannelSplitterNode : AudioNode" class="idl">
</dl>
</section>

<section>
<h2>The ChannelMergerNode Interface</h2>

<p>
  The <a>ChannelMergerNode</a> is for use in more advanced applications
  and would often be used in conjunction with <a>ChannelSplitterNode</a>.
</p>
<pre>
  numberOfInputs  : Variable N (default to 6)  // number of connected inputs may be less than this
  numberOfOutputs : 1

  channelCountMode = "max";
  channelInterpretation = "speakers";
</pre>

<p>
  This interface represents an <a>AudioNode</a> for combining channels from
  multiple audio streams into a single audio stream. It has a variable number of
  inputs (defaulting to 6), but not all of them need be connected. There is a
  single output whose audio stream has a number of channels equal to the sum of
  the numbers of channels of all the connected inputs. For example, if an
  <a>ChannelMergerNode</a> has two connected inputs (both stereo), then the
  output will be four channels, the first two from the first input and the
  second two from the second input. In another example with two connected inputs
  (both mono), the output will be two channels (stereo), with the left channel
  coming from the first input and the right channel coming from the second
  input.
</p>

<h3 id="example-2">Example:</h3>
<figure>
  <img alt="channel merger" src="images/channel-merger.png">
  <figcaption>A diagram of ChannelMerger</figcaption>
</figure>

<p>
  Please note that in this example, the merger does <b>not</b> interpret the
  channel identities (such as left, right, etc.), but simply combines channels
  in the order that they are input.
</p>


<p>
  Be aware that it is possible to connect an <a>ChannelMergerNode</a> in
  such a way that it outputs an audio stream with a large number of channels
  greater than the maximum supported by the audio hardware. In this case where
  such an output is connected to the <a>AudioContext</a> 
  <code><a href="#widl-AudioContext-destination">destination</a></code> (the
  audio hardware), then the extra channels will be ignored.  Thus, the
  <a>ChannelMergerNode</a> should be used in situations where the number of
  channels is well understood.
</p>

<dl title="interface ChannelMergerNode : AudioNode" class="idl">
</dl>
</section>

<section>
<h2>The DynamicsCompressorNode Interface</h2>

<p>
  <a>DynamicsCompressorNode</a> is an <a>AudioNode</a> processor implementing a
  dynamics compression effect.
</p>

<p>
  Dynamics compression is very commonly used in musical production and game
  audio. It lowers the volume of the loudest parts of the signal and raises the
  volume of the softest parts. Overall, a louder, richer, and fuller sound can
  be achieved. It is especially important in games and musical applications
  where large numbers of individual sounds are played simultaneous to control
  the overall signal level and help avoid clipping (distorting) the audio output
  to the speakers.
</p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = 2;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>

<dl title="interface DynamicsCompressorNode< : AudioNode" class="idl">
  <dt> readonly attribute AudioParam threshold </dt>
  <dd>
    The decibel value above which the compression will start taking effect.  Its
    default <code>value</code> is -24, with a nominal range of -100 to 0.
  </dd>
  <dt> readonly attribute AudioParam knee </dt>
  <dd>
    A decibel value representing the range above the threshold where the
    curve smoothly transitions to the "ratio" portion. Its default
    <code>value</code> is 30, with a nominal range of 0 to 40.
  </dd>
  <dt> readonly attribute AudioParam ratio </dt>
  <dd>
    The amount of dB change in input for a 1 dB change in output. Its default
    <code>value</code> is 12, with a nominal range of 1 to 20.
  </dd>
  <dt> readonly attribute AudioParam reduction </dt>
  <dd>
    A read-only decibel value for metering purposes, representing the current
    amount of gain reduction that the compressor is applying to the signal. If
    fed no signal the value will be 0 (no gain reduction).  The nominal range is
    -20 to 0.
  </dd>
  <dt> readonly attribute AudioParam attack </dt>
  <dd>
    The amount of time (in seconds) to reduce the gain by 10dB.   Its default
    <code>value</code> is 0.003, with a nominal range of 0 to 1.
  </dd>
  <dt> readonly attribute AudioParam release </dt>
  <dd>
    The amount of time (in seconds) to increase the gain by 10dB.  Its default
    <code>value</code> is 0.250, with a nominal range of 0 to 1.
  </dd>
</dl>
</section>

<section>
<h2>The BiquadFilterNode Interface</h2>

<p>
  <a>BiquadFilterNode</a> is an <a>AudioNode</a> processor implementing very
  common low-order filters.
</p>

<p>
  Low-order filters are the building blocks of basic tone controls (bass, mid,
  treble), graphic equalizers, and more advanced filters. Multiple
  <a>BiquadFilterNode</a> filters can be combined to form more complex filters. The
  filter parameters such as "frequency" can be changed over time for filter
  sweeps, etc. Each <a>BiquadFilterNode</a> can be configured as one of a number of
  common filter types as shown in the IDL below.  The default filter type
  is "lowpass".
</p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>

<p>
The number of channels of the output always equals the number of channels of the input.
</p>

<dl title="enum BiquadFilterType" class="idl">
  <dt>lowpass</dt>
  <dd>
    <p>A <a href="http://en.wikipedia.org/wiki/Low-pass_filter">lowpass filter</a>
    allows frequencies below the cutoff frequency to pass through and attenuates
    frequencies above the cutoff. It implements a standard second-order
    resonant lowpass filter with 12dB/octave rolloff.</p>

    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The cutoff frequency</dd>
        <dt>Q</dt>
          <dd>Controls how peaked the response will be at the cutoff frequency. A
            large value makes the response more peaked.  Please note that for this filter type, this
            value is not a traditional Q, but is a resonance value in decibels.</dd>
        <dt>gain</dt>
          <dd>Not used in this filter type</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>highpass</dt>
  <dd>
    <p>A <a href="http://en.wikipedia.org/wiki/High-pass_filter">highpass
    filter</a> is the opposite of a lowpass filter. Frequencies above the cutoff
    frequency are passed through, but frequencies below the cutoff are attenuated.
    It implements a standard second-order resonant highpass filter with
    12dB/octave rolloff.</p>

    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The cutoff frequency below which the frequencies are attenuated</dd>
        <dt>Q</dt>
          <dd>Controls how peaked the response will be at the cutoff frequency. A
            large value makes the response more peaked. Please note that for this filter type, this
            value is not a traditional Q, but is a resonance value in decibels.</dd>
        <dt>gain</dt>
          <dd>Not used in this filter type</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>bandpass</dt>
  <dd>
    <p>A <a href="http://en.wikipedia.org/wiki/Band-pass_filter">bandpass
    filter</a> allows a range of frequencies to pass through and attenuates the
    frequencies below and above this frequency range. It implements a
    second-order bandpass filter.</p>
    
    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The center of the frequency band</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Controls the width of the band. The width becomes narrower as the Q
            value increases.</dd>
        <dt>gain</dt>
          <dd>Not used in this filter type</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>lowshelf</dt>
  <dd>
    <p>The lowshelf filter allows all frequencies through, but adds a boost (or
    attenuation) to the lower frequencies. It implements a second-order
    lowshelf filter.</p>
    
    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The upper limit of the frequences where the boost (or attenuation) is
            applied.</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Not used in this filter type.</dd>
        <dt>gain</dt>
          <dd>The boost, in dB, to be applied. If the value is negative, the
            frequencies are attenuated.</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>highshelf</dt>
  <dd>
    <p>The highshelf filter is the opposite of the lowshelf filter and allows all
    frequencies through, but adds a boost to the higher frequencies. It
    implements a second-order highshelf filter</p>
    
    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The lower limit of the frequences where the boost (or attenuation) is
            applied.</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Not used in this filter type.</dd>
        <dt>gain</dt>
          <dd>The boost, in dB, to be applied. If the value is negative, the
            frequencies are attenuated.</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>peaking</dt>
  <dd>
    <p>The peaking filter allows all frequencies through, but adds a boost (or
    attenuation) to a range of frequencies. </p>
    
    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The center frequency of where the boost is applied.</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Controls the width of the band of frequencies that are boosted. A
            large value implies a narrow width.</dd>
        <dt>gain</dt>
          <dd>The boost, in dB, to be applied. If the value is negative, the
            frequencies are attenuated.</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>notch</dt>
  <dd>
    <p>The notch filter (also known as a <a
    href="http://en.wikipedia.org/wiki/Band-stop_filter">band-stop or
    band-rejection filter</a>) is the opposite of a bandpass filter. It allows all
    frequencies through, except for a set of frequencies.</p>
    
    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The center frequency of where the notch is applied.</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Controls the width of the band of frequencies that are attenuated. A
            large value implies a narrow width.</dd>
        <dt>gain</dt>
          <dd>Not used in this filter type.</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>allpass</dt>
  <dd>
    <p>An <a
    href="http://en.wikipedia.org/wiki/All-pass_filter#Digital_Implementation">allpass
    filter</a> allows all frequencies through, but changes the phase relationship
    between the various frequencies. It implements a second-order allpass
    filter</p>
    
    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The frequency where the center of the phase transition occurs. Viewed
            another way, this is the frequency with maximal <a
            href="http://en.wikipedia.org/wiki/Group_delay">group delay</a>.</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Controls how sharp the phase transition is at the center frequency. A
            larger value implies a sharper transition and a larger group delay.</dd>
        <dt>gain</dt>
          <dd>Not used in this filter type.</dd>
      </dl>
    </blockquote>
  </dd>
</dl>

<p>
All attributes of the <a>BiquadFilterNode</a> are <em>k-rate</em>
<a>AudioParam</a>.
</p>

<dl title="interface BiquadFilterNode : AudioNode" class="idl">
  <dt>attribute BiquadFilterType type</dt>
  <dd>
    The type of this <a>BiquadFilterNode</a>. The exact meaning of the other
    parameters depend on the value of the <code>type</code> attribute.
  </dd>
  <dt>readonly attribute AudioParam frequency</dt>
  <dd>
    The frequency at which the <a>BiquadFilterNode</a> will operate, in Hz.
    Its default value is 350Hz, and its nominal range is from 10Hz to half the
    Nyquist frequency.
  </dd>
  <dt>readonly attribute AudioParam detune</dt>
  <dd> A detune value, in cents, for the frequency</dd>
  <dt>readonly attribute AudioParam Q</dt>
  <dd>
    The <a href="http://en.wikipedia.org/wiki/Q_factor">Q</a> factor has a
    default value of 1, with a nominal range of 0.0001 to 1000.
  </dd>
  <dt>readonly attribute AudioParam gain</dt>
  <dd>The gain has a default value of 0, with a nominal range of -40 to 40.</dd>

  <dt>void getFrequencyResponse() </dt>
  <dd>
  <p>
    Given the current filter parameter settings, calculates the
    frequency response for the specified frequencies.
  </p>
  <dl class="parameters">
    <dt>Float32Array frequencyHz</dt>
    <dd>
      This parameter specifies an array of frequencies at which the response
      values will be calculated.
    </dd>
    <dt>Float32Array magResponse</dt>
    <dd>
      This parameter specifies an output array receiving the linear magnitude
      response values.
    </dd>
    <dt>Float32Array phaseResponse</dt>
   <dd>
    This parameter specifies an output array receiving the phase response values
    in radians.
   </dd>
  </dl>
  </dd>
</dl>

<p>
  The filter types are briefly described below. We note that all of these
  filters are very commonly used in audio processing. In terms of
  implementation, they have all been derived from standard analog filter
  prototypes. For more technical details, we refer the reader to the
  excellent <a href="http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt">
  reference</a> by Robert Bristow-Johnson.
</p>

</section>
<section>
<h2 id="WaveShaperNode">The WaveShaperNode Interface</h2>

<p>
<a>WaveShaperNode</a> is an <a>AudioNode</a> processor implementing non-linear
distortion effects.
</p>

<p>
Non-linear waveshaping distortion is commonly used for both subtle non-linear
warming, or more obvious distortion effects. Arbitrary non-linear shaping curves
may be specified.
</p>

<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>

<p>
  The number of channels of the output always equals the number of channels of
  the input.
</p>

<dl title="enum OverSampleType" class="idl">
  <dt> none </dt>
  <dd> Don't oversample</dd>
  <dt> 2x </dt>
  <dd> Oversample two times </dd>
  <dt> 4x </dt>
  <dd> Oversample four times </dd>
</dl>

<dl title="interface WaveShaperNode : AudioNode" class="idl" data-merge="OverSampleType">
  <dt> attribute Float32Array? curve </dt>
  <dd>
    The shaping curve used for the waveshaping effect. The input signal is
    nominally within the range -1 -&gt; +1. Each input sample within this range
    will index into the shaping curve with a signal level of zero corresponding
    to the center value of the curve array. Any sample value less than -1 will
    correspond to the first value in the curve array. Any sample value greater
    than +1 will correspond to the last value in the curve array.  The
    implementation must perform linear interpolation between adjacent points in
    the curve.  Initially the curve attribute is null, which means that the
    WaveShaperNode will pass its input to its output without modification.
  </dd>
  <dt> attribute OverSampleType oversample </dt>
    <dd>
    <p>
      Specifies what type of oversampling (if any) should be used when applying
      the shaping curve.    The default value is "none", meaning the curve will
      be applied directly to the input samples.  A value of "2x" or "4x" can
      improve the quality of the processing by avoiding some aliasing, with the
      "4x" value yielding the highest quality.  For some applications, it's
      better to use no oversampling in order to get a very precise shaping
      curve.
    </p>
    <p>
      A value of "2x" or "4x" means that the following steps must be performed:
    </p>
    <ol>
      <li>
        Up-sample the input samples to 2x or 4x the sample-rate of the
        <a>AudioContext</a>.  Thus for each processing block of 128 samples,
        generate 256 (for 2x) or 512 (for 4x) samples.
      </li>
      <li>Apply the shaping curve.</li>
      <li>
        Down-sample the result back to the sample-rate of the <a>AudioContext</a>.
        Thus taking the 256 (or 512) processed samples, generating 128 as the
        final result.
      </li>
    </ol>
    <p>
      The exact up-sampling and down-sampling filters are not specified, and can
      be tuned for sound quality (low aliasing, etc.), low latency, and
      performance.
    </p>
    </dd>
</dl>

</section>

<section>
<h2>The OscillatorNode Interface</h2>

<p>
  <a>OscillatorNode</a> represents an audio source generating a periodic waveform.
  It can be set to a few commonly used waveforms. Additionally, it can be set to
  an arbitrary periodic waveform through the use of a <a>PeriodicWave</a> object.
</p>

<p>
  Oscillators are common foundational building blocks in audio synthesis.  An
  OscillatorNode will start emitting sound at the time specified by the
  <code>start()</code> method.
</p>

<p>
  Mathematically speaking, a <em>continuous-time</em> periodic waveform can have
  very high (or infinitely high) frequency information when considered in the
  frequency domain.  When this waveform is sampled as a discrete-time digital
  audio signal at a particular sample-rate, then care must be taken to discard
  (filter out) the high-frequency information higher than the <em>Nyquist</em>
  frequency (half the sample-rate) before converting the waveform to a digital
  form.  If this is not done, then <em>aliasing</em> of higher frequencies (than
  the Nyquist frequency) will fold back as mirror images into frequencies lower
  than the Nyquist frequency.  In many cases this will cause audibly objectionable
  artifacts.  This is a basic and well understood principle of audio DSP.
</p>

<p>
  There are several practical approaches that an implementation may take to avoid
  this aliasing.  But regardless of approach, the <em>idealized</em> discrete-time
  digital audio signal is well defined mathematically.  The trade-off for the
  implementation is a matter of implementation cost (in terms of CPU usage) versus
  fidelity to achieving this ideal.
</p>

<p>
It is expected that an implementation will take some care in achieving this
ideal, but it is reasonable to consider lower-quality, less-costly approaches on
lower-end hardware.
</p>

<p>
Both .frequency and .detune are <em>a-rate</em> parameters and are used together
to determine a <em>computedFrequency</em> value:
</p>

<pre class=highlight>
  computedFrequency(t) = frequency(t) * pow(2, detune(t) / 1200)
</pre>

<p>
  The OscillatorNode's instantaneous phase at each time is the time integral of
  <em>computedFrequency</em>.
</p>

<pre>
  numberOfInputs  : 0
  numberOfOutputs : 1 (mono output)
</pre>

<dl title="enum OscillatorType" class="idl">
  <dt> sine </dt>
  <dd> A sine wave. </dd>
  <dt> square </dt>
  <dd> A square wave of duty period 0.5 </dd>
  <dt> sawtooth </dt>
  <dd> XXX </dd>
  <dt> triangle </dt>
  <dd> XXX </dd>
  <dt> custom </dt>
  <dd> XXX </dd>
</dl>

<dl title="interface OscillatorNode : AudioNode" class="idl">
    <dt> attribute OscillatorType type </dt>
    <dd>
      The shape of the periodic waveform.  It may directly be set to any of the
      type constant values except for "custom".  The <a
      href="#widl-OscillatorNode-setPeriodicWave-void-PeriodicWave-periodicWave"><code>setPeriodicWave()</code></a> method can be
      used to set a custom waveform, which results in this attribute being set to
      "custom".  The default value is "sine".
    </dd>

    <dt> readonly attribute AudioParam frequency </dt>
    <dd>
      The frequency (in Hertz) of the periodic waveform. Its default
      <code>value</code> is 440. This parameter is <em>a-rate</em>.
    </dd>
    <dt> readonly attribute AudioParam detune </dt>
    <dd>
      A detuning value (in Cents) which will offset the <code>frequency</code> by
      the given amount. Its default <code>value</code> is 0.  This parameter is
      <em>a-rate</em>.
    </dd>

    <dt> void start(double when)</dt>
    <dd>Defined as in <a>AudioBufferSourceNode</a>.</dd>
    <dt> void stop(double when) </dt>
    <dd>Defined as in <a>AudioBufferSourceNode</a>.</dd>
    <dt> void setPeriodicWave(PeriodicWave periodicWave) </dt>
    <dd>
      Sets an arbitrary custom periodic waveform given a <a>PeriodicWave</a>.
    </dd>

    <dt> attribute EventHandler onended </dt>
    <dd>
      A property used to set the <code>EventHandler</code> (described in <cite><a
      href="http://www.whatwg.org/specs/web-apps/current-work/#eventhandler">HTML</a></cite>[[HTML]])
      for the ended event that is dispatched to <a >OscillatorNode</a>
      node types.  When the playback of the buffer for an <code>OscillatorNode</code>
      is finished, an event of type <code>Event</code> (described in <cite><a
      href="http://www.whatwg.org/specs/web-apps/current-work/#event">HTML</a></cite>[[HTML]])
      will be dispatched to the event handler.
    </dd>
</dl>
</section>


<section>
<h2>The PeriodicWave Interface</h2>

<p>
PeriodicWave represents an arbitrary periodic waveform to be used with an
<a>OscillatorNode</a>.  Please see
<a
  href="#widl-AudioContext-createPeriodicWave-PeriodicWave-Float32Array-real-Float32Array-imag">createPeriodicWave()</a> and <a
href="#widl-OscillatorNode-setPeriodicWave-void-PeriodicWave-periodicWave">setPeriodicWave()</a> and for more details.
</p>

<dl title="interface PeriodicWave" class="idl">
</dl>

</section>

<section>
<h2 id="MediaStreamAudioSourceNode"> The MediaStreamAudioSourceNode Interface</h2>

<p>
This interface represents an audio source from a <code>MediaStream</code>.  The
first <code>AudioMediaStreamTrack</code> from the <code>MediaStream</code> will
be used as a source of audio. Those interfaces are described in
[[!mediacapture-streams]].
</p>
<pre>
    numberOfInputs  : 0
    numberOfOutputs : 1
</pre>

<p>
  The number of channels of the output corresponds to the number of channels of
  the <code>AudioMediaStreamTrack</code>.  If there is no valid audio track,
  then the number of channels output will be one silent channel.
</p>

<dl title="interface MediaStreamAudioSourceNode : AudioNode" class="idl">
</dl>
</section>

<section>
<h2> The MediaStreamAudioDestinationNode Interface </h2>

<p>This interface is an audio destination representing a
<code>MediaStream</code> with a single <code>AudioMediaStreamTrack</code>.  This
MediaStream is created when the node is created and is accessible via the
<dfn>stream</dfn> attribute.  This stream can be used in a similar way as a
<code>MediaStream</code> obtained via <code>getUserMedia()</code>, and can, for
example, be sent to a remote peer using the <code>RTCPeerConnection</code>
(described in [[!webrtc]])
<code>addStream()</code> method.
</p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : 0

    channelCount = 2;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>

<p>
  The number of channels of the input is by default 2 (stereo).  Any connections
  to the input are up-mixed/down-mixed to the number of channels of the input.
</p>

<dl title="interface MediaStreamAudioDestinationNode : AudioNode" class="idl">
  <dt> readonly attribute MediaStream stream </dt>
  <dd>
    A MediaStream containing a single AudioMediaStreamTrack with the same
    number of channels as the node itself.
  </dd>
</dl>

</section>

</section>

<section class="informative">
<h2>Mixer Gain Structure</h2>

<h3 id="background">Background</h3>

<p>One of the most important considerations when dealing with audio processing
graphs is how to adjust the gain (volume) at various points. For example, in a
standard mixing board model, each input bus has pre-gain, post-gain, and
send-gains. Submix and master out busses also have gain control. The gain
control described here can be used to implement standard mixing boards as well
as other architectures. </p>

<section>
  <h3 id="SummingJunction">Summing Inputs</h3>
  
  <p>The inputs to <a>AudioNode</a>s have
  the ability to accept connections from multiple outputs. The input then acts as
  a unity gain summing junction with each output signal being added with the
  others: </p>
  <figure>
    <img alt="unity gain summing junction" src="images/unity-gain-summing-junction.png" />
    <figcaption>A graph showing Source 1 and Source 2 output summed at the input
    of Destination</figcaption>
  </figure>
  
  <p>In cases where the channel layouts of the outputs do not match, a mix
  (usually up-mix) will occur according to the <a href="UpMix">mixing rules</a>.
  </p>
</section>

<section>
  <h3>Gain Control</h3>
  
  <p>But many times, it's important to be able to control the gain for each of
  the output signals. The <a>GainNode</a> gives this
  control: </p>
  <figure>
    <img alt="mixer architecture new" src="images/mixer-architecture-new.png" />
    <figcaption>A graph featuring volume control for each voice</figcaption>
  </figure>
  
  <p>Using these two concepts of unity gain summing junctions and GainNodes,
  it's possible to construct simple or complex mixing scenarios. </p>
</section>

<section>
  <h3 id="Example-mixer-with-send-busses">Example: Mixer with Send Busses</h3>
  
  <p>In a routing scenario involving multiple sends and submixes, explicit
  control is needed over the volume or "gain" of each connection to a mixer. Such
  routing topologies are very common and exist in even the simplest of electronic
  gear sitting around in a basic recording studio. </p>
  
  <p>Here's an example with two send mixers and a main mixer. Although possible,
  for simplicity's sake, pre-gain control and insert effects are not illustrated:
  </p>
  <figure>
    <img alt="mixer gain structure" src="images/mixer-gain-structure.png" />
    <figcaption>A graph showing a full mixer with send busses.</figcaption>
  </figure>
  
  <p>This diagram is using a shorthand notation where "send 1", "send 2", and
  "main bus" are actually inputs to <a>AudioNode</a>s, but here are represented as
  summing busses, where the intersections g2_1, g3_1, etc. represent the "gain"
  or volume for the given source on the given mixer. In order to expose this
  gain, an <a>GainNode</a> is used:
  </p>

  <p>Here's how the above diagram could be constructed in JavaScript: </p>

  <pre class="highlight example">

  var context = 0;
  var compressor = 0;
  var reverb = 0;
  var delay = 0;
  var s1 = 0;
  var s2 = 0;

  var source1 = 0;
  var source2 = 0;
  var g1_1 = 0;
  var g2_1 = 0;
  var g3_1 = 0;
  var g1_2 = 0;
  var g2_2 = 0;
  var g3_2 = 0;

  // Setup routing graph
  function setupRoutingGraph() {
      context = new AudioContext();

      compressor = context.createDynamicsCompressor();

      // Send1 effect
      reverb = context.createConvolver();
      // Convolver impulse response may be set here or later

      // Send2 effect
      delay = context.createDelay();

      // Connect final compressor to final destination
      compressor.connect(context.destination);

      // Connect sends 1 &amp; 2 through effects to main mixer
      s1 = context.createGain();
      reverb.connect(s1);
      s1.connect(compressor);

      s2 = context.createGain();
      delay.connect(s2);
      s2.connect(compressor);

      // Create a couple of sources
      source1 = context.createBufferSource();
      source2 = context.createBufferSource();
      source1.buffer = manTalkingBuffer;
      source2.buffer = footstepsBuffer;

      // Connect source1
      g1_1 = context.createGain();
      g2_1 = context.createGain();
      g3_1 = context.createGain();
      source1.connect(g1_1);
      source1.connect(g2_1);
      source1.connect(g3_1);
      g1_1.connect(compressor);
      g2_1.connect(reverb);
      g3_1.connect(delay);

      // Connect source2
      g1_2 = context.createGain();
      g2_2 = context.createGain();
      g3_2 = context.createGain();
      source2.connect(g1_2);
      source2.connect(g2_2);
      source2.connect(g3_2);
      g1_2.connect(compressor);
      g2_2.connect(reverb);
      g3_2.connect(delay);

      // We now have explicit control over all the volumes g1_1, g2_1, ..., s1, s2
      g2_1.gain.value = 0.2;  // For example, set source1 reverb gain

      // Because g2_1.gain is an "AudioParam",
      // an automation curve could also be attached to it.
      // A "mixing board" UI could be created in canvas or WebGL controlling these gains.
  }

   </pre>
</section>
</section>


<section>
<h2 id="DynamicLifetime">Dynamic Lifetime</h2>

<section>
<h3>Background</h3>

<p class="norm"><em>This section is non-normative. Please see <a href="#lifetime-AudioContext">AudioContext lifetime</a>
and <a href="#lifetime-AudioNode">AudioNode lifetime</a>  for normative
requirements.</em>
</p>

<p>In addition to allowing the creation of static routing configurations, it
should also be possible to do custom effect routing on dynamically allocated
voices which have a limited lifetime. For the purposes of this discussion,
let's call these short-lived voices "notes". Many audio applications
incorporate the ideas of notes, examples being drum machines, sequencers, and
3D games with many one-shot sounds being triggered according to game play. </p>

<p>In a traditional software synthesizer, notes are dynamically allocated and
released from a pool of available resources. The note is allocated when a MIDI
note-on message is received. It is released when the note has finished playing
either due to it having reached the end of its sample-data (if non-looping), it
having reached a sustain phase of its envelope which is zero, or due to a MIDI
note-off message putting it into the release phase of its envelope. In the MIDI
note-off case, the note is not released immediately, but only when the release
envelope phase has finished. At any given time, there can be a large number of
notes playing but the set of notes is constantly changing as new notes are
added into the routing graph, and old ones are released. </p>

<p>The audio system automatically deals with tearing-down the part of the
routing graph for individual "note" events. A "note" is represented by an
<code>AudioBufferSourceNode</code>, which can be directly connected to other
processing nodes. When the note has finished playing, the context will
automatically release the reference to the <code>AudioBufferSourceNode</code>,
which in turn will release references to any nodes it is connected to, and so
on. The nodes will automatically get disconnected from the graph and will be
deleted when they have no more references. Nodes in the graph which are
long-lived and shared between dynamic voices can be managed explicitly.
Although it sounds complicated, this all happens automatically with no extra
JavaScript handling required. </p>
</section>

<section>
<h3>Example</h3>
<figure>
  <img alt="dynamic allocation" src="images/dynamic-allocation.png" />
  <figcaption>A graph featuring a subgraph that will be releases early.</figcaption>
</figure>

<p>The low-pass filter, panner, and second gain nodes are directly connected
from the one-shot sound. So when it has finished playing the context will
automatically release them (everything within the dotted line). If there are no
longer any JavaScript references to the one-shot sound and connected nodes,
then they will be immediately removed from the graph and deleted. The streaming
source, has a global reference and will remain connected until it is explicitly
disconnected. Here's how it might look in JavaScript: </p>

<pre class="example highlight">

var context = 0;
var compressor = 0;
var gainNode1 = 0;
var streamingAudioSource = 0;

// Initial setup of the "long-lived" part of the routing graph
function setupAudioContext() {
    context = new AudioContext();

    compressor = context.createDynamicsCompressor();
    gainNode1 = context.createGain();

    // Create a streaming audio source.
    var audioElement = document.getElementById('audioTagID');
    streamingAudioSource = context.createMediaElementSource(audioElement);
    streamingAudioSource.connect(gainNode1);

    gainNode1.connect(compressor);
    compressor.connect(context.destination);
}

// Later in response to some user action (typically mouse or key event)
// a one-shot sound can be played.
function playSound() {
    var oneShotSound = context.createBufferSource();
    oneShotSound.buffer = dogBarkingBuffer;

    // Create a filter, panner, and gain node.
    var lowpass = context.createBiquadFilter();
    var panner = context.createPanner();
    var gainNode2 = context.createGain();

    // Make connections
    oneShotSound.connect(lowpass);
    lowpass.connect(panner);
    panner.connect(gainNode2);
    gainNode2.connect(compressor);

    // Play 0.75 seconds from now (to play immediately pass in 0)
    oneShotSound.start(context.currentTime + 0.75);
}
</pre>
</section>
</section>



<section>
<h2>Channel up-mixing and down-mixing</h2>

<p class="norm">This section is normative.</p>

<p>
<a href="#mixer-gain-structure"></a>
describes how an input to an <a>AudioNode</a> can be connected from one or more outputs
of an <a>AudioNode</a>.  Each of these connections from an output represents a stream with
a specific non-zero number of channels.  An input has <em>mixing rules</em> for combining the channels
from all of the connections to it.  As a simple example, if an input is connected from a mono output and
a stereo output, then the mono connection will usually be up-mixed to stereo and summed with
the stereo connection.  But, of course, it's important to define the exact <em>mixing rules</em> for
every input to every <a>AudioNode</a>.  The default mixing rules for all of the inputs have been chosen so that
things "just work" without worrying too much about the details, especially in the very common
case of mono and stereo streams.  But the rules can be changed for advanced use cases, especially
multi-channel.
</p>

<p>
To define some terms, <em>up-mixing</em> refers to the process of taking a stream with a smaller
number of channels and converting it to a stream with a larger number of channels.  <em>down-mixing</em>
refers to the process of taking a stream with a larger number of channels and converting it to a stream
with a smaller number of channels.
</p>

<p>
An <a>AudioNode</a> input use three basic pieces of information to determine how to mix all the outputs
connected to it.  As part of this process it computes an internal value <dfn><code>computedNumberOfChannels</code></dfn>
representing the actual number of channels of the input at any given time:
</p>

<p>
The <a>AudioNode</a> attributes involved in channel up-mixing and down-mixing rules are defined
<a href="#AudioNode">above</a>.  The following is a more precise specification
on what each of them mean.
</p>

<ul>
<li><a href="#widl-AudioNode-channelCount"><code>channelCount</code></a> is used to help compute <a><code>computedNumberOfChannels</code></a>.</li>

<li><a href="#widl-AudioNode-channelCountMode"><code>channelCountMode</code></a> determines how <a><code>computedNumberOfChannels</code></a> will be computed.
Once this number is computed, all of the connections will be up or down-mixed to that many channels.  For most nodes,
the default value is <a href="#idl-def-ChannelCountMode.max"><code>"max"</code></a>.
<ul>
<li><a href="#idl-def-ChannelCountMode.max"><code>"max"</code></a>: <a><code>computedNumberOfChannels</code></a> is computed as the maximum of the number of channels of all connections.
In this mode <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a> is ignored.</li>
<li><a href="#idl-def-ChannelCountMode.clamped-max"><code>"clamped-max"</code></a>: same as “max” up to a limit of the <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a></li>
<li><a href="#idl-def-ChannelCountMode.explicit"><code>"explicit"</code></a>: <a><code>computedNumberOfChannels</code></a> is the exact value as specified
in <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a></li>
</ul>

</li>

<li><a href="#widl-AudioNode-channelInterpretation"><code>channelInterpretation</code></a> determines how the individual channels will be treated.
For example, will they be treated as speakers having a specific layout, or will they
be treated as simple discrete channels?  This value influences exactly how the up and down mixing is
performed.  The default value is "speakers".

<ul>
  <li><a
    href="#idl-def-ChannelInterpretation.speakers"><code>“speakers”</code></a>:
  use <a href="#ChannelLayouts">up-down-mix equations for
  mono/stereo/quad/5.1</a>.  In cases where the number of channels do not match
any of these basic speaker layouts, revert to "discrete".
</li>
<li><a
  href="#idl-def-ChannelInterpretation.discrete"><code>“discrete”</code></a>:
up-mix by filling channels until they run out then zero out remaining channels.
down-mix by filling as many channels as possible, then dropping remaining
channels</li>
</ul>

</li>

</ul>

<p>
For each input of an <a>AudioNode</a>, an implementation must:
</p>

<ol>
<li>Compute <a>computedNumberOfChannels</a>.</li>
<li>
  For each connection to the input:
  <ul>
    <li>
      up-mix or down-mix the connection to <a><code>computedNumberOfChannels</code></a>
      according to <a href="#widl-AudioNode-channelInterpretation"><code>channelInterpretation</code></a>.
    </li>
    <li>
      Mix it together with all of the other mixed streams (from other
      connections). This is a straight-forward mixing together of each of the
      corresponding channels from each
      connection.
    </li>
  </ul>
</li>
</ol>




<section>
  <h3 id="ChannelLayouts">Speaker Channel Layouts</h3>
  
  <p class="norm">This section is normative.</p>
  
  <p>
  When <a
    href="#widl-AudioNode-channelInterpretation"><code>channelInterpretation</code></a>
  is <a href="#idl-def-ChannelInterpretation-speakers">"speakers"</a> then the up-mixing and down-mixing
  is defined for specific channel layouts.
  </p>
  
  <p>It's important to define the channel ordering (and define some
  abbreviations) for these speaker layouts.</p>
  
  <p>
  For now, only considers cases for mono, stereo, quad, 5.1. Later other channel
  layouts can be defined.
  </p>
</section>

<section>
  <h4 id ="ChannelOrdering">Channel ordering</h4>
  
  <pre>  Mono
      0: M: mono
      
    Stereo
      0: L: left
      1: R: right
    </pre>
  
  <pre>  Quad
      0: L:  left
      1: R:  right
      2: SL: surround left
      3: SR: surround right
  
    5.1
      0: L:   left
      1: R:   right
      2: C:   center
      3: LFE: subwoofer
      4: SL:  surround left
      5: SR:  surround right
  </pre>
</section>

<section><h4 id="UpMix-sub">Up Mixing speaker layouts</h4>

<pre>Mono up-mix:
    
    1 -&gt; 2 : up-mix from mono to stereo
        output.L = input;
        output.R = input;

    1 -&gt; 4 : up-mix from mono to quad
        output.L = input;
        output.R = input;
        output.SL = 0;
        output.SR = 0;

    1 -&gt; 5.1 : up-mix from mono to 5.1
        output.L = 0;
        output.R = 0;
        output.C = input; // put in center channel
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Stereo up-mix:

    2 -&gt; 4 : up-mix from stereo to quad
        output.L = input.L;
        output.R = input.R;
        output.SL = 0;
        output.SR = 0;

    2 -&gt; 5.1 : up-mix from stereo to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Quad up-mix:

    4 -&gt; 5.1 : up-mix from quad to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = input.SL;
        output.SR = input.SR;</pre>

</section>

<section>
  <h4 id="down-mix">Down Mixing speaker layouts</h4>
  
  <p>A down-mix will be necessary, for example, if processing 5.1 source
  material, but playing back stereo. </p>
  <pre>
  Mono down-mix:
  
      2 -&gt; 1 : stereo to mono
          output = 0.5 * (input.L + input.R);
  
      4 -&gt; 1 : quad to mono
          output = 0.25 * (input.L + input.R + input.SL + input.SR);
  
      5.1 -&gt; 1 : 5.1 to mono
          output = 0.7071 * (input.L + input.R) + input.C + 0.5 * (input.SL + input.SR)
  
  
  Stereo down-mix:
  
      4 -&gt; 2 : quad to stereo
          output.L = 0.5 * (input.L + input.SL);
          output.R = 0.5 * (input.R + input.SR);
  
      5.1 -&gt; 2 : 5.1 to stereo
          output.L = L + 0.7071 * (input.C + input.SL)
          output.R = R + 0.7071 * (input.C + input.SR)
  
  Quad down-mix:
  
      5.1 -&gt; 4 : 5.1 to quad
          output.L = L + 0.7071 * input.C
          output.R = R + 0.7071 * input.C
          output.SL = input.SL
          output.SR = input.SR
  
  </pre>
</section>

<section class="informative">
  <h3 id="ChannelRules-section">Channel Rules Examples</h3>
  
  <pre class="highlight example">
  // Set gain node to explicit 2-channels (stereo).
  gain.channelCount = 2;
  gain.channelCountMode = "explicit";
  gain.channelInterpretation = "speakers";
  
  // Set "hardware output" to 4-channels for DJ-app with two stereo output busses.
  context.destination.channelCount = 4;
  context.destination.channelCountMode = "explicit";
  context.destination.channelInterpretation = "discrete";
  
  // Set "hardware output" to 8-channels for custom multi-channel speaker array
  // with custom matrix mixing.
  context.destination.channelCount = 8;
  context.destination.channelCountMode = "explicit";
  context.destination.channelInterpretation = "discrete";
  
  // Set "hardware output" to 5.1 to play an HTMLAudioElement.
  context.destination.channelCount = 6;
  context.destination.channelCountMode = "explicit";
  context.destination.channelInterpretation = "speakers";
  
  // Explicitly down-mix to mono.
  gain.channelCount = 1;
  gain.channelCountMode = "explicit";
  gain.channelInterpretation = "speakers";
  </pre>
</section>
</section>


<section>
<h2 id="Spatialization">Spatialization / Panning </h2>

<section>
  <h3 id="Spatialization-background">Background</h3>
  
  <p>A common feature requirement for modern 3D games is the ability to
  dynamically spatialize and move multiple audio sources in 3D space. Game audio
  engines such as OpenAL, FMOD, Creative's EAX, Microsoft's XACT Audio, etc. have
  this ability. </p>
  
  <p>Using an <code>PannerNode</code>, an audio stream can be spatialized or
  positioned in space relative to an <a>AudioListener</a>. An
  <a><code>AudioContext</code></a> will contain a
  single <a>AudioListener</a>. Both panners and listeners have a position
  in 3D space using a right-handed cartesian coordinate system.
  The units used in the coordinate system are not defined, and do not need to be
  because the effects calculated with these coordinates are independent/invariant
  of any particular units such as meters or feet.  <a>PannerNode</a>
  objects (representing the source stream) have an <code>orientation</code>
  vector representing in which direction the sound is projecting. Additionally,
  they have a <code>sound cone</code> representing how directional the sound is.
  For example, the sound could be omnidirectional, in which case it would be
  heard anywhere regardless of its orientation, or it can be more directional and
  heard only if it is facing the listener. <a>AudioListener</a> objects
  (representing a person's ears) have an <code>orientation</code> and
  <code>up</code> vector representing in which direction the person is facing.
  Because both the source stream and the listener can be moving, they both have a
  <code>velocity</code> vector representing both the speed and direction of
  movement. Taken together, these two velocities can be used to generate a
  doppler shift effect which changes the pitch. </p>
  
  <p>
  During rendering, the <a>PannerNode</a> calculates an <em>azimuth</em>
  and <em>elevation</em>.  These values are used internally by the implementation in
  order to render the spatialization effect.  See the <a
    href="#Spatialization-panning-algorithm">Panning Algorithm</a> section for
  details of how these values are used.
  </p>
  
  <p>
  The following algorithm must be used to calculate the <em>azimuth</em>
  and <em>elevation</em>:
  </p>
  
  <pre class="code highlight">
  // Calculate the source-listener vector.
  vec3 sourceListener = source.position - listener.position;
  
  if (sourceListener.isZero()) {
      // Handle degenerate case if source and listener are at the same point.
      azimuth = 0;
      elevation = 0;
      return;
  }
  
  sourceListener.normalize();
  
  // Align axes.
  vec3 listenerFront = listener.orientation;
  vec3 listenerUp = listener.up;
  vec3 listenerRight = listenerFront.cross(listenerUp);
  listenerRight.normalize();
  
  vec3 listenerFrontNorm = listenerFront;
  listenerFrontNorm.normalize();
  
  vec3 up = listenerRight.cross(listenerFrontNorm);
  
  float upProjection = sourceListener.dot(up);
  
  vec3 projectedSource = sourceListener - upProjection * up;
  projectedSource.normalize();
  
  azimuth = 180 * acos(projectedSource.dot(listenerRight)) / PI;
  
  // Source in front or behind the listener.
  double frontBack = projectedSource.dot(listenerFrontNorm);
  if (frontBack &lt; 0)
      azimuth = 360 - azimuth;
  
  // Make azimuth relative to "front" and not "right" listener vector.
  if ((azimuth &gt;= 0) &amp;&amp; (azimuth &lt;= 270))
      azimuth = 90 - azimuth;
  else
      azimuth = 450 - azimuth;
  
  elevation = 90 - 180 * acos(sourceListener.dot(up)) / PI;
  
  if (elevation &gt; 90)
      elevation = 180 - elevation;
  else if (elevation &lt; -90)
      elevation = -180 - elevation;
  </pre>
</section>

<section>
  <h3 id="Spatialization-panning-algorithm">Panning Algorithm</h3>
  
  <p>
  <em>mono->stereo</em> and <em>stereo->stereo</em>  panning must be supported.
  <em>mono->stereo</em> processing is used when all connections to the input are mono.
  Otherwise <em>stereo->stereo</em> processing is used.</p>
  
  <p>The following algorithms must be implemented: </p>
  <ul>
    <li>Equal-power (Vector-based) panning
      <p>This is a simple and relatively inexpensive algorithm which provides
      basic, but reasonable results.  It is commonly used when panning musical sources.
      </p>
      The <em>elevation</em> value is ignored in this panning algorithm.
  
      <p>
      The following steps are used for processing:
      </p>
      
      <ol>
  
      <li>
      <p>
      The <em>azimuth</em> value is first contained to be within the range -90 &lt;= <em>azimuth</em> &lt;= +90 according to:
      </p>
      <pre class="highlight">
      // Clamp azimuth to allowed range of -180 -&gt; +180.
      azimuth = max(-180, azimuth);
      azimuth = min(180, azimuth);
  
      // Now wrap to range -90 -&gt; +90.
      if (azimuth &lt; -90)
          azimuth = -180 - azimuth;
      else if (azimuth &gt; 90)
          azimuth = 180 - azimuth;
      </pre>
      </li>
      
      <li>
      <p>
      A 0 -&gt; 1 normalized value <em>x</em> is calculated from <em>azimuth</em> for <em>mono->stereo</em> as:
      </p>
      <pre class="highlight">
      x = (azimuth + 90) / 180
      </pre>
  
      <p>
      Or for <em>stereo->stereo</em> as:
      </p>
      <pre class="highlight">
      if (azimuth &lt;= 0) { // from -90 -&gt; 0
          // inputL -> outputL and "equal-power pan" inputR as in mono case
          // by transforming the "azimuth" value from -90 -&gt; 0 degrees into the range -90 -&gt; +90.
          x = (azimuth + 90) / 90;
      } else { // from 0 -> +90
          // inputR -> outputR and "equal-power pan" inputL as in mono case
          // by transforming the "azimuth" value from 0 -&gt; +90 degrees into the range -90 -&gt; +90.
          x = azimuth / 90;
      }
      </pre>
      </li>
      
      <li>
      <p>
      Left and right gain values are then calculated:
      </p>
      <pre class="highlight">
      gainL = cos(0.5 * PI * x);
      gainR = sin(0.5 * PI * x);
      </pre>
      </li>
      
      <li>
      <p>For <em>mono->stereo</em>, the output is calculated as:</p>
      <pre class="highlight">
      outputL = input * gainL
      outputR = input * gainR
      </pre>
      <p>Else for <em>stereo->stereo</em>, the output is calculated as:</p>
      <pre class="highlight">
      if (azimuth &lt;= 0) { // from -90 -&gt; 0
          outputL = inputL + inputR * gainL;
          outputR = inputR * gainR;
      } else { // from 0 -&gt; +90
          outputL = inputL * gainL;
          outputR = inputR + inputL * gainR;
      }
      </pre>
      </li>
      
      </ol>
      
      
      
    </li>
    <li><a
      href="http://en.wikipedia.org/wiki/Head-related_transfer_function">HRTF</a>
      panning (stereo only).
      <p>This requires a set of HRTF impulse responses recorded at a variety of
      azimuths and elevations. There are a small number of open/free impulse
      responses available. The implementation requires a highly optimized
      convolution function. It is somewhat more costly than "equal-power", but
      provides a more spatialized sound. </p>
      <figure>
        <img alt="HRTF panner" src="images/HRTF_panner.png" />
        <figcaption>A diagram showing the process of panning a source using
        HRTF.</figcaption>
      </figure>
    </li>
  </ul>
</section>

<section>
  <h3 id="Spatialization-distance-effects">Distance Effects</h3>
  <p>
  Sounds which are closer are louder, while sounds further away are quieter.
  Exactly <em>how</em> a sound's volume changes according to distance from the listener
  depends on the <em>distanceModel</em> attribute.
  </p>
  
  
  <p>
  During audio rendering, a <em>distance</em> value will be calculated based on the panner and listener positions according to:
  </p>
  <pre class="highlight">
  v = panner.position - listener.position
  </pre>
  <pre class="highlight">
  distance = sqrt(dot(v, v))
  </pre>
  
  <p>
  <em>distance</em> will then be used to calculate <em>distanceGain</em> which
  depends on the <em>distanceModel</em> attribute.  See the <a
  href="##idl-def-DistanceModelType">distanceModel</a> section for details of
how this is calculated for each distance model.
  </p>
  <p>As part of its processing, the <code>PannerNode</code> scales/multiplies the input audio signal by <em>distanceGain</em>
  to make distant sounds quieter and nearer ones louder.
  </p>
</section>

<section>
  <h3 id="Spatialization-sound-cones">Sound Cones</h3>
  
  <p>The listener and each sound source have an orientation vector describing
  which way they are facing. Each sound source's sound projection characteristics
  are described by an inner and outer "cone" describing the sound intensity as a
  function of the source/listener angle from the source's orientation vector.
  Thus, a sound source pointing directly at the listener will be louder than if
  it is pointed off-axis. Sound sources can also be omni-directional. </p>
  
  <p>
  The following algorithm must be used to calculate the gain contribution due
  to the cone effect, given the source (the <code>PannerNode</code>) and the listener:
  </p>
  
  <pre class="highlight">
  if (source.orientation.isZero() || ((source.coneInnerAngle == 360) &amp;&amp; (source.coneOuterAngle == 360)))
      return 1; // no cone specified - unity gain
  
  // Normalized source-listener vector
  vec3 sourceToListener = listener.position - source.position;
  sourceToListener.normalize();
  
  vec3 normalizedSourceOrientation = source.orientation;
  normalizedSourceOrientation.normalize();
  
  // Angle between the source orientation vector and the source-listener vector
  double dotProduct = sourceToListener.dot(normalizedSourceOrientation);
  double angle = 180 * acos(dotProduct) / PI;
  double absAngle = fabs(angle);
  
  // Divide by 2 here since API is entire angle (not half-angle)
  double absInnerAngle = fabs(source.coneInnerAngle) / 2;
  double absOuterAngle = fabs(source.coneOuterAngle) / 2;
  double gain = 1;
  
  if (absAngle &lt;= absInnerAngle)
      // No attenuation
      gain = 1;
  else if (absAngle &gt;= absOuterAngle)
      // Max attenuation
      gain = source.coneOuterGain;
  else {
      // Between inner and outer cones
      // inner -&gt; outer, x goes from 0 -&gt; 1
      double x = (absAngle - absInnerAngle) / (absOuterAngle - absInnerAngle);
      gain = (1 - x) + source.coneOuterGain * x;
  }
  
  return gain;
  </pre>
</section>

<section>
<h3 id="Spatialization-doppler-shift">Doppler Shift</h3>
  <ul>
    <li>Introduces a pitch shift which can realistically simulate moving
    sources.</li>
    <li>Depends on: source / listener velocity vectors, speed of sound, doppler
      factor.</li>
  </ul>
  
  <p>
  The following algorithm must be used to calculate the doppler shift value which is used
  as an additional playback rate scalar for all AudioBufferSourceNodes connecting directly or
  indirectly to the AudioPannerNode:
  </p>
  
  <pre class="highlight">
  double dopplerShift = 1; // Initialize to default value
  double dopplerFactor = listener.dopplerFactor;
  
  if (dopplerFactor &gt; 0) {
      double speedOfSound = listener.speedOfSound;
  
      // Don't bother if both source and listener have no velocity.
      if (!source.velocity.isZero() || !listener.velocity.isZero()) {
          // Calculate the source to listener vector.
          vec3 sourceToListener = source.position - listener.position;
  
          double sourceListenerMagnitude = sourceToListener.length();
  
          double listenerProjection = sourceToListener.dot(listener.velocity) / sourceListenerMagnitude;
          double sourceProjection = sourceToListener.dot(source.velocity) / sourceListenerMagnitude;
  
          listenerProjection = -listenerProjection;
          sourceProjection = -sourceProjection;
  
          double scaledSpeedOfSound = speedOfSound / dopplerFactor;
          listenerProjection = min(listenerProjection, scaledSpeedOfSound);
          sourceProjection = min(sourceProjection, scaledSpeedOfSound);
  
          dopplerShift = ((speedOfSound - dopplerFactor * listenerProjection) / (speedOfSound - dopplerFactor * sourceProjection));
          fixNANs(dopplerShift); // Avoid illegal values
  
          // Limit the pitch shifting to 4 octaves up and 3 octaves down.
          dopplerShift = min(dopplerShift, 16);
          dopplerShift = max(dopplerShift, 0.125);
      }
  }
  </pre>
</section>
</section>

<section>
<h2 id="Convolution">Linear Effects using Convolution</h2>

<section>
  <h3 id="Convolution-background">Background</h3>
  
  <p><a href="http://en.wikipedia.org/wiki/Convolution">Convolution</a> is a
  mathematical process which can be applied to an audio signal to achieve many
  interesting high-quality linear effects. Very often, the effect is used to
  simulate an acoustic space such as a concert hall, cathedral, or outdoor
  amphitheater. It can also be used for complex filter effects, like a muffled
  sound coming from inside a closet, sound underwater, sound coming through a
  telephone, or playing through a vintage speaker cabinet. This technique is very
  commonly used in major motion picture and music production and is considered to
  be extremely versatile and of high quality. </p>
  
  <p>Each unique effect is defined by an <code>impulse response</code>. An
  impulse response can be represented as an audio file and <a
  href="#recording-impulse-responses">can be recorded</a> from a real acoustic
  space such as a cave, or can be synthetically generated through a great variety
  of techniques. </p>
</section>

<section>
  <h3 id="Convolution-motivation">Motivation for use as a Standard</h3>
  
  <p>A key feature of many game audio engines (OpenAL, FMOD, Creative's EAX,
  Microsoft's XACT Audio, etc.) is a reverberation effect for simulating the
  sound of being in an acoustic space. But the code used to generate the effect
  has generally been custom and algorithmic (generally using a hand-tweaked set
  of delay lines and allpass filters which feedback into each other). In nearly
  all cases, not only is the implementation custom, but the code is proprietary
  and closed-source, each company adding its own "black magic" to achieve its
  unique quality. Each implementation being custom with a different set of
  parameters makes it impossible to achieve a uniform desired effect. And the
  code being proprietary makes it impossible to adopt a single one of the
  implementations as a standard. Additionally, algorithmic reverberation effects
  are limited to a relatively narrow range of different effects, regardless of
  how the parameters are tweaked. </p>
  
  <p>A convolution effect solves these problems by using a very precisely defined
  mathematical algorithm as the basis of its processing. An impulse response
  represents an exact sound effect to be applied to an audio stream and is easily
  represented by an audio file which can be referenced by URL. The range of
  possible effects is enormous. </p>
</section>

<section>
  <h3 id="Convolution-implementation-guide">Implementation Guide</h3>
  <p>
  Linear convolution can be implemented efficiently.
  Here are some <a href="convolution.html">notes</a>
  describing how it can be practically implemented.
  </p>
</section>

<section>
  <h3 id="Convolution-reverb-effect">Reverb Effect (with matrixing)</h3>
  
  <p class="norm">This section is normative.</p>
  
  <p>
  In the general case the source
  has N input channels, the impulse response has K channels, and the playback
  system has M output channels. Thus it's a matter of how to matrix these
  channels to achieve the final result.
  </p>
  
  <p>
  The subset of N, M, K below must be implemented (note that the first image in the diagram is just illustrating
  the general case and is not normative, while the following images are normative).
  Without loss of generality, developers desiring more complex and arbitrary
  matrixing can use multiple <a>ConvolverNode</a>
  objects in conjunction with an <a>ChannelMergerNode</a>.
  </p>
  
  
  <p>Single channel convolution operates on a mono audio input, using a mono
  impulse response, and generating a mono output. But to achieve a more spacious sound, 2 channel audio
  inputs and 1, 2, or 4 channel impulse responses will be considered. The following diagram, illustrates the
  common cases for stereo playback where N and M are 1 or 2 and K is 1, 2, or 4.
  </p>
  <figure>
    <img alt="reverb matrixing" src="images/reverb-matrixing.png" />
    <figcaption>A graphical representation of the different input and output channel
    count possibilities when using a <a>ConvolverNode</a>.</figcaption>
  </figure>
</section>

<section class="informative">
  <h3 id="recording-impulse-responses">Recording Impulse Responses</h3>
  
  <figure>
    <img alt="impulse response" src="images/impulse-response.png" />
    <figcaption>A time-domain representation of an impulse
    response.</figcaption>
  </figure>

  <p>The most <a
  href="http://pcfarina.eng.unipr.it/Public/Papers/226-AES122.pdf">modern</a> and
  accurate way to record the impulse response of a real acoustic space is to use
  a long exponential sine sweep. The test-tone can be as long as 20 or 30
  seconds, or longer.
  Several recordings of the test tone played through a speaker can be made with
  microphones placed and oriented at various positions in the room. It's
  important to document speaker placement/orientation, the types of microphones,
  their settings, placement, and orientations for each recording taken. </p>
  
  <p>Post-processing is required for each of these recordings by performing an
  inverse-convolution with the test tone, yielding the impulse response of the
  room with the corresponding microphone placement. These impulse responses are
  then ready to be loaded into the convolution reverb engine to re-create the
  sound of being in the room. </p>
</section>

<section>
  <h3 id="tools">Tools</h3>
  
  <p>Two command-line tools have been written, <code>generate_testtones</code>
  generates an exponential sine-sweep test-tone and its inverse. Another tool
  <code>convolve</code> was written for post-processing. With these tools,
  anybody with recording equipment can record their own impulse responses. To
  test the tools in practice, several recordings
  were made in a warehouse space with interesting acoustics. These were later
  post-processed with the command-line tools.
  <pre>
  <code>% generate_testtones -h</code>
  Usage: generate_testtone
    [-o /Path/To/File/To/Create] Two files will be created: .tone and .inverse
    [-rate &lt;sample rate&gt;] sample rate of the generated test tones
    [-duration &lt;duration&gt;] The duration, in seconds, of the generated files
    [-min_freq &lt;min_freq&gt;] The minimum frequency, in hertz, for the sine sweep
  </pre>

  <pre>
  <code>% convolve -h</code>
  Usage: convolve input_file impulse_response_file output_file</pre>
</section>


<section>
  <h3 id="recording-setup">Recording Setup</h3>
  <figure>
    <img alt="recording setup" src="images/recording-setup.png" />
    <figcaption>Audio Interface: Metric Halo Mobile I/O 2882</figcaption>
  </figure>
  <figure>
    <img alt="microphones speaker" src="images/microphones-speaker.png" />
    <figcaption>The microphone and speaker positions</figcaption>
  </figure>
  <figure>
    <img alt="microphone" src="images/microphone.png" />
    <figcaption>Microphones: AKG 414s</figcaption>
  </figure>
  <figure>
    <img alt="speaker" src="images/speaker.png" />
<figcaption>Speaker: Mackie HR824 </figcaption>
  </figure>
</section>
  
  
<section>
  <h3 id="warehouse">The Warehouse Space</h3>
  <figure>
    <img alt="warehouse" src="images/warehouse.png" />
    <figcaption>The space in which the impulse is recorded</figcaption>
  </figure>
</section>
</section>

<section class="informative">
<h2 id="JavaScriptProcessing">JavaScript Synthesis and Processing</h2>

<p>The Mozilla project has conducted <a
href="https://wiki.mozilla.org/Audio_Data_API">Experiments</a> to synthesize
and process audio directly in JavaScript. This approach is interesting for a
certain class of audio processing and they have produced a number of impressive
demos. This specification includes a means of synthesizing and processing
directly using JavaScript by using a special subtype of <a>AudioNode</a> called
<a>ScriptProcessorNode</a>. </p>

<p>Here are some interesting examples where direct JavaScript processing can be
useful: </p>

<section>
  <h3 id="custom-DSP-effects">Custom DSP Effects</h3>
  
  <p>Unusual and interesting custom audio processing can be done directly in JS.
  It's also a good test-bed for prototyping new algorithms. This is an extremely
  rich area. </p>
</section>

<section>
  <h3 id="educational-applications">Educational Applications</h3>
  
  <p>JS processing is ideal for illustrating concepts in computer music synthesis
  and processing, such as showing the de-composition of a square wave into its
  harmonic components, FM synthesis techniques, etc. </p>
</section>

<section>
  <h3 id="javaScript-performance">JavaScript Performance</h3>
  
  <p>JavaScript has a variety of <a
  href="#JavaScriptPerformance">performance issues</a> so it is not
  suitable for all types of audio processing. The approach proposed in this
  document includes the ability to perform computationally intensive aspects of
  the audio processing (too expensive for JavaScript to compute in real-time)
  such as multi-source 3D spatialization and convolution in optimized C++ code.
  Both direct JavaScript processing and C++ optimized code can be combined due to
  the APIs <a href="#ModularRouting">modular approach</a>. </p>
</section>
</section>

<section>
<h2 id="Performance">Performance Considerations</h2>

<section>
  <h3>Latency</h3>
  <figure>
    <img alt="latency" src="images/latency.png" />
    <figcaption>Use cases in which the latency can be important</figcaption>
  </figure>

  <p>For web applications, the time delay between mouse and keyboard events
  (keydown, mousedown, etc.) and a sound being heard is important. </p>

  <p>This time delay is called latency and is caused by several factors (input
  device latency, internal buffering latency, DSP processing latency, output
  device latency, distance of user's ears from speakers, etc.), and is
  cummulative. The larger this latency is, the less satisfying the user's
  experience is going to be. In the extreme, it can make musical production or
  game-play impossible. At moderate levels it can affect timing and give the
  impression of sounds lagging behind or the game being non-responsive. For
  musical applications the timing problems affect rhythm. For gaming, the timing
  problems affect precision of gameplay. For interactive applications, it
  generally cheapens the users experience much in the same way that very low
  animation frame-rates do. Depending on the application, a reasonable latency
  can be from as low as 3-6 milliseconds to 25-50 milliseconds. </p>
</section>

<section>
  <h3>Audio Glitching</h3>
  
  <p>Audio glitches are caused by an interruption of the normal continuous audio
  stream, resulting in loud clicks and pops. It is considered to be a
  catastrophic failure of a multi-media system and must be avoided. It can be
  caused by problems with the threads responsible for delivering the audio stream
  to the hardware, such as scheduling latencies caused by threads not having the
  proper priority and time-constraints. It can also be caused by the audio DSP
  trying to do more work than is possible in real-time given the CPU's speed. </p>
</section>

<section>
  <h3>Hardware Scalability</h3>
  
  <p>The system should gracefully degrade to allow audio processing under
  resource constrained conditions without dropping audio frames. </p>
  
  <p>First of all, it should be clear that regardless of the platform, the audio
  processing load should never be enough to completely lock up the machine.
  Second, the audio rendering needs to produce a clean, un-interrupted audio
  stream without audible <a href="#Glitching">glitches</a>. </p>
  
  <p>The system should be able to run on a range of hardware, from mobile phones
  and tablet devices to laptop and desktop computers. But the more limited
  compute resources on a phone device make it necessary to consider techniques to
  scale back and reduce the complexity of the audio rendering. For example,
  voice-dropping algorithms can be implemented to reduce the total number of
  notes playing at any given time. </p>
  
  <p>Here's a list of some techniques which can be used to limit CPU usage: </p>
  
  <section>
    <h4 id="CPU-monitoring">CPU monitoring</h4>
    
    <p>In order to avoid audio breakup, CPU usage must remain below 100%. </p>
    
  <p>The relative CPU usage can be dynamically measured for each <a>AudioNode</a> (and
    chains of connected nodes) as a percentage of the rendering time quantum. In a
    single-threaded implementation, overall CPU usage must remain below 100%. The
    measured usage may be used internally in the implementation for dynamic
    adjustments to the rendering. It may also be exposed through a
    <code>cpuUsage</code> attribute of <a>AudioNode</a> for use by
    JavaScript. </p>
    
    <p>In cases where the measured CPU usage is near 100% (or whatever threshold is
    considered too high), then an attempt to add additional <a>AudioNode</a>s
    into the rendering graph can trigger voice-dropping. </p>
  </section>
  
  <section>
    <h4 id="Voice-dropping">Voice Dropping</h4>
    
    <p>Voice-dropping is a technique which limits the number of voices (notes)
    playing at the same time to keep CPU usage within a reasonable range. There can
    either be an upper threshold on the total number of voices allowed at any given
    time, or CPU usage can be dynamically monitored and voices dropped when CPU
    usage exceeds a threshold. Or a combination of these two techniques can be
    applied. When CPU usage is monitored for each voice, it can be measured all the
    way from a source node through any effect processing nodes which apply
    uniquely to that voice. </p>
    
    <p>When a voice is "dropped", it needs to happen in such a way that it doesn't
    introduce audible clicks or pops into the rendered audio stream. One way to
    achieve this is to quickly fade-out the rendered audio for that voice before
    completely removing it from the rendering graph. </p>
    
    <p>When it is determined that one or more voices must be dropped, there are
    various strategies for picking which voice(s) to drop out of the total ensemble
    of voices currently playing. Here are some of the factors which can be used in
    combination to help with this decision: </p>
    <ul>
      <li>Older voices, which have been playing the longest can be dropped instead
        of more recent voices. </li>
      <li>Quieter voices, which are contributing less to the overall mix may be
        dropped instead of louder ones. </li>
      <li>Voices which are consuming relatively more CPU resources may be dropped
        instead of less "expensive" voices.</li>
      <li>An <a>AudioNode</a> can have a <code>priority</code> attribute to help determine
        the relative importance of the voices.</li>
    </ul>
  </section>

  <section>
    <h4 id="Simplification-of-Effects-Processing">Simplification of Effects
    Processing</h4>
    
    <p>Most of the effects described in this document are relatively inexpensive
    and will likely be able to run even on the slower mobile devices. However, the
    <a href="#ConvolverNode">convolution effect</a> can be configured with
    a variety of impulse responses, some of which will likely be too heavy for
    mobile devices. Generally speaking, CPU usage scales with the length of the
    impulse response and the number of channels it has. Thus, it is reasonable to
    consider that impulse responses which exceed a certain length will not be
    allowed to run. The exact limit can be determined based on the speed of the
    device. Instead of outright rejecting convolution with these long responses, it
    may be interesting to consider truncating the impulse responses to the maximum
    allowed length and/or reducing the number of channels of the impulse response.
    </p>
    
    <p>In addition to the convolution effect. The <a>PannerNode</a>
    may also be expensive if using the HRTF panning model. For slower devices, a
    cheaper algorithm such as EQUALPOWER can be used to conserve compute
    resources. </p>
  </section>
  
  <section>
    <h4 id="Sample-rate">Sample Rate</h4>
    
    <p>For very slow devices, it may be worth considering running the rendering at
    a lower sample-rate than normal. For example, the sample-rate can be reduced
    from 44.1KHz to 22.05KHz. This decision must be made when the
    <code>AudioContext</code> is created, because changing the sample-rate
    on-the-fly can be difficult to implement and will result in audible glitching
    when the transition is made. </p>
  </section>
  
  <section>
    <h4 id="pre-flighting">Pre-flighting</h4>
    
    <p>It should be possible to invoke some kind of "pre-flighting" code (through
    JavaScript) to roughly determine the power of the machine. The JavaScript code
    can then use this information to scale back any more intensive processing it
    may normally run on a more powerful machine. Also, the underlying
    implementation may be able to factor in this information in the voice-dropping
    algorithm. </p>
    
    <p><span class="ednote">TODO: add specification and more detail here </span></p>
  </section>
  
  <section>
    <h4 id="Authoring-for-different-user-agents">Authoring for different
    user agents</h4>
    JavaScript code can use information about user-agent to scale back any more
    intensive processing it may normally run on a more powerful machine. 
  </section>
  
  <section>
    <h4 id="Scalability-of-Direct-JavaScript-Synthesis">Scalability of Direct JavaScript Synthesis / Processing</h4>
    
    <p>Any audio DSP / processing code done directly in JavaScript should also be
    concerned about scalability. To the extent possible, the JavaScript code itself
    needs to monitor CPU usage and scale back any more ambitious processing when
    run on less powerful devices. If it's an "all or nothing" type of processing,
    then user-agent check or pre-flighting should be done to avoid generating an
    audio stream with audio breakup. </p>
  </section>
</section>

<section>
<h3 id="JavaScriptPerformance">JavaScript Issues with real-time Processing and Synthesis: </h3>
While processing audio in JavaScript, it is extremely challenging to get
reliable, glitch-free audio while achieving a reasonably low-latency,
especially under heavy processor load. 
<ul>
  <li>JavaScript is very much slower than heavily optimized C++ code and is not
    able to take advantage of SSE optimizations and multi-threading which is
    critical for getting good performance on today's processors. Optimized
    native code can be on the order of twenty times faster for processing FFTs
    as compared with JavaScript. It is not efficient enough for heavy-duty
    processing of audio such as convolution and 3D spatialization of large
    numbers of audio sources. </li>
  <li>setInterval() and XHR handling will steal time from the audio processing.
    In a reasonably complex game, some JavaScript resources will be needed for
    game physics and graphics. This creates challenges because audio rendering
    is deadline driven (to avoid glitches and get low enough latency).</li>
  <li>JavaScript does not run in a real-time processing thread and thus can be
    pre-empted by many other threads running on the system.</li>
  <li>Garbage Collection (and autorelease pools on Mac OS X) can cause
    unpredictable delay on a JavaScript thread. </li>
  <li>Multiple JavaScript contexts can be running on the main thread, stealing
    time from the context doing the processing. </li>
  <li>Other code (other than JavaScript) such as page rendering runs on the
    main thread. </li>
  <li>Locks can be taken and memory is allocated on the JavaScript thread. This
    can cause additional thread preemption. </li>
</ul>
The problems are even more difficult with today's generation of mobile devices
which have processors with relatively poor performance and power consumption /
battery-life issues.
</section>
</section>


<section>
<h2 id="ExampleApplications" class="informative">Example Applications</h2>

<p>Please see the <a
href="http://chromium.googlecode.com/svn/trunk/samples/audio/index.html">demo</a>
page for working examples. </p>

<p>Here are some of the types of applications a web audio system should be able
to support: </p>

<section>
  <h3 id="basic-sound-playback">Basic Sound Playback</h3>
  
  <p>Simple and <a href="#latency"><strong>low-latency</strong></a>
  playback of sound effects in response to simple user actions such as mouse
  click, roll-over, key press. </p>
</section>


<section>
  <h3 id="threeD-environmentse-and-games">3D Environments and Games</h3>
  <figure>
    <img alt="videogame" src="http://payload48.cargocollective.com/1/2/66805/3278334/redteam_680.jpg" />
    <figcaption>A screenshot of a video game</figcaption>
  </figure>


<p>Electronic Arts has produced an impressive immersive game called
 <a href="http://sophie-lu.com/Strike-Fortress-EA">Strike Fortress</a>,
taking advantage of 3D spatialization and convolution for room simulation.</p>

<figure>
  <img alt="beach demo" src="images/beach-demo.png" />
  <figcaption>A screeshot of a graphic demo</figcaption>
</figure>

<p>3D environments with audio are common in games made for desktop applications
and game consoles. Imagine a 3D island environment with spatialized audio,
seagulls flying overhead, the waves crashing against the shore, the crackling
of the fire, the creaking of the bridge, and the rustling of the trees in the
wind. The sounds can be positioned naturally as one moves through the scene.
Even going underwater, low-pass filters can be tweaked for just the right
underwater sound. </p>
<figure>
  <img alt="box2d" src="images/box2d.png" />
  <figcaption>A screenshot of a demo of the box2d physics engine</figcaption>
</figure>
<figure>
  <img alt="8-ball" src="images/8-ball.png" />
  <figcaption>A screenshot of a pool video game</figcaption>
</figure>


<p><a href="http://box2d.org/">Box2D</a> is an interesting open-source
library for 2D game physics. It has various implementations, including one
based on Canvas 2D. A demo has been created with dynamic sound effects for each
of the object collisions, taking into account the velocities vectors and
positions to spatialize the sound events, and modulate audio effect parameters
such as filter cutoff. </p>

<p>A virtual pool game with multi-sampled sound effects has also been created.
</p>
</section>


<section>
  <h3 id="musical-applications">Musical Applications</h3>
  <figure>
    <img alt="garageband" src="images/garage-band.png" />
    <figcaption>A screenshot of a Digital Audio Workstation</figcaption>
  </figure>
  <figure>
    <img alt="shiny drum machine" src="images/shiny-drum-machine.png" /> 
    <figcaption>A screenshot of a drum machine</figcaption>
  </figure>
  <figure>
    <img alt="tonecraft" src="images/tonecraft.png" />
    <figcaption>A screenshot of a WebAudio demo</figcaption>
  </figure>
  Many music composition and production applications are possible. Applications
  requiring tight scheduling of audio events can be implemented and can be both
  educational and entertaining. Drum machines, digital DJ applications, and even
  timeline-based digital music production software with some of the features of
  <a href="http://en.wikipedia.org/wiki/GarageBand">GarageBand</a> can be
  written.
</section>


<section>
  <h3 id="music-visualizers">Music Visualizers</h3>
  <figure>
    <img alt="music visualizer" src="images/music-visualizer.png" />
    <figcaption>A screenshot of a music visualizer</figcaption>
  </figure>
  When combined with WebGL GLSL shaders, realtime analysis data can be presented
  in entertaining ways. These can be as advanced as any found in iTunes.
</section>


<section>
  <h3 id="educational-applications_2">Educational Applications</h3>
  <figure>
    <img alt="javascript processing" src="images/javascript-processing.png" />
    <figcaption>A screenshot of a frequency visualizer written in Javascript</figcaption>
  </figure>
  
  <p>A variety of educational applications can be written, illustrating concepts
  in music theory and computer music synthesis and processing. </p>
</section>


<section>
  <h3 id="artistic-audio-exploration">Artistic Audio Exploration</h3>
  
  <p>There are many creative possibilites for artistic sonic environments for
  installation pieces. </p>
</section>
</section>

<section class="informative">
  <h2 id="SecurityConsiderations">Security Considerations</h2>
</section>

<section class="informative">
  <h2 id="PrivacyConsiderations">Privacy Considerations</h2>
  
  <p>When giving various information on
  available <a>AudioNode</a>s, the Web Audio API potentially exposes information on
  characteristic features of the client (such as audio hardware sample-rate) to
  any page that makes use of the <a>AudioNode</a> interface. Additionally, timing
  information can be collected through the RealtimeAnalyzerNode or
  <a>ScriptProcessorNode</a> interface. The information could subsequently be used to
  create a fingerprint of the client. </p>
  
  <p>Currently audio input is not specified in this document, but it will involve
  gaining access to the client machine's audio input or microphone. This will
  require asking the user for permission in an appropriate way, probably via the
  <a href="http://developers.whatwg.org/">getUserMedia()
  API</a>. </p>
</section>

<section>
  <h2 id="requirements">Requirements and Use Cases</h2>
  
  <p>Please see <a href="#ExampleApplications">Example Applications</a>
  </p>
</section>

</section>

<section>
<h2>Acknowledgements</h2>
<p>This specification is the collective work of the W3C <a href="http://www.w3.org/2011/audio/">Audio Working Group</a>.</p>

<p>Members of the Working Group are (at the time of writing, and by alphabetical order): <br />
Adenot, Paul (Mozilla Foundation);
Akhgari, Ehsan (Mozilla Foundation);
Berkovitz, Joe (Invited Expert);
Bossart, Pierre (Intel Corporation);
Carlson, Eric (Apple, Inc.);
Geelnard, Marcus (Opera Software);
Goode, Adam (Google, Inc.);
Gregan, Matthew (Mozilla Foundation);
Jägenstedt, Philip (Opera Software);
Kalliokoski, Jussi (Invited Expert);
Lilley, Chris (W3C Staff);
Lowis, Chris (Invited Expert. WG co-chair from December 2012 to September 2013, affiliated with British Broadcasting Corporation);
Mandyam, Giridhar (Qualcomm Innovation Center, Inc);
Noble, Jer (Apple, Inc.);
O'Callahan, Robert(Mozilla Foundation);
Onumonu, Anthony (British Broadcasting Corporation);
Paradis, Matthew (British Broadcasting Corporation);
Raman, T.V. (Google, Inc.);
Schepers, Doug (W3C/MIT);
Shires, Glen (Google, Inc.);
Smith, Michael (W3C/Keio);
Thereaux, Olivier (British Broadcasting Corporation) – WG Chair;
Verdie, Jean-Charles (MStar Semiconductor, Inc.);
Wilson, Chris (Google,Inc.);
ZERGAOUI, Mohamed (INNOVIMAX)
</p>

<p>Former members of the Working Group and contributors to the specification include:<br />
Caceres, Marcos (Invited Expert);
Cardoso, Gabriel (INRIA);
Chen, Bin (Baidu, Inc.);
MacDonald, Alistair (W3C Invited Experts) — WG co-chair from March 2011 to July 2012;
Michel, Thierry (W3C/ERCIM);
Rogers, Chris (Google, Inc.) – Specification Editor until August 2013;
Wei, James (Intel Corporation);
</p>

</section>

<section>
<h2 id="ChangeLog">Web Audio API Change Log</h2>
<p>See <a href="changelog.html">changelog.html</a>.</p>
</section>
</body>
</html>
