<!DOCTYPE html>
<html>
<head>
  <title>Web Audio API</title>
  <meta charset=utf-8>
  <script src='respec-w3c-common' async class='remove'></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=MML_HTMLorMML"></script>
  <script class='remove'>
    var respecConfig = {
        specStatus: "ED",
        shortName:  "webaudio",
        edDraftURI: "http://webaudio.github.io/web-audio-api/",
        editors: [
              {   name:       "Paul Adenot",
                  company:    "Mozilla",
                  companyURL: "http://mozilla.org/",
                  mailto:     "padenot@mozilla.com" },
              {
                  name:       "Chris Wilson",
                  company:    "Google, Inc.",
                  companyURL: "http://google.com",
                  mailto:     "cwilso@google.com" },
        ],
        previousMaturity: "WD",
        previousPublishDate:  "2012-12-13",
        previousURI:  "http://www.w3.org/TR/2012/WD-webaudio-20121213/",
        wg:           "Audio Working Group",
        wgURI:        "http://www.w3.org/2011/audio/",
        wgPublicList: "public-audio",
        wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
        tocIntroductory: true,
        copyrightStart: 2013,
        otherLinks: [
          {
            key: "Previous editor",
            data : [{value: "Chris Rogers (Until August 2013)"}] },
          {
            key: "Repository",
            href: "https://github.com/WebAudio/web-audio-api" },
          {
            key: "Bug tracker",
            href: "https://github.com/WebAudio/web-audio-api/issues?state=open" },
        ]
    };
  </script>
  <script>
    function findBadLink () {
      var old = document.querySelectorAll(".badLink");
      for (var i = 0 ; i < old.length; i++) {
        nodes[i].style.backgroundColor = "";
        nodes[i].classList.remove("badLink");
      }
      var nodes = document.querySelectorAll('a');

      for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].href) {
              var id =  nodes[i].href.split("/");
              id = id[id.length - 1];
              if (id.length != 0) {
                  if (id[0] == "#") {
                      if (document.querySelectorAll(id).length == 0) {
                        nodes[i].style.backgroundColor = "red";
                        nodes[i].classList.add("badLink");
                        console.log(nodes[i].textContent);
                    }
                 }
              }
          } else {
            nodes[i].style.backgroundColor = "red";
            nodes[i].classList.add("badLink");
          }
      }
    }

    function findMissingLink() {
      var codetags = document.querySelectorAll("code");

      for (var i = 0; i < codetags.length; i++) {
        if (!(codetags[i].parentNode instanceof HTMLAnchorElement) ||
            codetags[i].parentNode.href == "") {
          codetags[i].style.backgroundColor = 'hotpink';
          codetags[i].style.color  = 'yellow';

          console.log(codetags[i].innerHTML);
        }
      }
    }
  </script>
</head>

<body>

<section id="abstract">
<p>This specification describes a high-level JavaScript <abbr
title="Application Programming Interface">API</abbr> for processing and
synthesizing audio in web applications. The primary paradigm is of an audio
routing graph, where a number of <a><code>AudioNode</code></a> objects are connected
together to define the overall audio rendering. The actual processing will
primarily take place in the underlying implementation (typically optimized
Assembly / C / C++ code), but <a href="#JavaScriptProcessing">direct
JavaScript processing and synthesis</a> is also supported. </p>

<p>The <a href="#introduction">introductory</a> section covers the motivation
behind this specification.</p>

<p>This API is designed to be used in conjunction with other APIs and elements
on the web platform, notably: XMLHttpRequest [[XHR]]
(using the <code>responseType</code> and <code>response</code> attributes). For
games and interactive applications, it is anticipated to be used with the
<code>canvas</code> 2D [[2dcontext]] and WebGL [[WEBGL]] 3D graphics APIs. </p>
</section>

<section id="sotd">
</section>

<section class="introductory">
<h2>Introduction</h2>
<section>

<p>Audio on the web has been fairly primitive up to this point and until very
recently has had to be delivered through plugins such as Flash and QuickTime.
The introduction of the <code>audio</code> element in HTML5 is very important,
allowing for basic streaming audio playback. But, it is not powerful enough to
handle more complex audio applications. For sophisticated web-based games or
interactive applications, another solution is required. It is a goal of this
specification to include the capabilities found in modern game audio engines as
well as some of the mixing, processing, and filtering tasks that are found in
modern desktop audio production applications. </p>

<p>The APIs have been designed with a wide variety of use cases in mind. Ideally, it should
be able to support <i>any</i> use case which could reasonably be implemented
with an optimized C++ engine controlled via JavaScript and run in a browser.
That said, modern desktop audio software can have very advanced capabilities,
some of which would be difficult or impossible to build with this system.
Apple's Logic Audio is one such application which has support for external MIDI
controllers, arbitrary plugin audio effects and synthesizers, highly optimized
direct-to-disk audio file reading/writing, tightly integrated time-stretching,
and so on. Nevertheless, the proposed system will be quite capable of
supporting a large range of reasonably complex games and interactive
applications, including musical ones. And it can be a very good complement to
the more advanced graphics features offered by WebGL. The API has been designed
so that more advanced capabilities can be added at a later time. </p>
</section>

<section>
<h2 id="Features">Features</h2>

<p>The API supports these primary features: </p>
<ul>
  <li><a href="#ModularRouting">Modular routing</a> for simple or
    complex mixing/effect architectures, including <a
    href="#mixer-gain-structure">multiple sends and submixes</a>.</li>
  <li><a href="#AudioParam">Sample-accurate scheduled sound
    playback</a> with low <a href="#latency">latency</a> for musical
    applications requiring a very high degree of rhythmic precision such as
    drum machines and sequencers. This also includes the possibility of <a
    href="#DynamicLifetime">dynamic creation</a> of effects. </li>
  <li>Automation of audio parameters for envelopes, fade-ins / fade-outs,
    granular effects, filter sweeps, LFOs etc. </li>
  <li>Flexible handling of channels in an audio stream, allowing them to be split and merged.</li>

  <li>Processing of audio sources from an <code>audio</code> or
    <code>video</code> <a href="#MediaElementAudioSourceNode">media
    element</a>. </li>

    <li>Processing live audio input using a <a href="#MediaStreamAudioSourceNode">MediaStream</a>
    from getUserMedia().
     </li>

     <li>Integration with WebRTC
  <ul>


   <li>Processing audio received from a remote peer using a
   <a><code>MediaStreamAudioSourceNode</code></a> and [[!webrtc]].
    </li>

  <li>Sending a generated or processed audio stream to a remote peer using a
  <a><code>MediaStreamAudioDestinationNode</code></a> and [[!webrtc]].
     </li>

     </ul>
     </li>

  <li>Audio stream synthesis and processing <a
    href="#JavaScriptProcessing">directly in JavaScript</a>. </li>
  <li><a href="#Spatialization">Spatialized audio</a> supporting a wide
    range of 3D games and immersive environments:
    <ul>
      <li>Panning models: equal-power, HRTF, pass-through </li>
      <li>Distance Attenuation </li>
      <li>Sound Cones </li>
      <li>Obstruction / Occlusion </li>
      <li>Doppler Shift </li>
      <li>Source / Listener based</li>
    </ul>
  </li>
  <li>A <a href="#Convolution">convolution engine</a> for a wide range
    of linear effects, especially very high-quality room effects. Here are some
    examples of possible effects:
    <ul>
      <li>Small / large room </li>
      <li>Cathedral </li>
      <li>Concert hall </li>
      <li>Cave </li>
      <li>Tunnel </li>
      <li>Hallway </li>
      <li>Forest </li>
      <li>Amphitheater </li>
      <li>Sound of a distant room through a doorway </li>
      <li>Extreme filters</li>
      <li>Strange backwards effects</li>
      <li>Extreme comb filter effects </li>
    </ul>
  </li>
  <li>Dynamics compression for overall control and sweetening of the mix </li>
  <li>Efficient <a href="#the-analysernode-interface">real-time time-domain and
    frequency analysis / music visualizer support</a></li>
  <li>Efficient biquad filters for lowpass, highpass, and other common filters.
  </li>
  <li>A Waveshaping effect for distortion and other non-linear effects</li>
  <li>Oscillators</li>

</ul>

<section>
<h2 id="ModularRouting">Modular Routing</h2>

<p>Modular routing allows arbitrary connections between different
<a><code>AudioNode</code></a>
objects. Each node can
have <dfn>inputs</dfn> and/or <dfn>outputs</dfn>. A <dfn>source node</dfn> has no inputs
and a single output. A <dfn>destination node</dfn>  has
one input and no outputs, the most common example being <a
href="#AudioDestinationNode"><code>AudioDestinationNode</code></a> the final destination to the audio
hardware. Other nodes such as filters can be placed between the source and destination nodes.
The developer doesn't have to worry about low-level stream format details
when two objects are connected together; <a href="#channel-up-mixing-and-down-mixing">the right
thing just happens</a>. For example, if a mono audio stream is connected to a
stereo input it should just mix to left and right channels <a
href="#channel-up-mixing-and-down-mixing">appropriately</a>. </p>

<p>In the simplest case, a single source can be routed directly to the output.
All routing occurs within an <a
href="#AudioContext"><code>AudioContext</code></a> containing a single
<a href="#AudioDestinationNode"><code>AudioDestinationNode</code></a>:
</p>
<figure>
  <img alt="modular routing" src="images/modular-routing1.png">
  <figcaption>A simple example of modular routing.</figcaption>
</figure>

<p>Illustrating this simple routing, here's a simple example playing a single
sound: </p>

<pre class="highlight example">

var context = new AudioContext();

function playSound() {
    var source = context.createBufferSource();
    source.buffer = dogBarkingBuffer;
    source.connect(context.destination);
    source.start(0);
}
</pre>

<p>Here's a more complex example with three sources and a convolution reverb
send with a dynamics compressor at the final output stage: </p>
<figure>
  <img alt="modular routing2" src="images/modular-routing2.png" />
  <figcaption>A more complex example of modular rounting.</figcaption>
</figure>

<pre class="highlight example">

var context = 0;
var compressor = 0;
var reverb = 0;

var source1 = 0;
var source2 = 0;
var source3 = 0;

var lowpassFilter = 0;
var waveShaper = 0;
var panner = 0;

var dry1 = 0;
var dry2 = 0;
var dry3 = 0;

var wet1 = 0;
var wet2 = 0;
var wet3 = 0;

var masterDry = 0;
var masterWet = 0;

function setupRoutingGraph () {
    context = new AudioContext();

    // Create the effects nodes.
    lowpassFilter = context.createBiquadFilter();
    waveShaper = context.createWaveShaper();
    panner = context.createPanner();
    compressor = context.createDynamicsCompressor();
    reverb = context.createConvolver();

    // Create master wet and dry.
    masterDry = context.createGain();
    masterWet = context.createGain();

    // Connect final compressor to final destination.
    compressor.connect(context.destination);

    // Connect master dry and wet to compressor.
    masterDry.connect(compressor);
    masterWet.connect(compressor);

    // Connect reverb to master wet.
    reverb.connect(masterWet);

    // Create a few sources.
    source1 = context.createBufferSource();
    source2 = context.createBufferSource();
    source3 = context.createOscillator();

    source1.buffer = manTalkingBuffer;
    source2.buffer = footstepsBuffer;
    source3.frequency.value = 440;

    // Connect source1
    dry1 = context.createGain();
    wet1 = context.createGain();
    source1.connect(lowpassFilter);
    lowpassFilter.connect(dry1);
    lowpassFilter.connect(wet1);
    dry1.connect(masterDry);
    wet1.connect(reverb);

    // Connect source2
    dry2 = context.createGain();
    wet2 = context.createGain();
    source2.connect(waveShaper);
    waveShaper.connect(dry2);
    waveShaper.connect(wet2);
    dry2.connect(masterDry);
    wet2.connect(reverb);

    // Connect source3
    dry3 = context.createGain();
    wet3 = context.createGain();
    source3.connect(panner);
    panner.connect(dry3);
    panner.connect(wet3);
    dry3.connect(masterDry);
    wet3.connect(reverb);

    // Start the sources now.
    source1.start(0);
    source2.start(0);
    source3.start(0);
}
</pre>
</section>
</section>

<section>
<h2 id="APIOverview">API Overview</h2>

<p>The interfaces defined are: </p>
<ul>
  <li>An <a class="dfnref" href="#AudioContext">AudioContext</a>
    interface, which contains an audio signal graph representing connections
    betweens <a><code>AudioNode</code></a>s. </li>
  <li>An <a><code>AudioNode</code></a> interface,
    which represents audio sources, audio outputs, and intermediate processing
    modules. <a><code>AudioNode</code></a>s can be dynamically connected together in a <a
    href="#ModularRouting">modular fashion</a>. <a><code>AudioNode</code></a>s
    exist in the context of an <a><code>AudioContext</code></a> </li>
  <li>An <a><code>AudioDestinationNode</code></a> interface, an
    <a><code>AudioNode</code></a> subclass representing the final destination for all rendered
    audio. </li>
  <li>An <a><code>AudioBuffer</code></a>
    interface, for working with memory-resident audio assets. These can
    represent one-shot sounds, or longer audio clips. </li>
  <li>An <a><code>AudioBufferSourceNode</code></a> interface,
    an <a><code>AudioNode</code></a> which generates audio from an AudioBuffer. </li>
  <li>A <a><code>MediaElementAudioSourceNode</code></a>
    interface, an <a><code>AudioNode</code></a> which is the audio source from an
    <code>audio</code>, <code>video</code>, or other media element. </li>
  <li>A <a><code>MediaStreamAudioSourceNode</code></a>
    interface, an <a><code>AudioNode</code></a> which is the audio source from a
    MediaStream such as live audio input, or from a remote peer. </li>
  <li>A <a><code>MediaStreamAudioDestinationNode</code></a>
    interface, an <a><code>AudioNode</code></a> which is the audio destination to a
    MediaStream sent to a remote peer. </li>
  <li>An <a><code>AudioWorker</code></a> interface, a
    <a><code>WebWorker</code></a> designed to enable processing audio directly in JavaScript in a Worker.</li>
  <li>An <a><code>AudioWorkerNode</code></a> interface, an
    <a><code>AudioNode</code></a> for connecting the node graph to an AudioWorker. </li>
  <li>A <a><code>ScriptProcessorNode</code></a> interface, an
    <a><code>AudioNode</code></a> for generating or processing audio directly in JavaScript. </li>
  <li>An <a><code>AudioProcessingEvent</code></a> interface,
    which is an event type used with <a><code>ScriptProcessorNode</code></a> objects.
  </li>
  <li>An <a><code>AudioParam</code></a> interface,
    for controlling an individual aspect of an <a><code>AudioNode</code></a>'s functioning, such as
    volume. </li>
  <li>An <a><code>GainNode</code></a>
    interface, for explicit gain control. Because inputs to
    <a><code>AudioNode</code></a>s support
    multiple connections (as a unity-gain summing junction), mixers can be <a
    href="#mixer-gain-structure">easily built</a> with GainNodes.
  </li>
  <li>A <a><code>BiquadFilterNode</code></a>
    interface, an <a><code>AudioNode</code></a> for common low-order filters such as:
    <ul>
      <li>Low Pass</li>
      <li>High Pass </li>
      <li>Band Pass </li>
      <li>Low Shelf </li>
      <li>High Shelf </li>
      <li>Peaking </li>
      <li>Notch </li>
      <li>Allpass </li>
    </ul>
  </li>
  <li>A <a><code>DelayNode</code></a> interface, an
    <a><code>AudioNode</code></a> which applies a dynamically adjustable variable delay. </li>
  <li>An <a><code>PannerNode</code></a>
    interface, for spatializing / positioning audio in 3D space. </li>
  <li>An <a><code>AudioListener</code></a>
    interface, which works with a <a>PannerNode</a> for
    spatialization. </li>
  <li>A <a><code>ConvolverNode</code></a>
      interface, an <a><code>AudioNode</code></a> for applying a <a
        href="#Convolution">real-time linear effect</a> (such as the sound
    of a concert hall). </li>
  <li>A <a><code>AnalyserNode</code></a> interface,
    for use with music visualizers, or other visualization applications. </li>
  <li>A <a><code>ChannelSplitterNode</code></a> interface,
    for accessing the individual channels of an audio stream in the routing
    graph. </li>
  <li>A <a><code>ChannelMergerNode</code></a> interface, for
    combining channels from multiple audio streams into a single audio stream.
  </li>
  <li>A <a><code>DynamicsCompressorNode</code></a> interface, an
    <a><code>AudioNode</code></a> for dynamics compression. </li>
  <li>A <a><code>WaveShaperNode</code></a>
    interface, an <a><code>AudioNode</code></a> which applies a non-linear waveshaping effect for
    distortion and other more subtle warming effects. </li>
  <li>A <a><code>OscillatorNode</code></a>
    interface, an audio source generating a periodic waveform. </li>
</ul>
</section>
</section>

<section id="conformance">
<p>The following conformance classes are defined by this specification: </p>
<dl>
  <dt><dfn id="dfn-conforming-implementation">conforming
  implementation</dfn></dt>
    <dd><p>A user agent is considered to be a <a class="dfnref"
      href="#dfn-conforming-implementation">conforming implementation</a> if it
      satisfies all of the MUST-, REQUIRED- and SHALL-level criteria in this specification that
      apply to implementations. </p>
    </dd>
</dl>
<p>
  User agents that use ECMAScript to implement the APIs defined in this
  specification must implement them in a manner consistent with the ECMAScript
  Bindings defined in the Web IDL specification [[!WEBIDL]] as this
  specification uses that specification and terminology.
</p>
</section>

<section id=audioapi>
<h2 id="API">The Audio API</h2>

<section>
<h2 id="AudioContext">The AudioContext Interface</h2>

<p>This interface represents a set of <a><code>AudioNode</code></a> objects and their
connections. It allows for arbitrary routing of signals to the
<a><code>AudioDestinationNode</code></a>
(what the user ultimately hears). Nodes are created from the context and are
then <a href="#ModularRouting">connected</a> together. In most use
cases, only a single <a><code>AudioContext</code></a> is used per document.</p>

<dl title="enum AudioContextState" class="idl">
  <dt>suspended</dt>
  <dd>The AudioContext is currently suspended (context time is not proceeding, audio hardware may be powered down/released).</dd>
  <dt>running</dt>
  <dd>Audio is being processed.</dd>
  <dt>closed</dt>
  <dd>The AudioContext has been released, and can no longer be used to process audio.  All system audio resources have been released.  Attempts to create new Nodes on the AudioContext will throw InvalidStateError.  (AudioBuffers may still be created, through <a>createBuffer</a> or <a>decodeAudioData</a>.)</dd>
</dl>

<dl title="[Constructor] interface AudioContext : EventTarget" class="idl"
  data-merge="DecodeSuccessCallback DecodeErrorCallback">
  <dt>readonly attribute AudioDestinationNode destination</dt>
  <dd><p>An <a
    href="#AudioDestinationNode"><code>AudioDestinationNode</code></a>
    with a single input representing the final destination for all audio.
    Usually this will represent the actual audio hardware.
    All <a><code>AudioNode</code></a>s actively rendering
    audio will directly or indirectly connect to <a
      href="#widl-AudioContext-destination"><code>destination</code></a>.</p>
  </dd>
  <dt> readonly attribute float sampleRate</dt>
  <dd><p>The sample rate (in sample-frames per second) at which the
    <a><code>AudioContext</code></a> handles audio. It is assumed that all <a><code>AudioNode</code></a>s in the
    context run at this rate. In making this assumption, sample-rate
    converters or "varispeed" processors are not supported in real-time
    processing.</p>
  </dd>
  <dt> readonly attribute double currentTime</dt>
  <dd><p>This is a time in seconds which starts at zero when the context is
    created and increases in real-time. All scheduled times are relative to
    it. This is not a "transport" time which can be started, paused, and
    re-positioned. It is always moving forward. A GarageBand-like timeline
    transport system can be very easily built on top of this (in JavaScript).
    This time corresponds to an ever-increasing hardware timestamp. </p>
  </dd>
  <dt> readonly attribute AudioListener listener </dt>
  <dd><p>An <a href="#AudioListener"><code>AudioListener</code></a>
    which is used for 3D <a
    href="#Spatialization">spatialization</a>.</p>
  </dd>

  <dt>readonly attribute AudioContextState state</dt>
  <dd>Describes the current state of the AudioContext.  The context state MUST begin in "suspended", and transitions to "running" when system resources are acquired and audio has begun processing.  For OfflineAudioContexts, the state will remain in "suspended" until startRendering()</code> is called, at which point it will transition to "running", and then to "closed" once audio processing has completed and oncomplete has been fired.
    <p>When the state is "suspended", a call to <code>resume()</code> will cause a transition to "running", or a call to <code>close()</code> will cause a transition to "closed".</p>
    <p>When the state is "running", a call to <code>suspend()</code> will cause a transition to "suspended", or a call to <code>close()</code> will cause a transition to "closed".</p>
    <p>When the state is "closed", no further state transitions are possible.</p>
  </dd>

  <dt>Promise suspend()</dt>
  <dd>Suspends the progression of time in the audio context, allows any current context processing blocks that are already processed to be played to the destination, and then allows the system to release its claim on audio hardware.  This is generally useful when the application knows it will not need the AudioContext for some time, and wishes to let the audio hardware power down.  The promise resolves when the frame buffer is empty (has been handed off to the hardware), or immediately (with no other effect) if the context is already suspended.  The promise is rejected if the context has been closed.  This method will cause an INVALID_STATE_ERR exception to be thrown if called on an OfflineAudioContext.

    <p>While the system is suspended, MediaStreams will have their output ignored; that is, data will be lost by the real time nature of media streams.  HTMLMediaElements will similarly have their output ignored until the system is resumed.  Audio Workers and ScriptProcessorNodes will simply not fire their onaudioprocess events while suspended, but will resume when resumed.  For the purpose of AnalyserNode window functions, the data is considered as a continuous stream - i.e. the resume()/suspend() does not cause silence to appear in the AnalyserNode's stream of data.</p></dd>

  <dt>Promise resume()</dt>
  <dd>Resumes the progression of time in an audio context that has been suspended, which may involve re-priming the frame buffer contents.  The promise resolves when the system has re-acquired (if necessary) access to audio hardware and has begun streaming to the destination, or immediately (with no other effect) if the context is already running.  The promise is rejected if the context has been closed.  If the context is not currently suspended, the promise will resolve.  This method will cause an INVALID_STATE_ERR exception to be thrown if called on an OfflineAudioContext.</dd>

  <dt>Promise close()</dt>
  <dd>Closes the audio context, releasing any system audio resources used by the <a>AudioContext</a>.  This will not automatically release all AudioContext-created objects, unless other references have been released as well; however, it will forcibly release any system audio resources that might prevent additional AudioContexts from being created and used, suspend the progression of audio time in the audio context, and stop processing audio data.  The promise resolves when all AudioContext-creation-blocking resources have been released.  This method will cause an INVALID_STATE_ERR exception to be thrown if called on an OfflineAudioContext.</dd>

 <dt>attribute EventHandler onstatechange</dt>
  <dd>
    A property used to set the <code>EventHandler</code> for an event that is dispatched to
    <a><code>AudioContext</code></a> when the state of the AudioContext has changed (i.e. when the
    corresponding promise would have resolved). An event of type <a><code>Event</code></a> will be 
    dispatched to the event handler, which can query the AudioContext's state directly.  A 
    newly-created AudioContext will always begin in the "paused" state, and a state change event will be fired 
    when it transitions to "running".
  </dd>

  <dt>AudioBuffer createBuffer()</dt>
  <dd> Creates an AudioBuffer of the given size. The audio data in the buffer will
  be zero-initialized (silent).  An NOT_SUPPORTED_ERR exception MUST be thrown
  if any of the arguments is negative, zero, or outside its nominal range.
  <dl class="parameters">
      <dt>unsigned long numberOfChannels</dt>
      <dd> Determines how many channels the buffer will have. An implementation
      must support at least 32 channels.</dd>
      <dt>unsigned long length</dt>
      <dd>Determines the size of the buffer in sample-frames.</dd>
      <dt>float sampleRate</dt>
      <dd>Describes the sample-rate of the linear PCM audio data in the buffer in
      sample-frames per second.  An implementation must support sample-rates in
      at least the range 22050 to 96000.</dd>
  </dl>
  </dd>

    <dt> Promise&lt;AudioBuffer&gt; decodeAudioData() </dt>
    <dd>
      Asynchronously decodes the audio file data contained in the ArrayBuffer.
    The ArrayBuffer can, for example, be loaded from an XMLHttpRequest's
    <code>response</code> attribute after setting the <code>responseType</code>
    to "arraybuffer".  Audio file data can be in any of the formats supported by
    the <code>audio</code> element.
    <dl class=parameters>
      <dt> ArrayBuffer audioData </dt>
      <dd> An ArrayBuffer containing compressed audio data </dd>
      <dt> optional DecodeSuccessCallback successCallback </dt>
      <dd>
        A callback function which will be invoked when the decoding is finished.
        The single argument to this callback is an AudioBuffer representing the
        decoded PCM audio data.
      </dd>
      <dt> optional DecodeErrorCallback errorCallback </dt>
      <dd>
        A callback function which will be invoked if there is an error
        decoding the audio file.
      </dd>

    </dl>
      <p>
      Although the primary method of interfacing with this function is via its promise return value, the callback
      parameters are provided for legacy reasons.
      </p>
      <p>
      The following steps must be performed:
      </p>
      <ol>
      <li>Let <var>promise</var> be a new promise.</li>
      <li>If <a>audioData</a> is null or not a valid ArrayBuffer:
        <ol>
          <li>Let <var>error</var> be a <code>DOMException</code> whose name is <code>NotSupportedError</code>.</li>
          <li>Reject <var>promise</var> with <var>error</var>.</li>
          <li>If <dfn>errorCallback</dfn> is not missing, invoke <dfn>errorCallback</dfn> with <var>error</var>.</li>
          <li>Terminate this algorithm.
        </ol>
      <li> Neuter the <a>audioData</a> ArrayBuffer in such a way that JavaScript code may not
      access or modify the data anymore.</li>
      <li>Queue a decoding operation to be performed on another thread.</li>
      <li>Return <var>promise</var>.</li>
      <li>In the decoding thread:
        <ol>
        <li>Attempt to decode the encoded <a>audioData</a> into linear PCM.</li>
        <li>If a decoding error is encountered due to the audio format not being recognized or supported, or because
        of corrupted/unexpected/inconsistent data, then, on the main thread's event loop:
          <ol>
          <li>Let <var>error</var> be a <code>DOMException</code> whose name is <code>"EncodingError"</code>.</li>
          <li>Reject <var>promise</var> with <var>error</var>.</li>
          <li>If <dfn>errorCallback</dfn> is not missing, invoke <a>errorCallback</a> with <var>error</var>.</li>
        </ol>
        <li>Otherwise:
          <ol>
          <li>Take the result, representing the decoded linear PCM audio data, and resample it to the sample-rate of
          the <a><code>AudioContext</code></a> if it is different from the sample-rate of <a>audioData</a>.</li>
          <li>On the main thread's event loop:
            <ol>
            <li>Let <var>buffer</var> be an <code>AudioBuffer</code> containing the final result (after possibly
            sample-rate converting).</li>
            <li>Resolve <var>promise</var> with <var>buffer</var>.</li>
            <li>If <dfn>successCallback</dfn> is not missing, invoke <a>successCallback</a> with <var>buffer</var>.
            </li>
            </ol>
          </li>
          </ol>
        </li>
        </ol>
      </li>
      </ol>
    </dd>


    <dt> AudioBufferSourceNode createBufferSource() </dt>
    <dd>Creates an <a><code>AudioBufferSourceNode</code></a>.
    </dd>

    <dt>MediaElementAudioSourceNode createMediaElementSource()</dt>
    <dd>
    Creates a <a href="#MediaElementAudioSourceNode">MediaElementAudioSourceNode</a>
    given an HTMLMediaElement.  As a consequence of calling this method, audio
    playback from the HTMLMediaElement will be re-routed into the processing graph
    of the <a><code>AudioContext</code></a>.
      <dl class=parameters>
        <dt> HTMLMediaElement mediaElement </dt>
        <dd> The media element that will be re-routed. </dd>
      </dl>
    </dd>

    <dt> MediaStreamAudioSourceNode createMediaStreamSource() </dt>
    <dd>
    <dl class=parameters>
      <dt>MediaStream mediaStream</dt>
      <dd> The media stream that will act as source. </dd>
    </dl>
    </dd>

    <dt> MediaStreamAudioDestinationNode createMediaStreamDestination() </dt>
    <dd>Creates a <a><code>MediaStreamAudioDestinationNode</code></a> </dd>

    <dt> AudioWorkerNode createAudioWorker()</dt>
    <dd>
      Creates an <a><code>AudioWorkerNode</code></a> and its associated <a><code>AudioWorkerGlobalScope</code></a> 
      for direct audio processing using JavaScript.  An INDEX_SIZE_ERR exception MUST 
      be thrown if <a><code>numberOfInputChannels</code></a> or
      <a><code>numberOfOutputChannels</code></a> are outside the valid range.

      <dl class=parameters>
        <dt> DOMString scriptURL </dt>
        <dd>
          This parameter represents the URL of the script to be loaded as an <a>AudioWorker</a>.
        </dd>
        <dt> optional unsigned long numberOfInputChannels = 2 </dt>
        <dd>
          This parameter determines the number of channels for this node's
          input. Values of up to 32 must be supported.
        </dd>
        <dt> optional unsigned long numberOfOutputChannels = 2 </dt>
        <dd>
          This parameter determines the number of channels for this node's
          output. Values of up to 32 must be supported.
        </dd>
      </dl>
      It is invalid for both <a><code>numberOfInputChannels</code></a> and
      <a><code>numberOfOutputChannels</code></a> to be zero.
    </dd>

    <dt> ScriptProcessorNode createScriptProcessor()</dt>
    <dd>
      This method is DEPRECATED, as it is intended to be replaced by createAudioWorker.
      Creates a <a><code>ScriptProcessorNode</code></a> for direct audio processing using
      JavaScript.  An INDEX_SIZE_ERR exception MUST be thrown if
      <a><code>bufferSize</code></a> or <a><code>numberOfInputChannels</code></a> or
      <a><code>numberOfOutputChannels</code></a> are outside the valid range.
      <dl class=parameters>
        <dt> optional unsigned long bufferSize = 0 </dt>
        <dd>
          The <a><code>bufferSize</code></a> parameter determines the buffer size in units of
          sample-frames.  If it's not passed in, or if the value is 0, then the
          implementation will choose the best buffer size for the given
          environment, which will be constant power of 2 throughout the lifetime
          of the node. Otherwise if the author explicitly specifies the
          bufferSize, it must be one of the following values: 256, 512, 1024,
          2048, 4096, 8192, 16384. This value controls how frequently the
          <a href="#audioprocess-spnode"><code>audioprocess</code></a> event is
          dispatched and how many sample-frames need to be processed each call.
          Lower values for <a><code>bufferSize</code></a>
          will result in a lower (better) <a href="#latency">latency</a>. Higher
          values will be necessary to avoid audio breakup and
          <a href="#audio-glitching">glitches</a>.
          It is recommended for authors to not specify this buffer size and
          allow the implementation to pick a good buffer size to balance between
          <a href="#latency">latency</a> and audio quality.
          </dd>
        <dt> optional unsigned long numberOfInputChannels = 2 </dt>
        <dd>
          This parameter determines the number of channels for this node's
          input. Values of up to 32 must be supported.
        </dd>
        <dt> optional unsigned long numberOfOutputChannels = 2 </dt>
        <dd>
          This parameter determines the number of channels for this node's
          output. Values of up to 32 must be supported.
        </dd>
      </dl>
      It is invalid for both <a><code>numberOfInputChannels</code></a> and
      <a><code>numberOfOutputChannels</code></a> to be zero.
    </dd>

    <dt> AnalyserNode createAnalyser() </dt>
    <dd>Create an <a><code>AnalyserNode</code></a>.</dd>
    <dt> GainNode createGain() </dt>
    <dd>Create an <a><code>GainNode</code></a>.</dd>
    <dt> DelayNode createDelay() </dt>
    <dd>
        Creates a <a><code>DelayNode</code></a> representing a variable delay line. The
        initial default delay time will be 0 seconds.
      <dl class=parameters>
        <dt> optional double maxDelayTime = 1.0 </dt>
        <dd>
          The <dfn>maxDelayTime</dfn> parameter is optional and specifies the
          maximum delay time in seconds allowed for the delay line.  If
          specified, this value MUST be greater than zero and less than three
          minutes or a NOT_SUPPORTED_ERR exception MUST be thrown.
        </dd>
      </dl>
    </dd>
    <dt> BiquadFilterNode createBiquadFilter() </dt>
    <dd>Creates a <a><code>BiquadFilterNode</code></a>
      representing a second order filter which can be configured as one of
      several common filter types.
    </dd>
    <dt> WaveShaperNode createWaveShaper() </dt>
    <dd>
      Creates a <a><code>WaveShaperNode</code></a> representing a non-linear distortion.
    </dd>
    <dt> PannerNode createPanner() </dt>
    <dd>
      Creates an <a><code>PannerNode</code></a>.
    </dd>
    <dt> ConvolverNode createConvolver() </dt>
    <dd>
      Creates a <a><code>ConvolverNode</code></a>.
    </dd>
    <dt> ChannelSplitterNode createChannelSplitter() </dt>
    <dd>
      Creates an <a><code>ChannelSplitterNode</code></a>
      representing a channel splitter. An INDEX_SIZE_ERR exception MUST be thrown
      for invalid parameter values.
      <dl class=parameters>
        <dt> optional unsigned long numberOfOutputs = 6 </dt>
        <dd>
          The number of outputs.  Values of up to 32 must be supported.  If not
          specified, then 6 will be used.
        </dd>
      </dl>
    </dd>
    <dt> ChannelMergerNode createChannelMerger() </dt>
    <dd>
      Creates a <a><code>ChannelMergerNode</code></a> representing a channel merger.  An
      INDEX_SIZE_ERR exception MUST be thrown for invalid parameter values.
      <dl class=parameters>
        <dt> optional unsigned long numberOfInputs = 6 </dt>
        <dd>
          The <dfn>numberOfInputs</dfn> parameter determines the number of inputs.
          Values of up to 32 must be supported.  If not specified, then 6 will be
          used.
        </dd>
      </dl>
    </dd>

    <dt> DynamicsCompressorNode createDynamicsCompressor() </dt>
    <dd>Creates a <a><code>DynamicsCompressorNode</code></a></dd>

    <dt> OscillatorNode createOscillator() </dt>
    <dd>Creates an <a><code>OscillatorNode</code></a></dd>
    <dt> PeriodicWave createPeriodicWave() </dt>
    <dd>
      Creates a <a><code>PeriodicWave</code></a> representing a waveform
      containing arbitrary harmonic content.  The <code>real</code> and
      <code>imag</code> parameters must be of type <code>Float32Array</code>
      (described in [[!TYPED-ARRAYS]]) of equal lengths greater than zero and less
      than or equal to 4096 or an INDEX_SIZE_ERR exception MUST be thrown.  These
      parameters specify the Fourier coefficients of a
      <a href="http://en.wikipedia.org/wiki/Fourier_series">Fourier series</a>
      representing the partials of a periodic waveform.  The created
      <a><code>PeriodicWave</code></a> will be used with an
      <a><code>OscillatorNode</code></a> and will represent a <em>normalized</em>
      time-domain waveform having maximum absolute peak value of 1.  Another way of
      saying this is that the generated waveform of an
      <a><code>OscillatorNode</code></a> will have maximum peak value at 0dBFS.
      Conveniently, this corresponds to the full-range of the signal values used by
      the Web Audio API.  Because the PeriodicWave will be normalized on creation,
      the <code>real</code> and <code>imag</code> parameters represent
      <em>relative</em> values.
    <p>
      As <a>PeriodicWave</a> objects maintain their own representation, any
      modification of the arrays uses as the <code>real</code> and
      <code>imag</code> parameters after the call to
      <a href="#widl-AudioContext-createPeriodicWave-PeriodicWave-Float32Array-real-Float32Array-imag">
        <code>createPeriodicWave()</code></a> will have no effect on the
      <a>PeriodicWave</a> object.
    </p>

    <dl class=parameters>
      <dt> Float32Array real </dt>
      <dd>
        The <dfn id="dfn-real">real</dfn> parameter represents an array of
        <code>cosine</code> terms (traditionally the A terms).  In audio
        terminology, the first element (index 0) is the DC-offset of the periodic
        waveform and is usually set to zero.  The second element (index 1)
        represents the fundamental frequency.  The third element represents the
        first overtone, and so on.
      </dd>
      <dt>Float32Array imag</dt>
      <dd>
        The <dfn id="dfn-imag">imag</dfn> parameter represents an array of
        <code>sine</code> terms (traditionally the B terms).  The first element
        (index 0) should be set to zero (and will be ignored) since this term does
        not exist in the Fourier series.  The second element (index 1) represents
        the fundamental frequency.  The third element represents the first
        overtone, and so on.
      </dd>
    </dl>
    </dd>
</dl>
<dl title="callback DecodeSuccessCallback = void" class="idl">
  <dt> AudioBuffer decodedData </dt>
  <dd> The AudioBuffer containing the decoded audio data. </dd>
</dl>

<dl title="callback DecodeErrorCallback = void" class="idl">
  <dt> DOMException error </dt>
  <dd> The error that occurred while decoding. </dd>
  </dl>

<section>
  <h3 id="lifetime-AudioContext" class="informative">Lifetime</h3>

<p>
Once created, an <code>AudioContext</code> will continue to play sound until it has no more sound to play, or
the page goes away.
</p>

</section>
<section class=informative>
<h3>Lack of introspection or serialization primitives</h3>
<p>
  The Web Audio API takes a <em>fire-and-forget</em> approach to audio source
  scheduling.  That is, <a>source nodes</a> are created for each note during the
  lifetime of the <a>AudioContext</a>, and never explicitely removed from the
  graph. This is incompatible with a serialization API, since there is no stable
  set of nodes that could be serialized.
</p>
<p>
  Moreover, having an introspection API would allow content script to be able to
  observe garbage collections.
</p>
</section>
</section>

<section>
<h2 id="OfflineAudioContext">The OfflineAudioContext Interface</h2>
<p><code>OfflineAudioContext</code> is a particular type of <a><code>AudioContext</code></a> for rendering/mixing-down
(potentially) faster than real-time. It does not render to the audio hardware, but instead renders as quickly as
possible, fulfilling the returned promise with the rendered result as an <code>AudioBuffer</code>.</p>

<p>Each <code>OfflineAudioContext</code> instance has an associated
<dfn id="#offline-audio-context-rendering-started-flag">rendering started flag</dfn> that is initially
<code>false</code>.</p>

<dl title='[Constructor(unsigned long numberOfChannels, unsigned long length, float sampleRate)] interface OfflineAudioContext : AudioContext' class='idl'>
  <dt>Promise&lt;AudioBuffer&gt; startRendering()</dt>
  <dd>
    <p>Given the current connections and scheduled changes, starts rendering audio.</p>
    <p>Although the primary method of getting the rendered audio data is via its promise return value, the instance
    will also fire an event named <code>complete</code> for legacy reasons.</p>
    <p>The following steps must be performed:</p>
    <ol>
      <li>If this instance's <a href="#offline-audio-context-rendering-started-flag">rendering started flag</a> is
      <code>true</code>, return a promise rejected with a <code>DOMException</code> whose name is
      <code>"InvalidStateError"</code>.</li>
      <li>Set this instance's <a href="#offline-audio-context-rendering-started-flag">rendering started flag</a> to
      <code>true</code>.</li>
      <li>Let <var>promise</var> be a new promise.</li>
      <li>Asynchronously perform the following steps:
        <ol>
          <li>Let <var>buffer</var> be a new <code>AudioBuffer</code>, with a number of channels equal to the
          <code>numberOfChannels</code> parameter used when this instance's constructor was called.</li>
          <li>Given the current connections and scheduled changes, start rendering audio into <var>buffer</var>.</li>
          <li>Once the rendering is complete,
            <ol>
              <li>Resolve <var>promise</var> with <var>buffer</var>.</li>
              <li>Fire a simple event named <code>complete</code> at this instance, using an instance of
              <a><code>OfflineAudioCompletionEvent</code></a> whose
              <code>renderedBuffer</code> property is set to <var>buffer</var>.</li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Return <var>promise</var>.</li>
    </ol>
  </dd>
  <dt>attribute EventHandler oncomplete</dt>
  <dd><p>An EventHandler of type <a href="#OfflineAudioCompletionEvent">OfflineAudioCompletionEvent</a>.</p></dd>
</dl>

<section>
<h2 id="OfflineAudioCompletionEvent">The OfflineAudioCompletionEvent Interface</h2>

<p>This is an <code>Event</code> object which is dispatched to <a><code>OfflineAudioContext</code></a> for legacy
reasons.</p>

<dl title="interface OfflineAudioCompletionEvent : Event" class="idl">
  <dt>readonly attribute AudioBuffer renderedBuffer</dt>
  <dd><p>An <code>AudioBuffer</code> containing the rendered audio data.</p></dd>
</dl>
</section>

</section>


<section>
<h2>The <dfn>AudioNode</dfn> Interface</h2>

<p>AudioNodes are the building blocks of an <a
href="#AudioContext"><code>AudioContext</code></a>. This interface
represents audio sources, the audio destination, and intermediate processing
modules. These modules can be connected together to form <a
href="#ModularRouting">processing graphs</a> for rendering audio to the
audio hardware. Each node can have <a>inputs</a> and/or <a>outputs</a>.
A <a>source node</a> has no inputs
and a single output. An <a
href="#AudioDestinationNode"><code>AudioDestinationNode</code></a> has
one input and no outputs and represents the final destination to the audio
hardware. Most processing nodes such as filters will have one input and one
output.  Each type of <a><code>AudioNode</code></a> differs in the details of how it processes or synthesizes audio.  But, in general, an <a><code>AudioNode</code></a>
will process its inputs (if it has any), and generate audio for its outputs (if it has any).
 </p>

<p>
Each output has one or more channels.  The exact number of
channels depends on the details of the specific <a><code>AudioNode</code></a>.
</p>

<p>
An output may connect to one or more <a><code>AudioNode</code></a>
inputs, thus <em>fan-out</em> is supported.  An input initially has no connections,
but may be connected from one
or more <a>AudioNode</a> outputs, thus <em>fan-in</em> is supported.  When the <code>connect()</code> method is called to connect
an output of an <a>AudioNode</a> to an input of an
<a>AudioNode</a>, we call that a <dfn>connection</dfn> to the input.
</p>

<p>
Each <a>AudioNode</a> <dfn>input</dfn> has a specific number of
channels at any given time.  This number can change depending on the <a>connection</a>(s)
made to the input.  If the input has no connections then it has one channel which is silent.
</p>

<p>
For each <a>input</a>, an <a><code>AudioNode</code> </a> performs a mixing
(usually an up-mixing) of all connections to that input.

Please see <a href="#mixer-gain-structure"></a> for more informative details,
and the <a href="#channel-up-mixing-and-down-mixing"></a>
  section for normative requirements.

</p>

<p>
For performance reasons, practical implementations will need to use block
processing, with each <a><code>AudioNode</code></a> processing a fixed number
of sample-frames of size <em>block-size</em>.  In order to get uniform behavior
across implementations, we will define this value explicitly.
<em>block-size</em> is defined to be 128 sample-frames which corresponds to
roughly 3ms at a sample-rate of 44.1KHz.
</p>

<p>
AudioNodes are <em>EventTarget</em>s, as described in <cite><a href="http://dom.spec.whatwg.org/">DOM</a></cite>
[[!DOM]].  This means that it is possible to dispatch events to
<a><code>AudioNode</code></a>s the same
way that other EventTargets accept events.
</p>

<dl title="enum ChannelCountMode" class="idl">
  <dt>max</dt>
  <dd><a><code>computedNumberOfChannels</code></a> is computed as the maximum of the number of channels of all connections. In this mode channelCount is ignored</dd>
  <dt>clamped-max</dt>
  <dd>Same as “max” up to a limit of the channelCount</dd>
  <dt>explicit</dt>
  <dd><a><code>computedNumberOfChannels</code></a> is the exact value as specified in channelCount</dd>
</dl>

<dl title="enum ChannelInterpretation" class="idl">
  <dt>speakers</dt>
  <dd>
    use <a href="#ChannelLayouts">up-down-mix equations for mono/stereo/quad/5.1</a>. In cases where
    the number of channels do not match any of these basic speaker layouts, revert
    to "discrete".
  </dd>
  <dt>discrete</dt>
  <dd>
    Up-mix by filling channels until they run out then zero out remaining
    channels. down-mix by filling as many channels as possible, then dropping
    remaining channels.
  </dd>
</dl>

<dl title="interface AudioNode : EventTarget" class="idl">
  <dt>void connect()</dt>
  <dd>
    <dl class=parameters>
      <dt>AudioNode destination</dt>
      <dd> The <code>destination</code> parameter is the
      <a><code>AudioNode</code></a> to connect to. </dd>
      <dt>optional unsigned long output = 0 </dt>
      <dd>
        The <code>output</code> parameter is an index describing which output of the
        <a><code>AudioNode</code></a> from which to connect. If this paremeter is out-of-bound, an
        INDEX_SIZE_ERR exception MUST be thrown.
        It is possible to connect an <a><code>AudioNode</code></a> output to more than one input
        with multiple calls to connect(). Thus, "fan-out" is supported.
      </dd>
      <dt>optional unsigned long input = 0</dt>
      <dd>
        The <code>input</code> parameter is an index describing which input of
        the destination <a><code>AudioNode</code></a> to connect to. If this
        parameter is out-of ound, an INDEX_SIZE_ERR exception MUST be thrown.
        It is possible to connect an <a><code>AudioNode</code></a> to another
        <a><code>AudioNode</code></a> which creates a <dfn>cycle</dfn>: an
        <a><code>AudioNode</code></a> may connect to another
        <a><code>AudioNode</code></a>, which in turn connects back to the first
        <a><code>AudioNode</code></a>.  This is allowed only if there is at
        least one <a><code>DelayNode</code></a> in the <em>cycle</em> or a
        NOT_SUPPORTED_ERR exception MUST be thrown.
      </dd>

    </dl>
    <p>
      There can only be one connection between a given output of one specific
      node and a given input of another specific node.  Multiple connections
      with the same termini are ignored.  For example:
    </p>

    <pre class="highlight example">
    nodeA.connect(nodeB);
    nodeA.connect(nodeB);
    </pre>

    <p>
      will have the same effect as
    </p>

    <pre class="highlight example">
      nodeA.connect(nodeB);
    </pre>
  </dd>
  <dt>
    void connect()
  </dt>
  <dd>
    Connects the <a><code>AudioNode</code></a> to an <a><code>AudioParam</code></a>, controlling the parameter
    value with an audio-rate signal.

    <dl class=parameters>
      <dt> AudioParam destination </dt>
      <dd>The <code>destination</code> parameter is the <a><code>AudioParam</code></a> to connect to.</dd>
      <dt> optional unsigned long output = 0 </dt>
      <dd>
        The <code>output</code> parameter is an index describing which output of the
        <a><code>AudioNode</code></a> from which to connect. If the <code> parameter</code> is
        out-of-bound, an INDEX_SIZE_ERR exception MUST be thrown.
      </dd>
    </dl>

    <p>It is possible to connect an <a><code>AudioNode</code></a> output to more than one
    <a><code>AudioParam</code></a> with multiple calls to connect(). Thus, "fan-out" is supported.
    </p> <p>It is possible to connect more than one <a><code>AudioNode</code></a> output to a
    single <a><code>AudioParam</code></a> with multiple calls to connect().  Thus, "fan-in" is
    supported. </p> <p>An <a><code>AudioParam</code></a> will take the rendered audio data from
    any <a><code>AudioNode</code></a> output connected to it and <a href="#down-mix">convert it to
    mono</a> by down-mixing if it is not already mono, then mix it together
    with other such outputs and finally will mix with the <em>intrinsic</em>
    parameter value (the <code>value</code> the <a><code>AudioParam</code></a> would normally have
    without any audio connections), including any timeline changes scheduled
    for the parameter. </p>

    <p> There can only be one connection between a given output of one
    specific node and a specific <a><code>AudioParam</code></a>.  Multiple connections with the
    same termini are ignored.  For example: </p>

    <pre class="highlight">
      nodeA.connect(param);
      nodeA.connect(param);
    </pre>

    will have the same effect as

    <pre>
      nodeA.connect(param);
    </pre>
  </dd>
  <dt>void disconnect()</dt>
  <dd>
  <dl class=parameters>
    <dt>optional unsigned long output = 0</dt>
    <dd>
      This parameter is an index describing which output of the
      <a><code>AudioNode</code></a> to disconnect. If this parameter is
      out-of-bounds, an INDEX_SIZE_ERR exception MUST be thrown.
    </dd>
  </dl>
  </dd>

  <dt>readonly attribute AudioContext context</dt>
  <dd>The <a><code>AudioContext</code></a> which owns this <a><code>AudioNode</code></a>.</dd>
  <dt>readonly attribute unsigned long numberOfInputs</dt>
  <dd>
    The number of inputs feeding into the <a><code>AudioNode</code></a>. For <dfn>source
    nodes</dfn>, this will be 0.
  </dd>
  <dt>readonly attribute unsigned long numberOfOutputs</dt>
  <dd>
    The number of outputs coming out of the <a><code>AudioNode</code></a>. This will be 0
    for an <a><code>AudioDestinationNode</code></a>.
  </dd>

  <dt>attribute unsigned long <dfn>channelCount</dfn></dt>
  <dd>
    <p>The number of channels used when up-mixing and down-mixing connections
    to any inputs to the node.  The default value is 2 except for specific
    nodes where its value is specially determined.  This attribute has no
    effect for nodes with no inputs.  If this value is set to zero, the
    implementation MUST throw a NOT_SUPPORTED_ERR exception.</p>
    <p>See the <a href="#channel-up-mixing-and-down-mixing"></a>
    section for more information on this attribute.</p>
  </dd>
  <dt>attribute ChannelCountMode channelCountMode</dt>
  <dd>
    <p>
      Determines how channels will be counted when up-mixing and down-mixing
      connections to any inputs to the node .  This attribute has no effect
      for nodes with no inputs.
    </p>
    <p>
      See the <a href="#channel-up-mixing-and-down-mixing"></a> section
      for more information on this attribute.
    </p>
  </dd>
  <dt>attribute ChannelInterpretation channelInterpretation</dt>
  <dd>
    <p>
      Determines how individual channels will be treated when up-mixing and
      down-mixing connections to any inputs to the node.  This attribute has
      no effect for nodes with no inputs.
    </p>
    <p>
      See the <a href="#channel-up-mixing-and-down-mixing"></a> section
      for more information on this attribute.
    </p>
  </dd>
</dl>

<section>
  <h3 id="lifetime-AudioNode" class="informative">Lifetime</h3>

  <p>
    An implementation may choose any method to avoid unnecessary resource usage
    and unbounded memory growth of unused/finished nodes.  The following is a
    description to help guide the general expectation of how node lifetime would
    be managed.
  </p>

  <p>
    An <a><code>AudioNode</code></a> will live as long as there are any references to it.
    There are several types of references:
  </p>

  <ol>
  <li>A <em>normal</em> JavaScript reference obeying normal garbage collection rules. </li>
  <li>A <em>playing</em> reference for both <a><code>AudioBufferSourceNode</code></a>s and <a><code>OscillatorNode</code></a>s.
  These nodes maintain a <em>playing</em>
  reference to themselves while they are currently playing.</li>
  <li>A <em>connection</em> reference which occurs if another <a><code>AudioNode</code></a> is connected to it.   </li>
  <li>A <em>tail-time</em> reference which an <a><code>AudioNode</code></a> maintains on itself as long as it has
  any internal processing state which has not yet been emitted.  For example, a <a><code>ConvolverNode</code></a> has
  a tail which continues to play even after receiving silent input (think about clapping your hands in a large concert
    hall and continuing to hear the sound reverberate throughout the hall).  Some <a><code>AudioNode</code></a>s have this
    property.  Please see details for specific nodes.</li>
  </ol>

  <p>
  Any <a><code>AudioNode</code></a>s which are connected in a cycle <em>and</em> are directly or indirectly connected to the
  <a><code>AudioDestinationNode</code></a> of the <a><code>AudioContext</code></a> will stay alive as long as the <a><code>AudioContext</code></a> is alive.
  </p>

  <p>
  When an <a><code>AudioNode</code></a> has no references it will be deleted.  Before it is deleted, it will disconnect itself
  from any other <a><code>AudioNode</code></a>s which it is connected to.  In this way it releases all connection references (3) it has to other nodes.
  </p>

  <p>
  Regardless of any of the above references, it can be assumed that the <a><code>AudioNode</code></a> will be deleted when its <a><code>AudioContext</code></a> is deleted.
  </p>
</section>
</section>


<section>
<h2 id="AudioDestinationNode">The AudioDestinationNode Interface</h2>

<p>This is an <a><code>AudioNode</code></a> representing the final audio destination and is
what the user will ultimately hear. It can often be considered as an audio
output device which is connected to speakers. All rendered audio to be heard
will be routed to this node, a "terminal" node in the <a><code>AudioContext</code></a>'s routing
graph. There is only a single AudioDestinationNode per <a><code>AudioContext</code></a>, provided
through the <code>destination</code> attribute of <a><code>AudioContext</code></a>. </p>
<pre>
      numberOfInputs  : 1
      numberOfOutputs : 0

      channelCount = 2;
      channelCountMode = "explicit";
      channelInterpretation = "speakers";
</pre>

<dl title="interface AudioDestinationNode : AudioNode" class="idl">
  <dt>readonly attribute unsigned long maxChannelCount</dt>
  <dd>
    <p>
    The maximum number of channels that the <a href="#widl-AudioNode-channelCount"><code>
        channelCount</code></a> attribute
    can be set to.  An <a><code>AudioDestinationNode</code></a> representing the audio
    hardware end-point (the normal case) can potentially output more than 2
    channels of audio if the audio hardware is multi-channel.
    <code>maxChannelCount</code> is the maximum number of channels that this
    hardware is capable of supporting.  If this value is 0, then this indicates
    that <a href="#widl-AudioNode-channelCount">channelCount</a> may not be
    changed.  This will be the case for an <a><code>AudioDestinationNode</code></a> in an
    <a><code>OfflineAudioContext</code></a> and also for basic implementations with hardware
    support for stereo output only.
    </p>

    <p>
      <a href="#widl-AudioNode-channelCount">channelCount</a> defaults to 2 for
      a destination in a normal <a><code>AudioContext</code></a>, and may be set to any
      non-zero value less than or equal to <code>maxChannelCount</code>.  An
      <a><code>INDEX_SIZE_ERR</code></a> exception MUST be thrown if this value is not within
      the valid range.  Giving a concrete example, if the audio hardware
      supports 8-channel output, then we may set <a
      href="#widl-AudioNode-channelCount">channelCount</a> to 8, and render
      8-channels of output.
    </p>

    <p>
      For an<a><code>AudioDestinationNode</code></a> in an
      <a><code>OfflineAudioContext</code></a>, the
      <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a> is
      determined when the offline context is created and this value may not be
      changed.
    </p>
  </dd>
</dl>

</section>

<section>
<h2 id="AudioParam">The AudioParam Interface</h2>

<p>
  <a><code>AudioParam</code></a> controls an individual aspect of an <a><code>AudioNode</code></a>'s functioning,
  such as volume.  The parameter can be set immediately to a particular value
  using the <code>value</code> attribute. Or, value changes can be scheduled to
  happen at very precise times (in the coordinate system of
  <a><code>AudioContext</code></a>'s <a href="#widl-AudioContext-currentTime">currentTime</a>
  attribute), for envelopes, volume fades, LFOs, filter sweeps,
  grain windows, etc. In this way, arbitrary timeline-based automation curves
  can be set on any <a><code>AudioParam</code></a>.  Additionally, audio signals from the outputs of
  <a><code>AudioNode</code></a>s can be connected to an <a><code>AudioParam</code></a>, summing with the
  <em>intrinsic</em> parameter value.
</p>

<p>
  Some synthesis and processing <a><code>AudioNode</code></a>s have
  <code>AudioParams</code> as attributes whose values must be taken into account
  on a per-audio-sample basis.  For other <code>AudioParams</code>,
  sample-accuracy is not important and the value changes can be sampled more
  coarsely.  Each individual <code>AudioParam</code> will specify that it is
  either an <a>a-rate</a> parameter which means that its values must be taken
  into account on a per-audio-sample basis, or it is a <a>k-rate</a>
  parameter.
</p>

<p>
  Implementations must use block processing, with each <a><code>AudioNode</code></a>
  processing 128 sample-frames in each block.
</p>

<p>
  For each 128 sample-frame block, the value of a <dfn id="k-rate">k-rate</dfn> parameter must
  be sampled at the time of the very first sample-frame, and that value must be
  used for the entire block.  <dfn id="a-rate">a-rate</dfn> parameters must be sampled for
  each sample-frame of the block.
</p>

<p>
  An <code>AudioParam</code> maintains a time-ordered event list which is
  initially empty.  The times are in the time coordinate system of
  the <a><code>AudioContext</code></a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.  The events define a mapping from time to value.
  The following methods can change the event list by adding a new event into the
  list of a type specific to the method.  Each event has a time associated with
  it, and the events will always be kept in time-order in the list.  These
  methods will be called <em>automation</em> methods:
</p>

<ul>
<li>setValueAtTime() - <em>SetValue</em></li>
<li>linearRampToValueAtTime() - <em>LinearRampToValue</em></li>
<li>exponentialRampToValueAtTime() - <em>ExponentialRampToValue</em></li>
<li>setTargetAtTime() - <em>SetTarget</em></li>
<li>setValueCurveAtTime() - <em>SetValueCurve</em></li>
</ul>

<p>
The following rules will apply when calling these methods:
</p>
<ul>
  <li>
    If one of these events is added at a time where there is already an event
    of the exact same type, then the new event will replace the old one.
  </li>
  <li>
    If one of these events is added at a time where there is already one or more
    events of a different type, then it will be placed in the list after them, but
    before events whose times are after the event.
  </li>
  <li>
    If setValueCurveAtTime() is called for time T and duration D and there are any
    events having a time greater than T, but less than T + D, then a
    NOT_SUPPORTED_ERR exception MUST be thrown.  In other words, it's not ok to
    schedule a value curve during a time period containing other events.
  </li>
  <li>
    Similarly a NOT_SUPPORTED_ERR exception MUST be thrown if any
    <em>automation</em> method is called at a time which is inside of the time
    interval of a <em>SetValueCurve</em> event at time T and duration D.
  </li>
</ul>

<dl title="interface AudioParam" class="idl">
  <dt> attribute float value </dt>
  <dd>
    <p>
      The parameter's floating-point value.  This attribute is initialized to
      the <code>defaultValue</code>.  If <code>value</code> is set during a time
      when there are any automation events scheduled then it will be ignored and
      no exception will be thrown.
    </p>
  </dd>
  <dt> readonly attribute float defaultValue </dt>
  <dd>
    Initial value for the <code>value</code> attribute.
  </dd>

  <dt> void setValueAtTime(float value, double startTime) </dt>
  <dd>
    <p>
      Schedules a parameter value change at the given time.
    </p>
    <p>
      The <code>value</code> parameter is the value the parameter
      will change to at the given time.
    </p>
    <p>
      The <code>startTime</code> parameter is the time
      in the same time coordinate system as the <a><code>AudioContext</code></a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.  An INVALID_ACCESS_ERR exception MUST be 
      thrown if <code>startTime</code> is negative or is not a finite number.
    </p>
    <p>
      If there are no more events after this <em>SetValue</em> event, then for t
      &gt;= <code>startTime</code>,  v(t) = value.  In other words, the value
      will remain constant.
    </p>
    <p>
      If the next event (having time T1) after this <em>SetValue</em> event is
      not of type <em>LinearRampToValue</em> or <em>ExponentialRampToValue</em>,
      then, for t:
    </p>
    <pre>
      startTime &lt;= t &lt; T1,  v(t) = value
    </pre>
    <p>
       In other words, the value will remain constant during this time interval,
       allowing the creation of "step" functions.
    </p>
    <p>
      If the next event after this <em>SetValue</em> event is of type
      <em>LinearRampToValue</em> or <em>ExponentialRampToValue</em> then please
      see details below.
    </p>
  </dd>
  <dt> void linearRampToValueAtTime(float value, double endTime) </dt>
  <dd>
    <p>
      Schedules a linear continuous change in parameter value from the previous
      scheduled parameter value to the given value.
    </p>
    <p>
      The <code>value</code> parameter is the value the parameter will linearly ramp
      to at the given time.</p>
    <p>
      The <code>endTime</code> parameter is the time in the same time coordinate
      system as the <a><code>AudioContext</code></a>'s <a
      href="#widl-AudioContext-currentTime">currentTime</a> attribute.  An
      INVALID_ACCESS_ERR exception MUST be thrown if <code>endTime</code> is
      negative or is not a finite number.
    </p>

    <p>
      The value during the time interval T0 &lt;= t &lt; T1 (where T0 is the time
      of the previous event and T1 is the <code>endTime</code> parameter passed
      into this method) will be calculated as:
    </p>
    <pre>
      v(t) = V0 + (V1 - V0) * ((t - T0) / (T1 - T0))
    </pre>
    <p>
      Where V0 is the value at the time T0 and V1 is the value parameter passed
      into this method.
    </p>
    <p>
      If there are no more events after this LinearRampToValue event then for t
      &gt;= T1, v(t) = V1.
    </p>
  </dd>
  <dt> void exponentialRampToValueAtTime(float value, double endTime) </dt>
  <dd>
    <p>
      Schedules an exponential continuous change in parameter value from
      the previous scheduled parameter value to the given value. Parameters
      representing filter frequencies and playback rate are best changed
      exponentially because of the way humans perceive sound.
    </p>
    <p>
      The <code>value</code> parameter is the value the parameter
      will exponentially ramp to at the given time.  A NOT_SUPPORTED_ERR exception
      MUST be thrown if this value is less than or equal to 0, or if the value at
      the time of the previous event is less than or equal to 0.
    </p>
    <p>
      The <code>endTime</code> parameter is the time in the same
      time coordinate system as the <a><code>AudioContext</code></a>'s <a
      href="#widl-AudioContext-currentTime">currentTime</a> attribute.  An
      INVALID_ACCESS_ERR exception MUST be thrown if <code>endTime</code> is
      negative or is not a finite number.
    </p>
    <p>
      The value during the time interval T0 &lt;= t &lt; T1 (where T0 is the time
      of the previous event and T1 is the endTime parameter passed into this
      method) will be calculated as:
    </p>
    <pre>
        v(t) = V0 * (V1 / V0) ^ ((t - T0) / (T1 - T0))
    </pre>
    <p>
      Where V0 is the value at the time T0 and V1 is the value parameter passed into
      this method.
    </p>
    <p>
      If there are no more events after this ExponentialRampToValue event then for t
      &gt;= T1, v(t) = V1
    </p>
  </dd>
  <dt> void setTargetAtTime(float target, double startTime, float timeConstant) </dt>
  <dd>
    <p>
      Start exponentially approaching the target value at the given time

      with a rate having the given time constant. Among other uses, this is
      useful for implementing the "decay" and "release" portions of an ADSR
      envelope. Please note that the parameter value does not immediately
      change to the target value at the given time, but instead gradually
      changes to the target value.
    </p>
    <p>
      The <code>target</code> parameter is the value
      the parameter will <em>start</em> changing to at the given time.
    </p>
    <p>
      The <code>startTime</code> parameter is the time in the
      same time coordinate system as the <a><code>AudioContext</code></a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.  An INVALID_ACCESS_ERR exception MUST be 
      thrown if <code>start</code> is negative or is not a finite number.
    </p>
    <p>
      The <dfn id="dfn-timeConstant">timeConstant</dfn> parameter is the
      time-constant value of first-order filter (exponential) approach to the
      target value. The larger this value is, the slower the transition will
      be.
    </p>
    <p>
      More precisely, <em>timeConstant</em> is the time it takes a first-order
      linear continuous time-invariant system to reach the value 1 - 1/e (around
      63.2%) given a step input response (transition from 0 to 1 value).
    </p>
    <p>
      During the time interval: <em>T0</em> &lt;= t &lt; <em>T1</em>, where T0
      is the <code>startTime</code> parameter and T1 represents the time of the
      event following this event (or <em>infinity</em> if there are no following
      events):
    </p>
    <pre>
    v(t) = V1 + (V0 - V1) * exp(-(t - T0) / <em>timeConstant</em>)
    </pre>
    <p>
      Where V0 is the initial value (the .value attribute) at T0 (the
      <code>startTime</code> parameter) and V1 is equal to the <em>target</em>
      parameter.
    </p>
    </dd>
  <dt> void setValueCurveAtTime(Float32Array values, double startTime, double duration) </dt>
    <dd>
      <p>
        Sets an array of arbitrary parameter values starting at the given
        time for the given duration. The number of values will be scaled to fit
        into the desired duration.
      </p>
      <p>
        The <code>values</code> parameter is a Float32Array
        representing a parameter value curve. These values will apply starting at
        the given time and lasting for the given duration. Any modification to the
        the array used as <a id="#dfn-values"><code>values</code></a> argument
        after the call won't have any effect on the <a>AudioParam</a>.
      </p>
      <p>
        The <code>startTime</code> parameter is the time in the same time
        coordinate system as the <a><code>AudioContext</code></a>'s <a
        href="#widl-AudioContext-currentTime">currentTime</a> attribute.  An
        INVALID_ACCESS_ERR exception MUST be thrown if <code>startTime</code> is
        negative or is not a finite number.
      </p>
      <p>
        The <dfn id="dfn-duration_5">duration</dfn> parameter is the amount of
        time in seconds (after the <em>time</em> parameter) where values will be
        calculated according to the <em>values</em> parameter.
      </p>
      <p>
        During the time interval: <code>startTime</code> &lt;= t &lt;
        <code>startTime</code> + <em>duration</em>, values will be calculated:
      </p>
      <pre>
        v(t) = values[N * (t - startTime) / duration]
      </pre>
      <p>
        where <em>N</em> is the length of the <em>values</em> array.
      </p>
      <p>
        After the end of the curve time interval (t &gt;= <code>startTime</code> +
        <em>duration</em>), the value will remain constant at the final curve
        value, until there is another automation event (if any).
      </p>
    </dd>
  <dt> void cancelScheduledValues(double startTime) </dt>
    <dd>
      <p>
        Cancels all scheduled parameter changes with times greater than or
        equal to <code>startTime</code>.
      </p>
      <p>
        The <code>startTime</code> parameter is the starting time at and after
        which any previously scheduled parameter changes will be cancelled.  It
        is a time in the same time coordinate system as
        the <a><code>AudioContext</code></a>'s 
        <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.
        An INVALID_ACCESS_ERR exception MUST be thrown if <code>startTime</code> 
        is negative or is not a finite number.
      </p>
    </dd>
</dl>

<section>
<h3>Computation of Value</h3>

<p>
<dfn>computedValue</dfn> is the final value controlling the audio DSP and is computed by the audio rendering thread during each rendering time quantum.
  It must be internally computed as follows:
</p>

<ol>
<li>An <em>intrinsic</em> parameter value will be calculated at each time, which is either the value set directly to the <code>value</code> attribute,
or, if there are any scheduled parameter changes (automation events) with times before or at this time,
the value as calculated from these events.  If the <code>value</code> attribute
is set after any automation events have been scheduled, then these events will be removed.  When read, the <code>value</code> attribute
always returns the <em>intrinsic</em> value for the current time.  If automation events are removed from a given time range, then the
<em>intrinsic</em> value will remain unchanged and stay at its previous value until either the <code>value</code> attribute is directly set, or automation events are added
for the time range.
</li>

<li>
An <a><code>AudioParam</code></a> will take the rendered audio data from any <a><code>AudioNode</code></a> output connected to it and <a href="#down-mix">convert it to mono</a> by down-mixing if it is not
already mono, then mix it together with other such outputs.  If there are no <a><code>AudioNode</code></a>s connected to it, then this value is 0, having no
effect on the <em>computedValue</em>.
</li>

<li>
The <em>computedValue</em> is the sum of the <em>intrinsic</em> value and the value calculated from (2).
</li>

</ol>
</section>


<section>
<h3 id="example1-AudioParam">AudioParam Automation Example</h3>

<figure>
  <img alt="AudioParam automation" src="images/audioparam-automation1.png">
  <figcaption>An example of parameter automation.</figcaption>
</figure>
<pre class="code example"><code class="es-code highlight">
var t0 = 0;
var t1 = 0.1;
var t2 = 0.2;
var t3 = 0.3;
var t4 = 0.4;
var t5 = 0.6;
var t6 = 0.7;
var t7 = 1.0;

var curveLength = 44100;
var curve = new Float32Array(curveLength);
for (var i = 0; i &lt; curveLength; ++i)
    curve[i] = Math.sin(Math.PI * i / curveLength);

param.setValueAtTime(0.2, t0);
param.setValueAtTime(0.3, t1);
param.setValueAtTime(0.4, t2);
param.linearRampToValueAtTime(1, t3);
param.linearRampToValueAtTime(0.15, t4);
param.exponentialRampToValueAtTime(0.75, t5);
param.exponentialRampToValueAtTime(0.05, t6);
param.setValueCurveAtTime(curve, t6, t7 - t6);
</code></pre>
</section>
</section>

<section>
<h2 id="GainNode">The GainNode Interface</h2>
<p>
  Changing the gain of an audio signal is a fundamental operation in audio
  applications.  The <code>GainNode</code> is one of the building blocks for
  creating <a href="#mixer-gain-structure">mixers</a>.  This interface is an
  <a><code>AudioNode</code></a> with a single input and single output:
</p>
<pre>
  numberOfInputs  : 1
  numberOfOutputs : 1

  channelCountMode = "max";
  channelInterpretation = "speakers";
</pre>

<p>
  Each sample of each channel of the input data of the
  <a><code>GainNode</code></a> MUST be multiplied by the <a>computedValue</a> of
  the <a><code>gain</code></a> <a><code>AudioParam</code></a>.
</p>

<p>
  The implementation must make gain changes to the audio stream smoothly,
  without introducing noticeable clicks or glitches. This process is called
  "de-zippering".
</p>

<dl title="interface GainNode : AudioNode" class="idl">
  <dt>readonly attribute AudioParam gain</dt>
  <dd>
    Represents the amount of gain to apply. Its default <code>value</code> is 1
    (no gain change). The nominal <code>minValue</code> is 0, but may be set
    negative for phase inversion.  The nominal <code>maxValue</code> is 1, but
    higher values are allowed (no
    exception thrown).This parameter is <a>a-rate</a>
  </dd>
</dl>
</section>

<section>
<h2 id="DelayNode">The DelayNode Interface</h2>

<p>A delay-line is a fundamental building block in audio applications. This
interface is an <a><code>AudioNode</code></a> with a single input and single output: </p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>

<p>
  The number of channels of the output always equals the number of channels of the
  input.
</p>

<p>
  It delays the incoming audio signal by a certain amount. Specifically, at each
  time <em>t</em>, input signal <em>input(t)</em>, delay time
  <em>delayTime(t)</em> and output signal <em>output(t)</em>, the output will be
  <em> output(t) = input(t - delayTime(t))</em>. The default
  <code>delayTime</code> is 0 seconds (no delay). When the delay time is
  changed, the implementation must make the transition smoothly, without
  introducing noticeable clicks or glitches to the audio stream.
</p>

<dl title="interface DelayNode : AudioNode" class="idl">
  <dt> readonly attribute AudioParam delayTime </dt>
  <dd>
    <p>
      An <a><code>AudioParam</code></a> object representing the amount of delay
      (in seconds) to apply. Its default <code>value</code> is 0 (no delay). The
      minimum value is 0 and the maximum value is determined by the
      <code>maxDelayTime</code> argument to the <code>AudioContext</code> method
      <code>createDelay</code>.
    </p>
    <p>
      If <a><code>DelayNode</code></a> is part of a <a>cycle</a>, then the value
      of the <a><code>delayTime</code></a> attribute is clamped to a minimum of
      128 frames (one block).
    </p>
    <p>
      This parameter is <a>a-rate</a>.
    </p>
  </dd>
</dl>

</section>

<section>
<h2 id="AudioBuffer">The AudioBuffer Interface</h2>

<p>
  This interface represents a memory-resident audio asset (for one-shot sounds
  and other short audio clips). Its format is non-interleaved IEEE 32-bit linear
  PCM with a nominal range of -1 -&gt; +1. It can contain one or more channels.
  Typically, it would be expected that the length of the PCM data would be
  fairly short (usually somewhat less than a minute).  For longer sounds, such
  as music soundtracks, streaming should be used with the <code>audio</code>
  element and <code>MediaElementAudioSourceNode</code>.
</p>

<p>
  An <a>AudioBuffer</a> may be used by one or more
  <a><code>AudioContext</code></a>s.
</p>

<dl title="interface AudioBuffer" class="idl">
    <dt> readonly attribute float sampleRate </dt>
    <dd> The sample-rate for the PCM audio data in samples per second. </dd>
    <dt> readonly attribute long length </dt>
    <dd> Length of the PCM audio data in sample-frames. </dd>
    <dt> readonly attribute double duration </dt>
    <dd> Duration of the PCM audio data in seconds. </dd>
    <dt> readonly attribute long numberOfChannels </dt>
    <dd> The number of discrete audio channels. </dd>
    <dt> Float32Array getChannelData() </dt>
    <dd>
      Returns the <code>Float32Array</code> representing the PCM audio data for
      the specific channel.

      <dl class="parameters">
        <dt>unsigned long channel</dt>
        <dd>
          This parameter is an index representing the particular channel to get data
          for.  An index value of 0 represents the first channel.  This  index value
          MUST be less than <code>numberOfChannels</code> or an INDEX_SIZE_ERR
          exception MUST be thrown.
        </dd>
      </dl>
    </dd>
    <dt> void copyFromChannel() </dt>
    <dd>
      The <code>copyFromChannel</code> method copies the samples from the
      specified channel of the <a>AudioBuffer</a> to the
      <code>destination</code> array.
      <dl class="parameters">
        <dt>Float32Array destination</dt>
        <dd>The array the channel data will be copied to.</dd>
        <dt>long channelNumber</dt>
        <dd>
          The index of the channel to copy the data from. If
          <code>channelNumber</code> is greater or equal than the number of
          channel of the <a>AudioBuffer</a>, an <code>INDEX_SIZE_ERR</code> MUST
          be thrown.
        </dd>
        <dt>optional unsigned long startInChannel = 0</dt>
        <dd>
          An optional offset to copy the data from. If
          <code>startInChannel</code> is greater than the <code>length</code> of the
          <a>AudioBuffer</a>, an <code>INDEX_SIZE_ERR</code> MUST be thrown.
        </dd>
      </dl>
    </dd>
    <dt>void copyToChannel()</dt>
    <dd>
      The <code>copyToChannel</code> method copies the samples to the
      specified channel of the <a>AudioBuffer</a>, from the
      <code>source</code> array.
      <dl class="parameters">
        <dt>Float32Array source</dt>
        <dd>The array the channel data will be copied from.</dd>
        <dt>long channelNumber</dt>
        <dd>
          The index of the channel to copy the data to. If
          <code>channelNumber</code> is greater or equal than the number of
          channel of the <a>AudioBuffer</a>, an <code>INDEX_SIZE_ERR</code> MUST
          be thrown.
        </dd>
        <dt>optional unsigned long startInChannel = 0</dt>
          <dd>
            An optional offset to copy the data to.  If
            <code>startInChannel</code> is greater than the <code>length</code>
            of the <a>AudioBuffer</a>, an <code>INDEX_SIZE_ERR</code> MUST be
            thrown.
          </dd>
      </dl>
    </dd>
</dl>

<p class="note">
  The methods <code>copyToChannel</code> and <code>copyFromChannel</code> can be
  used to fill part of an array by passing in a <code>Float32Array</code> that's
  a view onto the larger array.

  When reading data from an <a>AudioBuffer</a>'s channels, and the data can be
  processed in chunks, <code>copyFromChannel</code> should be preferred to
  calling <code>getChannelData</code> and accessing the resulting array, because
  it may avoid unnecessary memory allocation and copying.
</p>

<p>
  An internal operation <a href="#acquire-the-content">acquire the contents of
  an <code>AudioBuffer</code></a> is invoked when the contents of an
  <a>AudioBuffer</a> are needed by some API implementation. This operation
  returns immutable channel data to the
  invoker.
</p>

<p>
When an <dfn id="acquire-the-content">acquire the content</dfn> operation occurs on an
<a>AudioBuffer</a>, run the following steps:
</p>
<ol>
  <li> If any of the <a>AudioBuffer</a>'s <code>ArrayBuffer</code> have
  been neutered, abort these steps, and return a zero-length channel data
  buffers to the invoker. </li>
  <li> Neuter all <code>ArrayBuffer</code>s for arrays previously returned by
  <code>getChannelData</code> on this <a>AudioBuffer</a>.</li>
  <li>Retain the underlying data buffers from those <code>ArrayBuffer</code>s
  and return references to them to the invoker.</li>
  <li>Attach <code>ArrayBuffer</code>s containing copies of the data to the
  <a>AudioBuffer</a>, to be returned by the next call to
  <code>getChannelData</code>.</li>
</ol>

The <a href="#acquire-the-content">acquire the contents of an AudioBuffer</a> operation is
invoked in the following cases:
<ul>
  <li>When <code>AudioBufferSourceNode.start</code> is called, it
  <a href="#acquire-the-content">acquires the contents</a> of the node's
  <code>buffer</code>. If the operation fails, nothing is played.</li>
  <li> When a <a>ConvolverNode</a>'s <code>buffer</code> is set to an
  <a>AudioBuffer</a> while the node is connected to an output node, or a
  <a>ConvolverNode</a> is connected to an output node while the
  <a>ConvolverNode</a>'s <code>buffer</code> is set to an
  <a>AudioBuffer</a>, it <a href="#acquire-the-content">acquires the
    content</a> of the <a>AudioBuffer</a>.</li>
  <li> When the dispatch of an <a>AudioProcessingEvent</a> completes, it
  <a href="#acquire-the-content">acquires the contents</a> of its
  <code>outputBuffer</code>.</li>
</ul>


</section>

<section>
<h2 id="AudioBufferSourceNode">The AudioBufferSourceNode Interface</h2>

<p>
  This interface represents an audio source from an in-memory audio asset in an
  <code>AudioBuffer</code>. It is useful for playing short audio assets which
  require a high degree of scheduling flexibility (can playback in rhythmically
  perfect ways). The start() method is used to schedule when sound playback will
  happen.  The playback will stop automatically when the buffer's audio data has
  been completely played (if the <code>loop</code> attribute is false), or when
  the stop() method has been called and the specified time has been reached.
  Please see more details in the start() and stop() description.  start() and
  stop() may not be issued multiple times for a given AudioBufferSourceNode.
</p>
<pre>
  numberOfInputs  : 0
  numberOfOutputs : 1
</pre>

<p>
  The number of channels of the output always equals the number of channels of
  the AudioBuffer assigned to the .buffer attribute, or is one channel of
  silence if .buffer is NULL.
</p>

<dl title="interface AudioBufferSourceNode : AudioNode" class="idl">
  <dt>attribute AudioBuffer? buffer</dt>
  <dd> Represents the audio asset to be played. </dd>

  <dt>readonly attribute AudioParam playbackRate</dt>
  <dd>
  The speed at which to render the audio stream. Its default
  <code>value</code> is 1.  This parameter is <a>k-rate</a>.
  </dd>
  <dt>readonly attribute AudioParam detune</dt>
  <dd>
  An aditional parameter to modulate the speed at which is rendered the audio
  stream. Its default value is 0. Its nominal range is [-1200; 1200].  This
  parameter is <a>k-rate</a>.
  </dd>
  <dt>attribute boolean loop</dt>
  <dd>
  Indicates if the audio data should play in a loop.  The default value is
  false.
  </dd>
  <dt>attribute double loopStart</dt>
  <dd>
  An optional value in seconds where looping should begin if the
  <code>loop</code> attribute is true.  Its default <code>value</code> is 0,
  and it may usefully be set to any value between 0 and the duration of the
  buffer.
  </dd>
  <dt>attribute double loopEnd</dt>
  <dd>
  An optional value in seconds where looping should end if the
  <code>loop</code> attribute is true.  Its default <code>value</code> is 0,
  and it may usefully be set to any value between 0 and the duration of the
  buffer.
  </dd>

  <dt>
  void start()
  </dt>
  <dd>
  Schedules a sound to playback at an exact time.
  <dl class="parameters">
    <dt>optional double when = 0</dt>
    <dd>
    The <a><code>when</code></a> parameter describes at what time (in seconds) the sound
    should start playing. It is in the same time coordinate system as
    the <a><code>AudioContext</code></a>'s <a href="#widl-AudioContext-currentTime">currentTime</a> attribute. If 0 is passed in for this value or if the
    value is less than <b>currentTime</b>, then the sound will start playing
    immediately.  <code>start</code> may only be called one time and must be
    called before <code>stop</code> is called or an INVALID_STATE_ERR
    exception MUST be thrown.  An INVALID_ACCESS_ERR exception MUST be 
    thrown if <code>when</code> is negative or is not a finite number.
    </dd>
    <dt>optional double offset = 0</dt>
    <dd>
    The <dfn id="dfn-offset">offset</dfn> parameter describes the offset
    time in the buffer (in seconds) where playback will begin. If 0 is
    passed in for this value, then playback will start from the beginning of
    the buffer.  An INVALID_ACCESS_ERR exception MUST be thrown if 
    <code>offset</code> is negative or is not a finite number.
    </dd>
    <dt>optional double duration</dt>
    <dd>
    The <a><code>duration</code></a> parameter describes the
    duration of the portion (in seconds) to be played.  If this parameter is
    not passed, the duration will be equal to the total duration of the
    AudioBuffer minus the <code>offset</code> parameter.  Thus if neither
    <code>offset</code> nor <code>duration</code> are specified then the
    implied duration is the total duration of the AudioBuffer.  An 
    INVALID_ACCESS_ERR exception MUST be thrown if <code>duration</code> 
    is negative or is not a finite number.
    </dd>
  </dl>
  </dd>

  <dt> void stop() </dt>
  <dd>
  Schedules a sound to stop playback at an exact time.
  <dl class="parameters">
    <dt>optional double when = 0</dt>
    <dd>
    The <a><code>when</code></a> parameter describes at what time (in seconds) the sound
    should stop playing.  It is in the same time coordinate system as
    the <a><code>AudioContext</code></a>'s
    <a href="#widl-AudioContext-currentTime">currentTime</a> attribute.  If 0
    is passed in for this value or if the value
    is less than <a><code>currentTime</code></a>, then the sound will stop playing
    immediately.    An INVALID_ACCESS_ERR exception MUST be thrown if 
    <code>when</code> is negative or is not a finite number.  If <code>stop</code> 
    is called again after already have been
    called, the last invocation will be the only one applied; stop times set by previous
    calls will not be applied, unless the buffer has already stopped prior to any
    subsequent calls.  If the buffer has already stopped, further calls to
    <code>stop</code> will have no effect.  If a stop time is reached prior to the
    scheduled start time, the sound will not play.
    </dd>
  </dl>
  </dd>

  <dt> attribute EventHandler onended </dt>
  <dd>
  A property used to set the <code>EventHandler</code> (described in <cite>
    <a href="http://www.whatwg.org/specs/web-apps/current-work/#eventhandler">
      HTML</a></cite>[[!HTML]]) for the ended event that is dispatched to
  <a><code>AudioBufferSourceNode</code></a>
  node types.  When the playback of the buffer for an
  <a><code>AudioBufferSourceNode</code></a> is finished, an event of type <code>Event
  </code> (described in <cite> <a
      href="http://www.whatwg.org/specs/web-apps/current-work/#event">HTML</a>
  </cite>[[!HTML]]) will be dispatched to the event handler.
  </dd>
</dl>

<p>
Both <code>playbackRate</code> and <code>detune</code> are <a>k-rate</a>
parameters and are used together to determine a <em>computedPlaybackRate</em>
value:

<pre class=highlight>
  computedPlaybackRate(t) = playbackRate(t) * pow(2, detune(t) / 1200)
</pre>

The <code>computedPlaybackRate</code> is the effective speed at which the
<a><code>AudioBuffer</code></a> of this <a><code>AudioBufferSourceNode</code>
</a> MUST be played.
</p>

<section>
<h3 id="looping-AudioBufferSourceNode">Looping</h3>
<p>
If the <code>loop</code> attribute is true when <code>start()</code> is called, then playback will continue indefinitely
until <code>stop()</code> is called and the stop time is reached.  We'll call this "loop" mode.  Playback always starts at the point in the buffer indicated
by the <code>offset</code> argument of <code>start()</code>, and in <em>loop</em> mode will continue playing until it reaches the <em>actualLoopEnd</em> position
in the buffer (or the end of the buffer), at which point it will wrap back around to the <em>actualLoopStart</em> position in the buffer, and continue
playing according to this pattern.
</p>

<p>
In <em>loop</em> mode then the <em>actual</em> loop points are calculated as follows from the <code>loopStart</code> and <code>loopEnd</code> attributes:
</p>

<blockquote>
<pre class="highlight">
if ((loopStart || loopEnd) &amp;&amp; loopStart &gt;= 0 &amp;&amp; loopEnd &gt; 0 &amp;&amp; loopStart &lt; loopEnd) {
    actualLoopStart = loopStart;
    actualLoopEnd = min(loopEnd, buffer.duration);
} else {
    actualLoopStart = 0;
    actualLoopEnd = buffer.duration;
}
</pre>
</blockquote>

<p>
Note that the default <code>value</code>s for <code>loopStart</code> and <code>loopEnd</code> are both 0, which indicates that looping should occur from the very start
to the very end of the buffer.
</p>

<p>
  Please note that as a low-level implementation detail, the AudioBuffer is at a
  specific sample-rate (usually the same as the <a><code>AudioContext</code></a>
  sample-rate), and that the loop times (in seconds) must be converted to the
  appropriate sample-frame positions in the buffer according to this sample-rate.
</p>
<p>
  When scheduling the beginning and the end of playback using the
  <code>start()</code> and <code>stop()</code> methods, the resulting start or
  stop time MUST be rounded to the nearest sample-frame in the sample rate of
  the <a><code>AudioContext</code></a>. That is, no sub-sample scheduling is
  possible.
</p>

</section>
</section>

<section>
<h2 id="MediaElementAudioSourceNode">The MediaElementAudioSourceNode Interface</h2>

<p>This interface represents an audio source from an <code>audio</code> or
<code>video</code> element. </p>
<pre>
  numberOfInputs  : 0
  numberOfOutputs : 1
</pre>

<p>
The number of channels of the output corresponds to the number of channels of the media referenced by the <code>HTMLMediaElement</code>.
Thus, changes to the media element's .src attribute can change the number of channels output by this node.
If the .src attribute is not set, then the number of channels output will be one silent channel.
</p>

<dl title="interface MediaElementAudioSourceNode : AudioNode" class=idl>
</dl>

<p>
  A <a>MediaElementAudioSourceNode</a> is created given an
  <code>HTMLMediaElement</code> using the <a>AudioContext</a>
  <code>createMediaElementSource()</code> method.
</p>

<p>
  The number of channels of the single output equals the number of channels of
  the audio referenced by the <code> HTMLMediaElement </code> passed in as the
  argument to <code>createMediaElementSource()</code>, or is 1 if the
  <code>HTMLMediaElement</code> has no audio.
</p>

<p>
  The <code>HTMLMediaElement</code> must behave in an identical fashion
  after the <a>MediaElementAudioSourceNode</a> has been created, <em>except</em>
  that the rendered audio will no longer be heard directly, but instead will be
  heard as a consequence of the <a>MediaElementAudioSourceNode</a> being
  connected through the routing graph.  Thus pausing, seeking, volume,
  <code>src</code> attribute changes, and other aspects of the
  <code>HTMLMediaElement</code> must behave as they normally would if
  <em>not</em> used with a <a>MediaElementAudioSourceNode</a>.
</p>

<pre class="highlight example">
  var mediaElement = document.getElementById('mediaElementID');
  var sourceNode = context.createMediaElementSource(mediaElement);
  sourceNode.connect(filterNode);
</pre>

<section>
  <h2>Security with MediaElementAudioSourceNode and cross-origin resources</h2>
  <p>
    <code>HTMLMediaElement</code> allows the playback of cross-origin resources.
    Because Web Audio can allows one to inspect the content of the resource
    (e.g. using a <a>MediaElementAudioSourceNode</a>, and a
    <a>ScriptProcessorNode</a> to read the samples), information leakage can
    occur if scripts from one <a
      href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#origin-0">origin</a>
      inspect the content of a resource from another <a
        href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#origin-0">origin</a>.
  </p>
  <p>
    To prevent this, a <a>MediaElementAudioSourceNode</a> MUST output
    <em>silence</em> instead of the normal output of the
    <code>HTMLMediaElement</code>
    if it has been created using an <code>HTMLMediaElement</code> for which the
    execution of the <a
    href="http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#cors-enabled-fetch">fetch
  algorithm</a> labeled the resource as <a
href="http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#cors-cross-origin">CORS-cross-origin</a>.
  </p>
</section>

</section>

<section>
<h2>The <dfn>AudioWorker</dfn></h2>

<p>AudioWorker is not an actual class in the Web Audio API; an Audio Worker is 
  represented in the main thread by the <a>AudioWorkerNode</a> methods 
  (postMessage, onmessage and terminate, in particular). From inside an audio 
  worker script, an Audio Worker is represented by an 
  <a><code>AudioWorkerGlobalScope</code></a> object representing the node's 
  contextual information; all worker scripts are run in the audio processing 
  thread.</p>

<section>
<h2>The <dfn>AudioWorkerNode</dfn> Interface</h2>

<p>This interface represents an <a><code>AudioNode</code></a> which interacts 
  with a <a>Worker</a> thread to generate, process, or analyse audio directly. 
  The user creates a separate audio processing worker script, which is hosted 
  inside the AudioWorkerGlobalScope and runs inside the audio processing 
  thread, rather than the main UI thread.  The AudioWorkerNode represents the 
  processing node in the main processing thread's node graph; the 
  AudioWorkerGlobalScope represents the context in which the user's audio 
  processing script is run.</p>
<p>Nota bene that if the Web Audio implementation normally runs audio process 
  at higher than normal thread priority, utilizing AudioWorkerNodes may cause 
  demotion of the priority of the audio thread (since user scripts cannot be 
  run with higher than normal priority).</p>

<pre>
    numberOfInputs  : variable
    numberOfOutputs : variable

    channelCount = numberOfInputChannels;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>

<p>
<a>numberOfInputChannels</a> and <dfn>numberOfOutputChannels</a>
determine the number of input and output channels (and the number of channels 
present in the AudioBuffers passed to the AudioProcess event handler inside the
<a>AudioWorkerGlobalScope</a>). It is invalid for both
<code>numberOfInputChannels</code> and <code>numberOfOutputChannels</code> to
be zero.
</p>

<pre class="highlight">
    var node = context.createAudioWorker( "bitcrusher.js", numberOfInputChannels, numberOfOutputChannels);
</pre>

<dl title="interface AudioWorkerNode : AudioNode" class="idl">
  <dt>void terminate()</dt>
  <dd>The terminate() method, when invoked, must cause the 
    <a href="http://dev.w3.org/html5/workers/#terminate-a-worker">"terminate 
      a worker"</a> algorithm to be run on the worker with which the object 
      is associated.  This will cease any <a>AudioProcessEvent</a>s being
      dispatched to the Audio Worker, and will cause the destruction of the
      worker thread.  In practical terms, this means the node will disconnect itself from any downstream connections.</dd>
  <dt>void postMessage(any message, optional sequence&lt;Transferable> transfer)</dt>
  <dd>postMessage may be called to send a message to the Audio Worker, via the
    algorithm defined by <a href="http://dev.w3.org/html5/workers/#dom-worker-postmessage">
    the Worker specification</a>.</dd>
  <dt>attribute EventHandler onmessage</dt>
  <dd>The onmessage handler is called whenever the Audio Worker posts a 
    message back to the main thread.</dd>
  <dt>AudioParam addParameter(DOMString name, optional float defaultValue) </dt>
  <dd>
    <p>
      Causes a correspondingly-named read-only <a>AudioParam</a> to be 
      present on the <a>AudioWorkerNode</a>, and a correspondingly-named 
      read-only <a>Float32Array</a> to be present on the 
      <a><code>parameters</code></a> object exposed on the 
      <a>AudioProcessEvent</a> on subsequent audio processing events.  The 
      AudioParam may immediately have its scheduling methods called, its 
      .<a>value</a> set, or AudioNodes connected to it.</p>
    <p>The <code>name</code> parameter is the name used for the read-only 
      AudioParam added to the AudioWorkerNode, and the name used for the 
      read-only <code>Float32Array</code> that will be present on the 
      <a><code>parameters</code></a> object exposed on subsequent 
      <a>AudioProcessEvent</a>s.</p>
    <p>The <dfn
      id="dfn-defaultValue">defaultValue</dfn> parameter is the default value 
      for the <a>AudioParam</a>'s <a>value</a> attribute, as well as 
      therefore the default value that will appear in the Float32Array in the 
      worker script (if no other parameter changes or connections affect the 
      value).</p>
  </dd>
  <dt>void removeParameter(DOMString name) </dt>
  <dd>
    <p>
      Removes a previously-added parameter named <code>name</code> from the 
      <a>AudioWorkerNode</a>.  This will also remove the correspondingly-named 
      read-only <a>AudioParam</a> from the <a>AudioWorkerNode</a>, and will 
      remove the correspondingly-named read-only <a>Float32Array</a> from the 
      <a>AudioProcessEvent</a>'s <a><code>parameters</code></a> member on 
      subsequent audio processing events. A 
      NOT_FOUND_ERR exception must be thrown if no parameter with that name 
      exists on this node.</p>
    <p>The <code>name</code> parameter identifies the parameter to be 
      removed.</p>
  </dd>
</dl>
</dl>
<p>
  Note that <a>AudioWorkerNode</a> objects will also have read-only 
  AudioParam objects for each named parameter added via the 
  <code>addParameter</code> method.  As this is dynamic, it cannot be captured
  in IDL.
</p>
  
<!--<div title="AudioWorkerNode implements Worker" class="idl">-->
  <p>AudioWorkerNodes must implement the <a>Worker</a>
  interface for communication with the audio worker script.</p>
<!--</div>-->
</section>

<section>
<h2>The AudioWorkerGlobalScope Interface</h2>

<p>This interface is a <a><code>DedicatedWorkerGlobalScope</code></a>-derived 
  object representing the context in which an audio processing script is run; 
  it is designed to enable the generation, processing, and analysis of audio 
  data directly using JavaScript in a Worker thread. </p>

<p>
The <a><code>AudioWorkerGlobalScope</code></a> has an 
<dfn id="audioprocess-worker">audioprocess</dfn> event that is dispatched
synchronously to process audio frames.  
<a href="#audioprocess-worker"><code>audioprocess</code></a> events are only
dispatched if the <a><code>AudioWorkerNode</code></a> has at least one input or
one output connected.

<dl title="interface AudioWorkerGlobalScope : DedicatedWorkerGlobalScope" class="idl">
  <dt>attribute EventHandler onaudioprocess</dt>
  <dd>
    A property used to set the <code>EventHandler</code> (described in <cite>
    <a href="http://www.whatwg.org/specs/web-apps/current-work/#eventhandler">
    HTML</a></cite>[[!HTML]]) for the <a href="#audioprocess-worker">
    <code>audioprocess</code></a> event that is dispatched to
    <a><code>AudioWorkerGlobalScope</code></a> when the associated
    <a><code>AudioWorkerNode</code></a> is connected. An event of type
    <a><code>AudioProcessEvent</code></a> will be dispatched to the event 
    handler.
  </dd>
  <dt>readonly attribute float sampleRate</dt>
  <dd>
    The sample rate of the host <a>AudioContext</a> (since inside the 
    <a>Worker</a> scope, the user will not have direct access to the 
    <a>AudioContext</a>.
  </dd>
</dl>
</section>

<section class="informative">
  <h3>Audio Worker Examples</h3>
  <section>
    <h4>A Bitcrusher Node</h4>
      <p>Bitcrushing is a mechanism by which the audio quality of an audio 
        stream is reduced - both by quantizing the value (simulating lower 
        bit-depth in integer-based audio), and by quantizing in time 
        (simulating a lower digital sample rate).  This example shows how to 
        use AudioParams (in this case, treated as a-rate) inside an 
        AudioWorker.</p>

    <h5>Main file javascript</h5>
    <pre class="highlight">var bitcrusherNode = audioContext.createAudioWorker("bitcrusher_worker.js", 1, 1);

// Custom parameter - number of bits to crush down to - default 8
bitcrusherNode.addParameter( "bits", 8 );

// Custom parameter - frequency reduction, 0-1, default 0.5
bitcrusherNode.addParameter( "frequencyReduction", 0.5 );</pre>
    <h5>bitcrusher_worker.js</h5>
    <pre class="highlight">var phaser = 0;
var lastDataValue = 0;

onaudioprocess= function (e) {
  for (var channel=0; channel&lt;e.inputBuffers.length; channel++) {
    var inputBuffer = e.inputBuffers[channel];
    var outputBuffer = e.outputBuffers[channel];
    var bufferLength = inputBuffer.length;
    var bitsArray = e.parameters.bits;
    var frequencyReductionArray = e.parameters.frequencyReduction;

    for (var i=0; i&lt;bufferLength; i++) {
      var bits = bitsArray ? bitsArray[i] : 8;
      var frequencyReduction = frequencyReductionArray ? frequencyReductionArray[i] : 0.5;

      var step = Math.pow(1/2, bits);
      phaser += frequencyReduction;
      if (phaser >= 1.0) {
          phaser -= 1.0;
          lastDataValue = step * Math.floor(inputBuffer[i] / step + 0.5);
      }
      outputBuffer[i] = lastDataValue;
    }
  }
};</pre>
  </section>
  <section>
    <h4>A Volume Meter and Clip Detector</h4>
    <p>Another common need is a clip-detecting volume meter.  This example 
      shows how to communicate basic parameters (that do not need AudioParam 
      scheduling) across to a Worker, as well as communicating data back to 
      the main thread.</p>

    <h5>Main file javascript</h5>
    <pre class="highlight">var vuNode = audioContext.createAudioWorker("vu_meter_worker.js", 1, 1);

// This handles communication back from the volume meter
vuNode.onmessage = function (event) {
  if (event.data instanceof Object ) {
    if (event.data.hasOwnProperty("clip")
      this.clip = event.data.clip;
    if (event.data.hasOwnProperty("volume")
      this.volume = event.data.volume;
  }
}

// Set up some configuration parameters
vuNode.postMessage( 
  { "smoothing": 0.9,   // Smoothing parameter
    "clipLevel": 0.9,   // Level to consider "clipping"
    "clipLag": 750,     // How long to keep "clipping" lit up after clip (ms)
    "updating": 90      // How frequently to update volume and clip param (ms)
  });

// Set up volume and clip attributes.  These will be updated by our onmessage.
vuNode.volume = 0;
vuNode.clip = false;</pre>

    <h5>vu_meter_worker.js</h5>
    <pre class="highlight">// how many samples between updates - default 100ms
this.timeToNextUpdate = 0.1 * this.sampleRate;

// This just handles setting attribute values
onmessage = function ( event ) {
  if (event.data instanceof Object ) {
    if (event.data.hasOwnProperty("smoothing")
      this.smoothing = event.data.smoothing;
    if (event.data.hasOwnProperty("clipLevel")
      this.clipLevel = event.data.clipLevel;
    if (event.data.hasOwnProperty("clipLag")
      this.clipLag = event.data.clipLag / 1000;  // convert to seconds
    if (event.data.hasOwnProperty("updating")    // convert to samples
      this.updatingInterval = event.data.updating * this.sampleRate / 1000 ;
  }
};

onaudioprocess = function ( event ) {
  var buf = event.inputBuffers[0];  // For simplicity, this example is only mono
  var bufLength = buf.length;
  var sum = 0;
  var x;

  // Do a root-mean-square on the samples: sum up the squares...
  for (var i=0; i&lt;bufLength; i++) {
    x = buf[i];
    if (Math.abs(x)>=this.clipLevel) {
      this.clipping = true;
      this.unsentClip = true;  // Make sure, for every clip, we send a message.
      this.lastClip = event.playbackTime + (i/this.sampleRate);
    }
    sum += x * x;
  }

  // ... then take the square root of the sum.
  var rms =  Math.sqrt(sum / bufLength);

  // Now smooth this out with the smoothing factor applied
  // to the previous sample - take the max here because we
  // want "fast attack, slow release."
  this.volume = Math.max(rms, this.volume*this.smoothing);
  if (this.clipping &amp;&amp; (!this.unsentClip) &amp;&amp; (event.playbackTime > (this.lastClip + clipLag)))
    this.clipping = false;

  // How long has it been since our last update?
  this.timeToNextUpdate -= this.last
  if (this.timeToNextUpdate&lt;0) {
    this.timeToNextUpdate = this.updatingInterval;
    this.postMessage(
      { "volume": this.volume,
        "clip": this.clipping });
    this.unsentClip = false;
  }
};</pre>
    </section>
  </section>
</section>

<section class="informative">
<h2>The ScriptProcessorNode Interface - DEPRECATED</h2>

<p>This interface is an <a><code>AudioNode</code></a> which can generate, process, or analyse audio
directly using JavaScript.  This node type is deprecated, to be replaced by the <a>AudioWorkerNode</a>; this text is only here for informative purposes until implementations remove this node type.</p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = numberOfInputChannels;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>

<p>
The <a><code>ScriptProcessorNode</code></a> is constructed with a <dfn>bufferSize</dfn> which must
be one of the following values: 256, 512, 1024, 2048, 4096, 8192, 16384.  This
value controls how frequently the <a href="#audioprocess-spnode">audioprocess
</a> event is dispatched and how many sample-frames need to be processed each
call.  <a href="#audioprocess-spnode"><code>audioprocess</code></a> events are
only dispatched if the <a><code>ScriptProcessorNode</code></a> has at least one
input or one output connected.  Lower numbers for <a
href="#widl-ScriptProcessorNode-bufferSize">bufferSize</a> will result in a
lower (better) <a href="#latency">latency</a>. Higher numbers will be necessary
to avoid audio breakup and <a href="#audio-glitching">glitches</a>.  This value
will be picked by the implementation if the bufferSize argument to
<code>createScriptProcessor</code> is not passed in, or is set to 0.
</p>

<p>
<dfn>numberOfInputChannels</dfn> and <dfn>numberOfOutputChannels</dfn>
determine the number of input and output channels. It is invalid for both
<code>numberOfInputChannels</code> and <code>numberOfOutputChannels</code> to
be zero.
</p>
<pre class=highlight>
    var node = context.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);
</pre>

<dl title="interface ScriptProcessorNode : AudioNode" class="idl">
  <dt>attribute EventHandler onaudioprocess</dt>
  <dd>
    A property used to set the <code>EventHandler</code> (described in <cite>
    <a href="http://www.whatwg.org/specs/web-apps/current-work/#eventhandler">
    HTML</a></cite>[[!HTML]]) for the <a
  href="#audioprocess-spnode"><code>audioprocess</code></a> event that is
dispatched to <a><code>ScriptProcessorNode</code></a> node types. An event of
type <a><code>AudioProcessingEvent</code></a> will be dispatched to the event
handler.
  </dd>
  <dt> readonly attribute long bufferSize </dt>
  <dd>
    The size of the buffer (in sample-frames) which needs to be processed each
    time <code>onaudioprocess</code> is called. Legal values are (256, 512,
    1024, 2048, 4096, 8192, 16384).
  </dd>
</dl>
</section>

<section>
<h2>The AudioProcessEvent Interface</h2>

<p>
This is an <code>Event</code> object which is dispatched to
<a><code>AudioWorkerGlobalScope</code></a> objects to perform processing.
</p>

<p>
  The event handler processes audio from the input (if any) by accessing the
  audio data from the <code>inputBuffers</code> attribute. The audio data which
  is the result of the processing (or the synthesized data if there are no
  inputs) is then placed into the <code>outputBuffers</code>.
</p>

<dl title="interface AudioProcessEvent : Event" class="idl">
    <dt> readonly attribute double playbackTime </dt>
    <dd>
      The time when the audio will be played in the same time coordinate system
      as the <a><code>AudioContext</code></a>'s <a href="#widl-AudioContext-currentTime">currentTime</a>.
      <code>playbackTime</code> allows for very
      tight synchronization between processing directly in JavaScript with the
      other events in the context's rendering graph.
    </dd>
    <dt> readonly attribute Float32Array[] inputBuffers </dt>
    <dd>
      An Array of Float32Arrays, one per channel, containing the input audio 
      buffer with input data.  The number of channels will be equal to the 
      <code>numberOfInputChannels</code> parameter of the createAudioWorker() 
      method.  It is expected that the event object, the Array and the input 
      and output buffers may be reused by the processing system, in order to 
      minimize memory churn; it is not recommended to maintain global handles
      to them.
      </dd>
    <dt> readonly attribute Float32Array[] outputBuffers </dt>
    <dd>
      An Array of Float32Arrays, one per channel, containing the output audio 
      buffer.  The number of channels will be equal to the 
      <code>numberOfOutputChannels</code> parameter of the createAudioWorker() 
      method.  It is expected that the event object, the Array and the input 
      and output buffers may be reused by the processing system, in order to 
      minimize memory churn; it is not recommended to maintain global handles
      to them.
    </dd>
    <dt> readonly attribute object parameters</dt>
    <dd>This object attribute exposes a correspondingly-named 
      read-only <a>Float32Array</a> for each parameter that has been added 
      via <a>addParameter</a>.  As this is dynamic, this cannot be captured 
      in IDL.  The length of this Float32Array will correspond to the length 
      of the inputBuffer.  The contents of this Float32Array will be the 
      values to be used for the AudioParam at the corresponding points in 
      time.  It is expected that this Float32Array will be reused by the 
      audio engine.</dd>
</dl>
</section>

<section class="informative">
<h2>The AudioProcessingEvent Interface - DEPRECATED</h2>

<p>
This is an <code>Event</code> object which is dispatched to
<a><code>ScriptProcessorNode</code></a> nodes.  It will be removed 
when the ScriptProcessorNode is removed, as the replacement 
<a>AudioWorker</a> uses the <a>AudioProcessEvent</a>.
</p>

<p>
  The event handler processes audio from the input (if any) by accessing the
  audio data from the <code>inputBuffer</code> attribute. The audio data which
  is the result of the processing (or the synthesized data if there are no
  inputs) is then placed into the <code>outputBuffer</code>.
</p>

<dl title="interface AudioProcessingEvent : Event" class="idl">
    <dt> readonly attribute double playbackTime </dt>
    <dd>
      The time when the audio will be played in the same time coordinate system
      as the <a><code>AudioContext</code></a>'s <a href="#widl-AudioContext-currentTime">currentTime</a>.
      <code>playbackTime</code> allows for very
      tight synchronization between processing directly in JavaScript with the
      other events in the context's rendering graph.
    </dd>
    <dt> readonly attribute AudioBuffer inputBuffer </dt>
    <dd>
      An AudioBuffer containing the input audio data.  It will have a number of
      channels equal to the <code>numberOfInputChannels</code> parameter of the
      createScriptProcessor() method.  This AudioBuffer is only valid while in
      the scope of the <code>onaudioprocess</code> function.  Its values will be
      meaningless outside of this scope.
      </dd>
    <dt> readonly attribute AudioBuffer outputBuffer </dt>
    <dd>
      An AudioBuffer where the output audio data should be written.  It will
      have a number of channels equal to the <code>numberOfOutputChannels</code>
      parameter of the createScriptProcessor() method.  Script code within the
      scope of the <code>onaudioprocess</code> function is expected to modify
      the <code>Float32Array</code> arrays representing channel data in this
      AudioBuffer.  Any script modifications to this AudioBuffer outside of this
      scope will not produce any audible effects.
    </dd>
</dl>
</section>

<section>
<h2>The PannerNode Interface</h2>

<p>
This interface represents a processing node which
<a href="#Spatialization">positions / spatializes</a> an incoming audio
stream in three-dimensional space. The spatialization is in relation to the <a
>AudioContext</a>'s <a><code>AudioListener</code></a> (<code>listener</code> attribute). </p>

<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = 2;
    channelCountMode = "clamped-max";
    channelInterpretation = "speakers";
</pre>

<p>
  The input of this node is either mono (1 channel) or stereo (2 channels) and cannot be increased.  Connections from nodes with fewer or more channels will be <a href="#channel-up-mixing-and-down-mixing">up-mixed or down-mixed appropriately</a>, but a NOT_SUPPORTED_ERR will be thrown if an attempt is made to set channelCount to a value great than 2 or if channelCountMode is set to "max".
</p>

<p>
The output of this node is hard-coded to stereo (2 channels) and
<em>currently</em> cannot be configured.
</p>

<p>
  The <a><code>PanningModelType</code></a> enum determines which spatialization algorithm will
  be used to position the audio in 3D space. The default is "HRTF".
</p>
<dl title="enum PanningModelType" class=idl>
  <dt>equalpower</dt>
  <dd>
    A simple and efficient spatialization algorithm using equal-power panning.
  </dd>
  <dt>HRTF</dt>
  <dd>
    A higher quality spatialization algorithm using a convolution with measured
    impulse responses from human subjects. This panning method renders stereo
    output.
  </dd>
</dl>

<p>
The <a><code>DistanceModelType</code></a> enum determines which algorithm will be used to
reduce the volume of an audio source as it moves away from the listener.  The
default is "inverse".
</p>
<dl title="enum DistanceModelType" class=idl>
  <dt>linear</dt>
  <dd>
  A linear distance model which calculates <em>distanceGain</em> according to:
  <pre>
    1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance)
  </pre>
  </dd>
  <dt>inverse</dt>
  <dd>
  <p>An inverse distance model which calculates <em>distanceGain</em> according to: </p>
  <pre>
    refDistance / (refDistance + rolloffFactor * (distance - refDistance))
  </pre>
  </dd>
  <dt>exponential</dt>
  <dd><p>An exponential distance model which calculates <em>distanceGain</em> according to: </p>
  <pre>
    pow(distance / refDistance, -rolloffFactor)
  </pre>
  </dd>
</dl>

<dl title="interface PannerNode : AudioNode" class=idl>

    <!--<dt>// Default for stereo is HRTF</dt>-->
    <dt>attribute PanningModelType panningModel</dt>
    <dd> Specifies the panning model used by this <a><code>PannerNode</code></a>. Defaults to
    <a><code>"HRTF"</code></a>.</dd>

    <!--<dt> // Uses a 3D cartesian coordinate system </dt>-->
    <dt>void setPosition(float x, float y, float z)</dt>
    <dd>
    <p>
      Sets the position of the audio source relative to the
      <a><code>listener</code></a> attribute. A 3D cartesian coordinate system is used.
    </p>
    <p>
      The <code>x, y, z</code> parameters represent the coordinates
      in 3D space.
    </p>
    <p>
      The default value is (0,0,0)
    </p>
    </dd>
    <dt>void setOrientation(float x, float y, float z)</dt>
    <dd>
    <p>
      Describes which direction the audio source is pointing in the 3D
      cartesian coordinate space. Depending on how directional the sound is
      (controlled by the <b>cone</b> attributes), a sound pointing away from
      the listener can be very quiet or completely silent.
    </p>
    <p>
      The <code>x, y, z</code> parameters represent a direction
      vector in 3D space.
    </p>
    <p>
      The default value is (1,0,0)
    </p>
    </dd>
    <dt>void setVelocity(float x, float y, float z)</dt>
    <dd>
    <p>
      Sets the velocity vector of the audio source. This vector controls both
      the direction of travel and the speed in 3D space. This velocity relative
      to the listener's velocity is used to determine how much doppler shift
      (pitch change) to apply.  The units used for this vector is <em>meters /
      second</em> and is independent of the units used for position and
      orientation vectors.
    </p>
    <p>
      The <code>x, y, z</code> parameters describe a direction
      vector indicating direction of travel and intensity.
    </p>
    <p>
      The default value is (0,0,0)
    </p>
    </dd>

    <!--<dt> // Distance model and attributes </dt>-->
    <dt>attribute DistanceModelType distanceModel</dt>
    <dd> Specifies the distance model used by this
    <a><code>PannerNode</code></a>. Defaults to <a><code>"inverse"</code></a>.
    </dd>
    <dt>attribute float refDistance</dt>
    <dd>
      A reference distance for reducing volume as source move further
      from the listener.  The default value is 1.
    </dd>
    <dt>attribute float maxDistance</dt>
    <dd>
      The maximum distance between source and listener, after which the
      volume will not be reduced any further.  The default value is 10000.
    </dd>
    <dt>attribute float rolloffFactor</dt>
    <dd>
      Describes how quickly the volume is reduced as source moves away from
      listener.  The default value is 1.
    </dd>


    <!--<dt> // Directional sound cone </dt>-->
    <dt>attribute float coneInnerAngle</dt>
    <dd>
      A parameter for directional audio sources, this is an angle, in degrees, inside
      of which there will be no volume reduction.  The default value is 360.
    </dd>
    <dt>attribute float coneOuterAngle</dt>
    <dd>
      A parameter for directional audio sources, this is an angle, in degrees, outside
      of which the volume will be reduced to a constant value of
      <a><code>coneOuterGain</code></a>.  The default value is 360.
    </dd>
    <dt>attribute float coneOuterGain</dt>
    <dd>
      A parameter for directional audio sources, this is the amount of volume
      reduction outside of the <a><code>coneOuterAngle</code></a>.  The default value is 0.
    </dd>
</dl>

</section>

<section>
<h2 id="AudioListener">The AudioListener Interface</h2>

<p>
This interface represents the position and orientation of the person
listening to the audio scene. All <a><code>PannerNode</code></a> objects
spatialize in relation to the <a><code>AudioContext</code></a>'s <a href="widl-AudioContext-listener"><code>listener</code></a>. See <a
href="#Spatialization">the Spatialization/Panning section</a> for more details about
spatialization.
</p>

<dl title="interface AudioListener" class="idl">
    <dt> attribute float dopplerFactor </dt>
    <dd>
      A constant used to determine the amount of pitch shift to use when
      rendering a doppler effect.  The default value is 1.
    </dd>
    <dt> attribute float speedOfSound </dt>
    <dd>
      The speed of sound used for calculating doppler shift. The default value
      is 343.3.
    </dd>

    <!--<dt> // Uses a 3D cartesian coordinate system </dt>-->
    <dt> void setPosition(float x, float y, float z) </dt>
    <dd>
      <p>
        Sets the position of the listener in a 3D cartesian coordinate
        space. <a><code>PannerNode</code></a> objects use this position relative to
        individual audio sources for spatialization.
      </p>
      <p>
        The <code>x, y, z</code> parameters represent
        the coordinates in 3D space.
      </p>
      <p>
        The default value is (0,0,0)
      </p>
    </dd>
    <dt> void setOrientation(float x, float y, float z, float xUp, float yUp, float zUp) </dt>
    <dd>
      <p>
        Describes which direction the listener is pointing in the 3D cartesian
        coordinate space. Both a <b>front</b> vector and an <b>up</b> vector are
        provided.  In simple human terms, the <b>front</b> vector represents
        which direction the person's nose is pointing.  The <b>up</b> vector
        represents the direction the top of a person's head is pointing.  These
        values are expected to be linearly independent (at right angles to each
        other).  For normative requirements of how these values are to be
        interpreted, see the <a href="#Spatialization">spatialization
        section</a>.
      </p>
      <p>
        The <code>x, y, z</code> parameters represent a <b>front</b> direction
        vector in 3D space, with the default value being (0,0,-1).
      </p>
      <p>
        The <code>xUp, yUp, zUp</code> parameters represent an <b>up</b> direction
        vector in 3D space, with the default value being (0,1,0).
      </p>
    </dd>
    <dd> void setVelocity(float x, float y, float z) </dd>
    <dd>
      <p>
        Sets the velocity vector of the listener. This vector controls both the
        direction of travel and the speed in 3D space. This velocity relative to
        an audio source's velocity is used to determine how much doppler shift
        (pitch change) to apply.  The units used for this vector is <em>meters /
        second</em> and is independent of the units used for position and
      orientation vectors.
      </p>
      <p>
        The <code>x, y, z</code> parameters describe a direction vector
        indicating direction of travel and intensity.
      </p>
      <p>The default value is (0,0,0) </p>
    </dd>
</dl>

</section>

<section>
<h2 id="ConvolverNode">The ConvolverNode Interface</h2>

<p>
  This interface represents a processing node which applies a <a
    href="#Convolution">linear convolution effect</a> given an impulse
  response.  Normative requirements for multi-channel convolution matrixing are
  described <a href="#Convolution-reverb-effect">here</a>.
</p>

<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = 2;
    channelCountMode = "clamped-max";
    channelInterpretation = "speakers";
</pre>

<p>
  The input of this node is either mono (1 channel) or stereo (2 channels) and cannot be increased.  Connections from nodes with fewer or more channels will be <a href="#channel-up-mixing-and-down-mixing">up-mixed or down-mixed appropriately</a>, but a NOT_SUPPORTED_ERR will be thrown if an attempt is made to set channelCount to a value great than 2 or if channelCountMode is set to "max".
</p>

<dl title="interface ConvolverNode : AudioNode" class="idl">
  <dt> attribute AudioBuffer? buffer </dt>
    <dd>
      A mono, stereo, or 4-channel <a><code>AudioBuffer</code></a> containing
      the (possibly multi-channel) impulse response used by the
      <a><code>ConvolverNode</code></a>.  The <code>AudioBuffer</code> must have
      1, 2, or 4 channels or a NOT_SUPPORTED_ERR exception MUST be thrown.  This
      <a><code>AudioBuffer</code></a> must be of the same sample-rate as the
      <a><code>AudioContext</code></a> or an NOT_SUPPORTED_ERR exception MUST be
      thrown.  At the time when this attribute is set, the <em>buffer</em> and
      the state of the <em>normalize</em> attribute will be used to configure
      the <a><code>ConvolverNode</code></a> with this impulse response having
      the given normalization.  The initial value of this attribute is null.
    </dd>
  <dt> attribute boolean normalize </dt>
    <dd>
      <p>
        Controls whether the impulse response from the buffer will be scaled by an
        equal-power normalization when the <code>buffer</code> atttribute is set.
        Its default value is <code>true</code> in order to achieve a more uniform
        output level from the convolver when loaded with diverse impulse
        responses.  If <code>normalize</code> is set to <code>false</code>, then
        the convolution will be rendered with no pre-processing/scaling of the
        impulse response.  Changes to this value do not take effect until the next
        time the <em>buffer</em> attribute is set.
      </p>
      <p>
        If the <em>normalize</em> attribute is false when the <em>buffer</em>
        attribute is set then the <a><code>ConvolverNode</code></a> will perform a linear convolution
        given the exact impulse response contained within the <em>buffer</em>.
      </p>
      <p>
        Otherwise, if the <em>normalize</em> attribute is true when the
        <em>buffer</em> attribute is set then the <a><code>ConvolverNode</code></a> will
        first perform a scaled RMS-power analysis of the audio data contained
        within <em>buffer</em> to calculate a <em>normalizationScale</em> given
        this algorithm:
      </p>

      <pre class="highlight">

float calculateNormalizationScale(buffer)
{
    const float GainCalibration = 0.00125;
    const float GainCalibrationSampleRate = 44100;
    const float MinPower = 0.000125;

    // Normalize by RMS power.
    size_t numberOfChannels = buffer->numberOfChannels();
    size_t length = buffer->length();

    float power = 0;

    for (size_t i = 0; i &lt; numberOfChannels; ++i) {
        float* sourceP = buffer->channel(i)->data();
        float channelPower = 0;

        int n = length;
        while (n--) {
            float sample = *sourceP++;
            channelPower += sample * sample;
        }

        power += channelPower;
    }

    power = sqrt(power / (numberOfChannels * length));

    // Protect against accidental overload.
    if (isinf(power) || isnan(power) || power &lt; MinPower)
        power = MinPower;

    float scale = 1 / power;

    // Calibrate to make perceived volume same as unprocessed.
    scale *= GainCalibration;

    // Scale depends on sample-rate.
    if (buffer->sampleRate())
        scale *= GainCalibrationSampleRate / buffer->sampleRate();

    // True-stereo compensation.
    if (buffer->numberOfChannels() == 4)
        scale *= 0.5;

    return scale;
}
      </pre>

      <p>
        During processing, the ConvolverNode will then take this calculated
        <em>normalizationScale</em> value and multiply it by the result of the
        linear convolution resulting from processing the input with the impulse
        response (represented by the <em>buffer</em>) to produce the final output.
        Or any mathematically equivalent operation may be used, such as
        pre-multiplying the input by <em>normalizationScale</em>, or
        pre-multiplying a version of the impulse-response by
        <em>normalizationScale</em>.
      </p>
    </dd>
</dl>
</section>

<section>
<h2>The AnalyserNode Interface</h2>

<p>
  This interface represents a node which is able to provide real-time frequency
  and time-domain analysis information. The audio stream will be passed
  un-processed from input to output.
</p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1    <em>Note that this output may be left unconnected.</em>

    channelCount = 1;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>

<dl title="interface AnalyserNode : AudioNode" class="idl">
    <!--<dt> // Real-time frequency-domain data </dt>-->
    <dt> void getFloatFrequencyData() </dt>
    <dd>
      <p>
        Copies the <a>current frequency data</a> into the passed floating-point
        array. If the array has fewer elements than the <a><code>frequencyBinCount</code></a>, the
        excess elements will be dropped. If the array has more elements than
        the <a><code>frequencyBinCount</code></a>, the excess elements will be ignored.
      </p>
      <dl class="parameters">
        <dt>Float32Array array</dt>
        <dd>
          This parameter is where the frequency-domain analysis data will be
          copied.
        </dd>
      </dl>
    </dd>
    <dt> void getByteFrequencyData() </dt>
    <dd>
      <p>
        Copies the <a>current frequency data</a> into the passed unsigned byte
        array. If the array has fewer elements than the <a><code>frequencyBinCount</code></a>, the
        excess elements will be dropped. If the array has more elements than
        the <a><code>frequencyBinCount</code></a>, the excess elements will be ignored.
      </p>
      <dl class="parameters">
        <dt>Uint8Array array</dt>
        <dd>
          This parameter is where the frequency-domain analysis data will be
          copied.
        </dd>
      </dl>
    </dd>

    <!--<dt>// Real-time waveform data </dt>-->
    <dt> void getFloatTimeDomainData() </dt>
    <dd>
      <p>
        Copies the current time-domain (waveform) data into the passed
        floating-point array. If the array has fewer elements than the value of
        <a><code>fftSize</code></a>, the excess elements will be dropped. If the array has
        more elements than <a><code>fftSize</code></a>, the excess elements will be ignored.
      </p>
      <dl class="parameters">
        <dt>Float32Array array</dt>
        <dd>
          This parameter is where the time-domain sample data will be copied.
        </dd>
      </dl>
    </dd>

    <dt> void getByteTimeDomainData() </dt>
    <dd>
      <p>
        Copies the current time-domain (waveform) data into the passed unsigned
        byte array. If the array has fewer elements than the value of
        <a><code>fftSize</code></a>, the excess elements will be dropped. If the array has
        more elements than <a><code>fftSize</code></a>, the excess elements will be ignored.
      </p>
      <dl class="parameters">
        <dt>Uint8Array array</dt>
        <dd>
          This parameter is where the time-domain sample data will be copied.
        </dd>
      </dl>
    </dd>

    <dt> attribute unsigned long fftSize </dt>
    <dd>
      The size of the FFT used for frequency-domain analysis. This must be a
      non-zero power of two in the range 32 to 2048, otherwise an INDEX_SIZE_ERR
      exception MUST be thrown.

      The default value is 2048.
    </dd>
    <dt> readonly attribute unsigned long frequencyBinCount </dt>
    <dd>
      Half the FFT size.
    </dd>

    <dt> attribute float minDecibels </dt>
    <dd>
      The minimum power value in the scaling range for the FFT analysis data for
      conversion to unsigned byte values.  The default value is -100.  If the
      value of this attribute is set to a value more than or equal to
      <code>maxDecibels</code>, an INDEX_SIZE_ERR exception MUST be thrown.
    </dd>
    <dt> attribute float maxDecibels </dt>
  <dd>
    The maximum power value in the scaling range for the FFT analysis data for
    conversion to unsigned byte values.  The default value is -30.  If the value
    of this attribute is set to a value less than or equal to
    <code>minDecibels</code>, an INDEX_SIZE_ERR exception MUST be thrown.
  </dd>

    <dt> attribute float smoothingTimeConstant </dt>
    <dd>
      A value from 0 -&gt; 1 where 0 represents no time averaging
      with the last analysis frame.
      The default value is 0.8.
      If the value of this attribute is set to a value less than 0 or more than 1,
      an INDEX_SIZE_ERR exception MUST be thrown.
    </dd>
</dl>

<section>
<h3>FFT Windowing and smoothing over time</h3>
When the <dfn id="current-frequency-data">current frequency data</dfn> are
computed, the following operations are to be performed:
<ol>
  <li> <a href="#blackman-window">Apply a Blackman window</a> to the time domain input data </li>
  <li> Apply a Fourier tranform to the windowed time domain input data to get imaginary and real frequency data </li>
  <li> <a href="#smoothing-over-time">Smooth over time</a> the frequency domain data</li>
</ol>

<dfn id="blackman-window">Applying a Blackman window</dfn> consists in the
following operation on the input time domain data <code>buffer</code>:

    <pre class="highlight">
function blackmanWindow(buffer) {
  var alpha = 0.16;
  var a0 = 0.5 * (1.0 - alpha);
  var a1 = 0.5;
  var a2 = 0.5 * alpha;

  for (var i = 0; i &lt; buffer.length; i++) {
    var x = i / buffer.length;
    buffer[i] *= a0 - a1 * Math.cos(2 * Math.PI * x) + a2 * Math.cos(4 * Math.PI * x);
  }
}
    </pre>

<dfn id="smoothing-over-time">Smoothing over time</dfn> frequency data consists
in the following operation:
<ul>
<li>
  Let <code>fftSize</code> be the value of <a
    href="#widl-AnalyserNode-fftSize"><code>fftSize</code></a> for this
  <a>AnalyserNode</a>.
</li>
<li>
  Let <code>outputBuffer</code> be an array that contains
  the frequency data that will be made available to the author via <a
    href="#widl-AnalyserNode-getFloatFrequencyData-void-Float32Array-array"><code>getFloatFrequencyData</code></a>,
  or <a
  href="#widl-AnalyserNode-getByteFrequencyData-void-Uint8Array-array"><code>getByteFrequencyData</code></a>.
</li>
<li>
  Let <code>lastOutputBuffer</code> be the result of this operation on the
  <a>previous block</a>. The <dfn>previous block</dfn> is defined as being the
  buffer returned by the previous <a href="#smoothing-over-time">smoothing over
  time</a> operation, or an array of <code>fftSize</code> zeros if this is the
  first time we are <a href="#smoothing-over-time">smoothing over time</a>.
</li>
<li>
  Let <code>smoothingConstant</code> be the value of the <a
  href="#widl-AnalyserNode-smoothingTimeConstant"><code>smoothingTimeConstant</code></a> attribute for
  this <a><code>AnalyserNode</code></a>.
</li>
<li>
  Let <code>real</code> and <code>imag</code> be two arrays of length
  <code>fftSize</code>, that contain the result of the previously applied Fourier
  transform.
</li>
</ul>

<pre class="highlight">
  function smoothingOverTime(outputBuffer, lastOutputBuffer,
                             smoothingConstant,
                             real, imag, fftSize) {
    for (var i = 0; i &lt; outputBuffer.length; i++) {
      var magnitude = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / fftSize;
      outputBuffer[i] = smoothingTimeConstant * lastOutputBuffer[i] + (1.0 - smoothingTimeConstant) * magnitude;
    }
  }
</pre>

</section>
</section>

<section>
<h2>The ChannelSplitterNode Interface</h2>

<p>
  The <code>ChannelSplitterNode</code> is for use in more advanced applications
  and would often be used in conjunction with <a><code>ChannelMergerNode</code></a>.
</p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : Variable N (defaults to 6) // number of "active" (non-silent) outputs is determined by number of channels in the input

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>

<p>
  This interface represents an <a><code>AudioNode</code></a> for accessing the individual channels
  of an audio stream in the routing graph. It has a single input, and a number
  of "active" outputs which equals the number of channels in the input audio
  stream.  For example, if a stereo input is connected to an
  <a><code>ChannelSplitterNode</code></a> then the number of active outputs will be two
  (one from the left channel and one from the right). There are always a total
  number of N outputs (determined by the <code>numberOfOutputs</code> parameter
  to the <a><code>AudioContext</code></a> method <a
    href="#widl-AudioContext-createChannelSplitter-ChannelSplitterNode-unsigned-long-numberOfOutputs"><code>createChannelSplitter()</code></a>),
  The default number is 6 if this value is not provided. Any outputs which are
  not "active" will output silence and would typically not be connected to
  anything.
</p>

<h3>Example:</h3>
<figure>
  <img alt="channel splitter" src="images/channel-splitter.png" />
  <figcaption>A diagram of a ChannelSplitter</figcaption>
</figure>

<p>
  Please note that in this example, the splitter does <b>not</b> interpret the
  channel identities (such as left, right, etc.), but simply splits out channels
  in the order that they are input.
</p>

<p>
  One application for <code>ChannelSplitterNode</code> is for doing "matrix
  mixing" where individual gain control of each channel is desired.
</p>

<dl title="interface ChannelSplitterNode : AudioNode" class="idl">
</dl>
</section>

<section>
<h2>The ChannelMergerNode Interface</h2>

<p>
  The <a><code>ChannelMergerNode</code></a> is for use in more advanced applications
  and would often be used in conjunction with <a><code>ChannelSplitterNode</code></a>.
</p>
<pre>
  numberOfInputs  : Variable N (default to 6)  // number of connected inputs may be less than this
  numberOfOutputs : 1

  channelCountMode = "max";
  channelInterpretation = "speakers";
</pre>

<p>
  This interface represents an <a><code>AudioNode</code></a> for combining channels from
  multiple audio streams into a single audio stream. It has a variable number of
  inputs (defaulting to 6), but not all of them need be connected. There is a
  single output whose audio stream has a number of channels equal to the sum of
  the numbers of channels of all the connected inputs. For example, if an
  <a><code>ChannelMergerNode</code></a> has two connected inputs (both stereo), then the
  output will be four channels, the first two from the first input and the
  second two from the second input. In another example with two connected inputs
  (both mono), the output will be two channels (stereo), with the left channel
  coming from the first input and the right channel coming from the second
  input.
</p>

<h3 id="example-2">Example:</h3>
<figure>
  <img alt="channel merger" src="images/channel-merger.png">
  <figcaption>A diagram of ChannelMerger</figcaption>
</figure>

<p>
  Please note that in this example, the merger does <b>not</b> interpret the
  channel identities (such as left, right, etc.), but simply combines channels
  in the order that they are input.
</p>


<p>
  Be aware that it is possible to connect an <a><code>ChannelMergerNode</code></a> in
  such a way that it outputs an audio stream with a large number of channels
  greater than the maximum supported by the audio hardware. In this case where
  such an output is connected to the <a><code>AudioContext</code></a>
  <a href="#widl-AudioContext-destination"><code>destination</code></a> (the
  audio hardware), then the extra channels will be ignored.  Thus, the
  <a><code>ChannelMergerNode</code></a> should be used in situations where the number of
  channels is well understood.
</p>

<dl title="interface ChannelMergerNode : AudioNode" class="idl">
</dl>
</section>

<section>
<h2>The DynamicsCompressorNode Interface</h2>

<p>
  <a><code>DynamicsCompressorNode</code></a> is an <a><code>AudioNode</code></a>
  processor implementing a dynamics compression effect.
</p>

<p>
  Dynamics compression is very commonly used in musical production and game
  audio. It lowers the volume of the loudest parts of the signal and raises the
  volume of the softest parts. Overall, a louder, richer, and fuller sound can
  be achieved. It is especially important in games and musical applications
  where large numbers of individual sounds are played simultaneous to control
  the overall signal level and help avoid clipping (distorting) the audio output
  to the speakers.
</p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = 2;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>

<dl title="interface DynamicsCompressorNode : AudioNode" class="idl">
  <dt> readonly attribute AudioParam threshold </dt>
  <dd>
    The decibel value above which the compression will start taking effect.  Its
    default <code>value</code> is -24, with a nominal range of -100 to 0.
  </dd>
  <dt> readonly attribute AudioParam knee </dt>
  <dd>
    A decibel value representing the range above the threshold where the
    curve smoothly transitions to the "ratio" portion. Its default
    <code>value</code> is 30, with a nominal range of 0 to 40.
  </dd>
  <dt> readonly attribute AudioParam ratio </dt>
  <dd>
    The amount of dB change in input for a 1 dB change in output. Its default
    <code>value</code> is 12, with a nominal range of 1 to 20.
  </dd>
  <dt> readonly attribute float reduction </dt>
  <dd>
    A read-only decibel value for metering purposes, representing the current
    amount of gain reduction that the compressor is applying to the signal. If
    fed no signal the value will be 0 (no gain reduction).
  </dd>
  <dt> readonly attribute AudioParam attack </dt>
  <dd>
    The amount of time (in seconds) to reduce the gain by 10dB.   Its default
    <code>value</code> is 0.003, with a nominal range of 0 to 1.
  </dd>
  <dt> readonly attribute AudioParam release </dt>
  <dd>
    The amount of time (in seconds) to increase the gain by 10dB.  Its default
    <code>value</code> is 0.250, with a nominal range of 0 to 1.
  </dd>
</dl>
</section>

<section>
<h2>The BiquadFilterNode Interface</h2>

<p>
  <a><code>BiquadFilterNode</code></a> is an <a><code>AudioNode</code></a>
  processor implementing very common low-order filters.
</p>

<p>
  Low-order filters are the building blocks of basic tone controls (bass, mid,
  treble), graphic equalizers, and more advanced filters. Multiple
  <a><code>BiquadFilterNode</code></a> filters can be combined to form more
  complex filters. The filter parameters such as <a><code>frequency</code></a>
  can be changed over time for filter sweeps, etc. Each
  <a><code>BiquadFilterNode</code></a> can be configured as one of a number of
  common filter types as shown in the IDL below.  The default filter type is
  <code>"lowpass"</code>.
</p>

<p>
  Both <a><code>frequency</code></a> and <a><code>detune</code></a> are
  <a>a-rate</a> parameters and are used together to determine a
  <dfn id=computedFreq-biquad>computedFrequency</dfn> value:
</p>

<pre class=highlight>
  computedFrequency(t) = frequency(t) * pow(2, detune(t) / 1200)
</pre>

<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>

<p>
The number of channels of the output always equals the number of channels of the input.
</p>

<dl title="enum BiquadFilterType" class="idl">
  <dt>lowpass</dt>
  <dd>
    <p>A <a href="http://en.wikipedia.org/wiki/Low-pass_filter">lowpass filter</a>
    allows frequencies below the cutoff frequency to pass through and attenuates
    frequencies above the cutoff. It implements a standard second-order
    resonant lowpass filter with 12dB/octave rolloff.</p>

    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The cutoff frequency</dd>
        <dt>Q</dt>
          <dd>Controls how peaked the response will be at the cutoff frequency. A
            large value makes the response more peaked.  Please note that for this filter type, this
            value is not a traditional Q, but is a resonance value in decibels.</dd>
        <dt>gain</dt>
          <dd>Not used in this filter type</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>highpass</dt>
  <dd>
    <p>A <a href="http://en.wikipedia.org/wiki/High-pass_filter">highpass
    filter</a> is the opposite of a lowpass filter. Frequencies above the cutoff
    frequency are passed through, but frequencies below the cutoff are attenuated.
    It implements a standard second-order resonant highpass filter with
    12dB/octave rolloff.</p>

    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The cutoff frequency below which the frequencies are attenuated</dd>
        <dt>Q</dt>
          <dd>Controls how peaked the response will be at the cutoff frequency. A
            large value makes the response more peaked. Please note that for this filter type, this
            value is not a traditional Q, but is a resonance value in decibels.</dd>
        <dt>gain</dt>
          <dd>Not used in this filter type</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>bandpass</dt>
  <dd>
    <p>A <a href="http://en.wikipedia.org/wiki/Band-pass_filter">bandpass
    filter</a> allows a range of frequencies to pass through and attenuates the
    frequencies below and above this frequency range. It implements a
    second-order bandpass filter.</p>

    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The center of the frequency band</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Controls the width of the band. The width becomes narrower as the Q
            value increases.</dd>
        <dt>gain</dt>
          <dd>Not used in this filter type</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>lowshelf</dt>
  <dd>
    <p>The lowshelf filter allows all frequencies through, but adds a boost (or
    attenuation) to the lower frequencies. It implements a second-order
    lowshelf filter.</p>

    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The upper limit of the frequences where the boost (or attenuation) is
            applied.</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Not used in this filter type.</dd>
        <dt>gain</dt>
          <dd>The boost, in dB, to be applied. If the value is negative, the
            frequencies are attenuated.</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>highshelf</dt>
  <dd>
    <p>The highshelf filter is the opposite of the lowshelf filter and allows all
    frequencies through, but adds a boost to the higher frequencies. It
    implements a second-order highshelf filter</p>

    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The lower limit of the frequences where the boost (or attenuation) is
            applied.</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Not used in this filter type.</dd>
        <dt>gain</dt>
          <dd>The boost, in dB, to be applied. If the value is negative, the
            frequencies are attenuated.</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>peaking</dt>
  <dd>
    <p>The peaking filter allows all frequencies through, but adds a boost (or
    attenuation) to a range of frequencies. </p>

    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The center frequency of where the boost is applied.</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Controls the width of the band of frequencies that are boosted. A
            large value implies a narrow width.</dd>
        <dt>gain</dt>
          <dd>The boost, in dB, to be applied. If the value is negative, the
            frequencies are attenuated.</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>notch</dt>
  <dd>
    <p>The notch filter (also known as a <a
    href="http://en.wikipedia.org/wiki/Band-stop_filter">band-stop or
    band-rejection filter</a>) is the opposite of a bandpass filter. It allows all
    frequencies through, except for a set of frequencies.</p>

    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The center frequency of where the notch is applied.</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Controls the width of the band of frequencies that are attenuated. A
            large value implies a narrow width.</dd>
        <dt>gain</dt>
          <dd>Not used in this filter type.</dd>
      </dl>
    </blockquote>
  </dd>
  <dt>allpass</dt>
  <dd>
    <p>An <a
    href="http://en.wikipedia.org/wiki/All-pass_filter#Digital_Implementation">allpass
    filter</a> allows all frequencies through, but changes the phase relationship
    between the various frequencies. It implements a second-order allpass
    filter</p>

    <blockquote>
      <dl>
        <dt>frequency</dt>
          <dd>The frequency where the center of the phase transition occurs. Viewed
            another way, this is the frequency with maximal <a
            href="http://en.wikipedia.org/wiki/Group_delay">group delay</a>.</dd>
        <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
          <dd>Controls how sharp the phase transition is at the center frequency. A
            larger value implies a sharper transition and a larger group delay.</dd>
        <dt>gain</dt>
          <dd>Not used in this filter type.</dd>
      </dl>
    </blockquote>
  </dd>
</dl>

<p>
All attributes of the <a><code>BiquadFilterNode</code></a> are <a>k-rate</a>
<a><code>AudioParam</code></a>.
</p>

<dl title="interface BiquadFilterNode : AudioNode" class="idl">
  <dt>attribute BiquadFilterType type</dt>
  <dd>
    The type of this <a><code>BiquadFilterNode</code></a>. The exact meaning of the other
    parameters depend on the value of the <a><code>type</code></a> attribute.
  </dd>
  <dt>readonly attribute AudioParam frequency</dt>
  <dd>
    The frequency at which the <a><code>BiquadFilterNode</code></a> will operate, in Hz.
    Its default value is 350Hz, and its nominal range is from 10Hz to half the
    Nyquist frequency.
  </dd>
  <dt>readonly attribute AudioParam detune</dt>
  <dd> A detune value, in cents, for the frequency. Its default value is 0. </dd>
  <dt>readonly attribute AudioParam Q</dt>
  <dd>
    The <a href="http://en.wikipedia.org/wiki/Q_factor">Q</a> factor has a
    default value of 1, with a nominal range of 0.0001 to 1000.
  </dd>
  <dt>readonly attribute AudioParam gain</dt>
  <dd>The gain has a default value of 0, with a nominal range of -40 to 40.</dd>

  <dt>void getFrequencyResponse() </dt>
  <dd>
  <p>
    Given the current filter parameter settings, calculates the
    frequency response for the specified frequencies.
  </p>
  <dl class="parameters">
    <dt>Float32Array frequencyHz</dt>
    <dd>
      This parameter specifies an array of frequencies at which the response
      values will be calculated.
    </dd>
    <dt>Float32Array magResponse</dt>
    <dd>
      This parameter specifies an output array receiving the linear magnitude
      response values.
    </dd>
    <dt>Float32Array phaseResponse</dt>
   <dd>
    This parameter specifies an output array receiving the phase response values
    in radians.
   </dd>
  </dl>
  </dd>
</dl>

  <section>
  <h3>Filters characteristics</h3>
  <p>
    There are multiple ways of implementing the type of filters available
    through the <a><code>BiquadFilterNode</code></a> each having very different
    characteristics. The formulas in this section describe the filters that a
    <a>conforming implementation</a> MUST implement, as they determine the
    characteristics of the different filter type. They are derived from formulas
    found in the <a href
    ="http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt">Audio EQ
    Cookbook</a>.
  </p>

  <p>
    The transfer function for the filters implemented by the
    <a><code>BiquadFilterNode</code></a> is:

    <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
      <mi>H</mi>
      <mrow>
        <mo>(</mo>
        <mi>z</mi>
        <mo>)</mo>
      </mrow>
      <mo>=</mo>
      <mfrac>
        <mrow>
          <mrow>
            <mo>(</mo>
            <mfrac>
              <msub>
                <mi>b</mi>
                <mn>0</mn>
              </msub>
              <msub>
                <mi>a</mi>
                <mn>0</mn>
              </msub>
            </mfrac>
            <mo>)</mo>
          </mrow>
          <mo>+</mo>
          <mrow>
            <mo>(</mo>
            <mfrac>
              <msub>
                <mi>b</mi>
                <mn>1</mn>
              </msub>
              <msub>
                <mi>a</mi>
                <mn>0</mn>
              </msub>
            </mfrac>
            <mo>)</mo>
          </mrow>
          <mo>&#x22C5;</mo>
          <msup>
            <mi>z</mi>
            <mrow>
              <mo>-</mo>
              <mn>1</mn>
            </mrow>
          </msup>
          <mo>+</mo>
          <mrow>
            <mo>(</mo>
            <mfrac>
              <msub>
                <mi>b</mi>
                <mn>2</mn>
              </msub>
              <msub>
                <mi>a</mi>
                <mn>0</mn>
              </msub>
            </mfrac>
            <mo>)</mo>
          </mrow>
          <mo>&#x22C5;</mo>
          <msup>
            <mi>z</mi>
            <mrow>
              <mo>-</mo>
              <mn>2</mn>
            </mrow>
          </msup>
        </mrow>
        <mrow>
          <mn>1</mn>
          <mo>+</mo>
          <mrow>
            <mo>(</mo>
            <mfrac>
              <msub>
                <mi>a</mi>
                <mn>1</mn>
              </msub>
              <msub>
                <mi>a</mi>
                <mn>0</mn>
              </msub>
            </mfrac>
            <mo>)</mo>
          </mrow>
          <mo>&#x22C5;</mo>
          <msup>
            <mi>z</mi>
            <mrow>
              <mo>-</mo>
              <mn>1</mn>
            </mrow>
          </msup>
          <mo>+</mo>
          <mrow>
            <mo>(</mo>
            <mfrac>
              <msub>
                <mi>a</mi>
                <mn>2</mn>
              </msub>
              <msub>
                <mi>a</mi>
                <mn>0</mn>
              </msub>
            </mfrac>
            <mo>)</mo>
          </mrow>
          <mo>&#x22C5;</mo>
          <msup>
            <mi>z</mi>
            <mrow>
              <mo>-</mo>
              <mn>2</mn>
            </mrow>
          </msup>
        </mrow>
      </mfrac>
      <mo>&#xA0;</mo>
      <mo>&#xA0;</mo>
    </math>

    The initial filter state is 0.
  </p>

  <p>
    The coefficients in the transfer function above are different for each node
    type. The following intermediate variable are necessary for their
    computation, based on the <a>computedValue</a> of the
    <a><code>AudioParam</code></a>s of the <a><code>BiquadFilterNode</code></a>.
    <ul>
    <li>Let <math
    title="Fs"><mrow><msub><mi>F</mi><mn>s</mn></msub></mrow></math> be the
    value of the <a><code>sampleRate</code></a> attribute for this
    <a>AudioContext</a>.</li>
    <li>Let <math
    title="f0"><mrow><msub><mi>f</mi><mn>0</mn></msub></mrow></math> be the
    value of the <a><code>computedFrequency</code></a>.
    <li>Let <math title="dbGain"><mi>dbGain</mi></math> be the value of the
    <a><code>gain</code></a> <a><code>AudioParam</code></a>.</li>
    <li>Let <math title="Q"><mi>Q</mi></math> be the value of the
    <a><code>Q</code></a> <a><code>AudioParam</code></a>.</li>
    <li>Let <math title="A_0"><mi>A</mi></math> be:
      <ul>
        <li>
          <math><msup><mn>10</mn><mrow><mfrac><mo>dBgain</mo><mn>40</mn></mfrac>
          </mrow></msup></math> for the filter types <code>peaking</code>,
          <code>highshelf</code> and <code>lowshelf</code> ;
        </li>
        <li>
          <math><msqrt><mrow><msup><mn>10</mn><mrow><mfrac><mo>dBgain</mo><mn>20
          </mn></mfrac></mrow></msup></mrow></msqrt></math> otherwise.
        </li>
      </ul>
    </li>
    <li>Let <math title="A_1"><msub><mi>A</mi><mn>1</mn></msub></math> be
    <li>Let <math title="omega0"><msub><mi>ω</mi><mn>0</mn></msub></math> be
    <math><mn>2</mn><mo>⋅</mo><mi>π</mi><mo>⋅</mo><mfrac><msub><mi>f</mi><mn>0</mn></msub><msub><mi>F</mi><mi>s</mi></msub></mfrac></math>.</li>
    <li>Let <math title="Q_Q"><msub><mi>α</mi><mn>Q</mn></msub></math> be 
    <math><mfrac><mrow><mi>sin</mi><mrow><mo>(</mo><msub><mi>ω</mi><mn>0</mn></msub><mo>)</mo></mrow></mrow><mrow><mn>2</mn><mo>⋅</mo><mi>Q</mi></mrow></mfrac></math></li>
    <li>Let <math title="Q_BW"><msub><mi>α</mi><mn>BW</mn></msub></math> be
    <math>
      <mrow>
        <mi>sin</mi>
        <mrow>
          <mo>(</mo>
          <msub>
            <mi>ω</mi>
            <mn>0</mn>
          </msub>
          <mo>)</mo>
        </mrow>
      </mrow>
      <mo>&#x22C5;</mo>
      <mrow>
        <mi>sinh</mi>
        <mrow>
          <mo>(</mo>
          <mfrac>
            <mrow>
              <mi>ln</mi>
              <mrow>
                <mo>(</mo>
                <mn>2</mn>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mn>2</mn>
          </mfrac>
          <mo>&#x22C5;</mo>
          <mi>Q</mi>
          <mo>&#x22C5;</mo>
          <mfrac>
            <msub>
              <mi>ω</mi>
              <mn>0</mn>
            </msub>
            <mrow>
              <mi>sin</mi>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>ω</mi>
                  <mn>0</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mfrac>
          <mo>)</mo>
        </mrow>
      </mrow>
    </math>
            </li>
    <li>Let <math title="Q_S"><msub><mi>α</mi><mn>S</mn></msub></math> be 
    <math>
      <mfrac>
        <mrow>
          <mi>sin</mi>
          <mrow>
            <mo>(</mo>
            <msub>
              <mi>ω</mi>
              <mn>0</mn>
            </msub>
            <mo>)</mo>
          </mrow>
        </mrow>
        <mn>2</mn>
      </mfrac>
      <mo>&#x22C5;</mo>
      <msqrt>
        <mrow>
          <mrow>
            <mo>(</mo>
            <mi>A</mi>
            <mo>+</mo>
            <mfrac>
              <mn>1</mn>
              <mi>A</mi>
            </mfrac>
            <mo>)</mo>
          </mrow>
          <mo>&#x22C5;</mo>
          <mrow>
            <mo>(</mo>
            <mfrac>
              <mn>1</mn>
              <mi>Q</mi>
            </mfrac>
            <mo>-</mo>
            <mn>1</mn>
            <mo>)</mo>
          </mrow>
          <mo>+</mo>
          <mn>2</mn>
        </mrow>
      </msqrt>
    </math>
    </li>
    </ul>
  </p>

  <p>
  The six coefficients (
    <math><msub><mi>b</mi><mn>0</mn></msub></math>,
    <math><msub><mi>b</mi><mn>1</mn></msub></math>,
    <math><msub><mi>b</mi><mn>2</mn></msub></math>,
    <math><msub><mi>a</mi><mn>0</mn></msub></math>,
    <math><msub><mi>a</mi><mn>1</mn></msub></math>,
    <math><msub><mi>a</mi><mn>2</mn></msub></math>) for each filter type, are:
    <dl>
      <dt><code>lowpass</code></dt>
      <dd>
        <math title="{:(b0 = (1 - cos(ω_0))/2), (b1 = 1 - cos(ω_0)), (b2 = (1 - cos(ω_0))/2), (a0 = 1 + alpha_Q), (a1 = -2*cos(ω_0)), (a2 = 1 - alpha_Q):}" display="block">
          <mrow>
            <mtable columnalign="left">
              <mtr>
                <mtd />
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>b</mi>
                    <mn>0</mn>
                  </msub>
                  <mo>=</mo>
                  <mfrac>
                    <mrow>
                      <mn>1</mn>
                      <mo>-</mo>
                      <mrow>
                        <mo>cos</mo>
                        <mrow>
                          <mo>(</mo>
                          <msub>
                            <mi>ω</mi>
                            <mn>0</mn>
                          </msub>
                          <mo>)</mo>
                        </mrow>
                      </mrow>
                    </mrow>
                    <mn>2</mn>
                  </mfrac>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>b</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>=</mo>
                  <mn>1</mn>
                  <mo>-</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>b</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>=</mo>
                  <mfrac>
                    <mrow>
                      <mn>1</mn>
                      <mo>-</mo>
                      <mrow>
                        <mo>cos</mo>
                        <mrow>
                          <mo>(</mo>
                          <msub>
                            <mi>ω</mi>
                            <mn>0</mn>
                          </msub>
                          <mo>)</mo>
                        </mrow>
                      </mrow>
                    </mrow>
                    <mn>2</mn>
                  </mfrac>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>a</mi>
                    <mn>0</mn>
                  </msub>
                  <mo>=</mo>
                  <mn>1</mn>
                  <mo>+</mo>
                  <msub>
                  <mi>α</mi>
                  <mn>Q</mn>
                  </msub>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>a</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>=</mo>
                  <mo>-</mo>
                  <mn>2</mn>
                  <mo>⋅</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>a</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>=</mo>
                  <mn>1</mn>
                  <mo>-</mo>
                  <msub>
                  <mi>α</mi>
                  <mn>Q</mn>
                  </msub>
                </mtd>
              </mtr>
            </mtable>
          </mrow>
    </math>
      </dd>
      <dt><code>highpass</code></dt>
      <dd>
        <math title="{: (H(s) = s^2 / (s^2 + s/Q + 1)), (), (b0 = (1 +
        cos(ω_0))/2), (b1 = -(1 + cos(ω_0))), (b2 = (1 + cos(ω_0))/2), (a0 = 1 +
        alpha_Q), (a1 = -2*cos(ω_0)), (a2 = 1 - alpha_Q) :}" display="block">
        <mrow>
          <mtable columnalign="left">
            <mtr>
              <mtd />
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mfrac>
                  <mrow>
                    <mn>1</mn>
                    <mo>+</mo>
                    <mrow>
                      <mo>cos</mo>
                      <mrow>
                        <mo>(</mo>
                        <msub>
                          <mi>ω</mi>
                          <mn>0</mn>
                        </msub>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                  </mrow>
                  <mn>2</mn>
                </mfrac>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo>-</mo>
                <mrow>
                  <mo>(</mo>
                  <mn>1</mn>
                  <mo>+</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mfrac>
                  <mrow>
                    <mn>1</mn>
                    <mo>+</mo>
                    <mrow>
                      <mo>cos</mo>
                      <mrow>
                        <mo>(</mo>
                        <msub>
                          <mi>ω</mi>
                          <mn>0</mn>
                        </msub>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                  </mrow>
                  <mn>2</mn>
                </mfrac>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>+</mo>
                <msub>
                <mi>α</mi>
                <mn>Q</mn>
                </msub>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo>-</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <mrow>
                  <mo>cos</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>ω</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>-</mo>
                <msub>
                <mi>α</mi>
                <mn>Q</mn>
                </msub>
              </mtd>
            </mtr>
          </mtable>
        </mrow>
        </math>
      </dd>
      <dt><code>bandpass</code></dt>
      <dd>
        <math title="{: (H(s) = (s/Q) / (s^2 + s/Q + 1)), (), (b0 = alpha_BW), (b1 = 0), (b2 = -alpha_BW), (a0 = 1 + alpha_BW), (a1 = -2*cos(ω_0)), (a2 = 1 - alpha_BW) :}" display="block">
          <mrow>
            <mtable columnalign="left">
              <mtr>
                <mtd />
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>b</mi>
                    <mn>0</mn>
                  </msub>
                  <mo>=</mo>
                  <msub>
                  <mi>α</mi>
                  <mn>BW</mn>
                  </msub>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>b</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>=</mo>
                  <mn>0</mn>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>b</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>=</mo>
                  <mo>-</mo>
                  <msub>
                  <mi>α</mi>
                  <mn>BW</mn>
                  </msub>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>a</mi>
                    <mn>0</mn>
                  </msub>
                  <mo>=</mo>
                  <mn>1</mn>
                  <mo>+</mo>
                  <msub>
                  <mi>α</mi>
                  <mn>BW</mn>
                  </msub>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>a</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>=</mo>
                  <mo>-</mo>
                  <mn>2</mn>
                  <mo>⋅</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msub>
                    <mi>a</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>=</mo>
                  <mn>1</mn>
                  <mo>-</mo>
                  <msub>
                  <mi>α</mi>
                  <mn>BW</mn>
                  </msub>
                </mtd>
              </mtr>
            </mtable>
          </mrow>
        </math>
      </dd>
      <dt><code>notch</code></dt>
      <dd>
        <math title="{: (H(s) = (s^2 + 1) / (s^2 + s/Q + 1)), (), (b0 = 1), (b1 = -2*cos(ω_0)), (b2 = 1), (a0 = 1 + alpha_BW), (a1 = -2*cos(ω_0)), (a2 = 1 - alpha_BW) :}" display="block">
        <mrow>
          <mtable columnalign="left">
            <mtr>
              <mtd />
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo>-</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <mrow>
                  <mo>cos</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>ω</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>+</mo>
                <msub>
                <mi>α</mi>
                <mn>BW</mn>
                </msub>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo>-</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <mrow>
                  <mo>cos</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>ω</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>-</mo>
                <msub>
                <mi>α</mi>
                <mn>BW</mn>
                </msub>
              </mtd>
            </mtr>
          </mtable>
        </mrow>
        </math>
      </dd>
      <dt><code>allpass</code></dt>
      <dd>
        <math title="{: (H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)), (), (b0 = 1 - alpha_Q), (b1 = -2*cos(ω_0)), (b2 = 1 + alpha_Q), (a0 = 1 + alpha_Q), (a1 = -2*cos(ω_0)), (a2 = 1 - alpha_Q) :}" display="block">
        <mrow>
          <mtable columnalign="left">
            <mtr>
              <mtd />
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>-</mo>
                <msub>
                <mi>α</mi>
                <mn>Q</mn>
                </msub>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo>-</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <mrow>
                  <mo>cos</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>ω</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>+</mo>
                <msub>
                <mi>α</mi>
                <mn>Q</mn>
                </msub>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>+</mo>
                <msub>
                <mi>α</mi>
                <mn>Q</mn>
                </msub>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo>-</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <mrow>
                  <mo>cos</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>ω</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>-</mo>
                <msub>
                <mi>α</mi>
                <mn>Q</mn>
                </msub>
              </mtd>
            </mtr>
          </mtable>
        </mrow>
        </math>
      </dd>
      <dt><code>peaking</code></dt>
      <dd>
        <math title="{: (H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)), (), (b0 = 1 + alpha_BW*A), (b1 = -2*cos(ω_0)), (b2 = 1 - alpha_BW*A), (a0 = 1 + alpha_BW/A), (a1 = -2*cos(ω_0)), (a2 = 1 - alpha_BW/A) :}" display="block">
        <mrow>
          <mtable columnalign="left">
            <mtr>
              <mtd />
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>+</mo>
                <msub>
                <mi>α</mi>
                <mn>BW</mn>
                </msub>
                <mo>⋅</mo>
                <mi>A</mi>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo>-</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <mrow>
                  <mo>cos</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>ω</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>-</mo>
                <msub>
                <mi>α</mi>
                <mn>BW</mn>
                </msub>
                <mo>⋅</mo>
                <mi>A</mi>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>+</mo>
                <mfrac>
                  <msub>
                  <mi>α</mi>
                  <mn>BW</mn>
                  </msub>
                  <mi>A</mi>
                </mfrac>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo>-</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <mrow>
                  <mo>cos</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>ω</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mn>1</mn>
                <mo>-</mo>
                <mfrac>
                  <msub>
                  <mi>α</mi>
                  <mn>BW</mn>
                  </msub>
                  <mi>A</mi>
                </mfrac>
              </mtd>
            </mtr>
          </mtable>
        </mrow>
        </math>
      </dd>
      <dt><code>lowshelf</code></dt>
      <dd>
        <math title="{: (H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)), (), (b0 = A*( (A+1) - (A-1)*cos(ω_0) + 2*sqrt(A)*alpha_S )), (b1 = 2*A*( (A-1) - (A+1)*cos(ω_0) )), (b2 = A*( (A+1) - (A-1)*cos(ω_0) - 2*sqrt(A)*alpha_S )), (a0 = (A+1) + (A-1)*cos(ω_0) + 2*sqrt(A)*alpha_S), (a1 = -2*( (A-1) + (A+1)*cos(ω_0))), (a2 = (A+1) + (A-1)*cos(ω_0) - 2*sqrt(A)*alpha_S) :}" display="block">
        <mrow>
          <mtable columnalign="left">
            <mtr>
              <mtd />
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mi>A</mi>
                <mo>⋅</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>⋅</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <mn>2</mn>
                  <mo>⋅</mo>
                  <msqrt>
                    <mrow>
                      <mi>A</mi>
                    </mrow>
                  </msqrt>
                  <mo>⋅</mo>
                  <msub>
                  <mi>α</mi>
                  <mn>S</mn>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <mi>A</mi>
                <mo>⋅</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>⋅</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mi>A</mi>
                <mo>⋅</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>⋅</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>-</mo>
                  <mn>2</mn>
                  <mo>⋅</mo>
                  <msqrt>
                    <mrow>
                      <mi>A</mi>
                    </mrow>
                  </msqrt>
                  <mo>⋅</mo>
                  <msub>
                  <mi>α</mi>
                  <mn>S</mn>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>A</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                  <mo>)</mo>
                </mrow>
                <mo>+</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>A</mi>
                  <mo>-</mo>
                  <mn>1</mn>
                  <mo>)</mo>
                </mrow>
                <mo>⋅</mo>
                <mrow>
                  <mo>cos</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>ω</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>+</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <msqrt>
                  <mrow>
                    <mi>A</mi>
                  </mrow>
                </msqrt>
                <mo>⋅</mo>
                <msub>
                <mi>α</mi>
                <mn>S</mn>
                </msub>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo>-</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>⋅</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>A</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                  <mo>)</mo>
                </mrow>
                <mo>+</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>A</mi>
                  <mo>-</mo>
                  <mn>1</mn>
                  <mo>)</mo>
                </mrow>
                <mo>⋅</mo>
                <mrow>
                  <mo>cos</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>ω</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>-</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <msqrt>
                  <mrow>
                    <mi>A</mi>
                  </mrow>
                </msqrt>
                <mo>⋅</mo>
                <msub>
                <mi>α</mi>
                <mn>S</mn>
                </msub>
              </mtd>
            </mtr>
          </mtable>
        </mrow>
        </math>
      </dd>
    <dt><code>highshelf</code></dt>
    <dd>
      <math title="{: (H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)), (), (b0 = A*( (A+1) + (A-1)*cos(ω_0) + 2*sqrt(A)*alpha_S )), (b1 = -2*A*( (A-1) + (A+1)*cos(ω_0) )), (b2 = A*( (A+1) + (A-1)*cos(ω_0) - 2*sqrt(A)*alpha_S )), (a0 = (A+1) - (A-1)*cos(ω_0) + 2*sqrt(A)*alpha_S), (a1 = 2*( (A-1) - (A+1)*cos(ω_0) )), (a2 = (A+1) - (A-1)*cos(ω_0) - 2*sqrt(A)*alpha_S) :}" display="block">
        <mrow>
          <mtable columnalign="left">
            <mtr>
              <mtd />
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mi>A</mi>
                <mo>⋅</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>⋅</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>+</mo>
                  <mn>2</mn>
                  <mo>⋅</mo>
                  <msqrt>
                    <mrow>
                      <mi>A</mi>
                    </mrow>
                  </msqrt>
                  <mo>⋅</mo>
                  <msub>
                  <mi>α</mi>
                  <mn>S</mn>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo>-</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <mi>A</mi>
                <mo>⋅</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>⋅</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>b</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mi>A</mi>
                <mo>⋅</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>⋅</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>-</mo>
                  <mn>2</mn>
                  <mo>⋅</mo>
                  <msqrt>
                    <mrow>
                      <mi>A</mi>
                    </mrow>
                  </msqrt>
                  <mo>⋅</mo>
                  <msub>
                  <mi>α</mi>
                  <mn>S</mn>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>0</mn>
                </msub>
                <mo>=</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>A</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                  <mo>)</mo>
                </mrow>
                <mo>-</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>A</mi>
                  <mo>-</mo>
                  <mn>1</mn>
                  <mo>)</mo>
                </mrow>
                <mo>⋅</mo>
                <mrow>
                  <mo>cos</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>ω</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>+</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <msqrt>
                  <mrow>
                    <mi>A</mi>
                  </mrow>
                </msqrt>
                <mo>⋅</mo>
                <msub>
                <mi>α</mi>
                <mn>S</mn>
                </msub>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>-</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>-</mo>
                  <mrow>
                    <mo>(</mo>
                    <mi>A</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                  </mrow>
                  <mo>⋅</mo>
                  <mrow>
                    <mo>cos</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>ω</mi>
                        <mn>0</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mo>)</mo>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>A</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                  <mo>)</mo>
                </mrow>
                <mo>-</mo>
                <mrow>
                  <mo>(</mo>
                  <mi>A</mi>
                  <mo>-</mo>
                  <mn>1</mn>
                  <mo>)</mo>
                </mrow>
                <mo>⋅</mo>
                <mrow>
                  <mo>cos</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>ω</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>-</mo>
                <mn>2</mn>
                <mo>⋅</mo>
                <msqrt>
                  <mrow>
                    <mi>A</mi>
                  </mrow>
                </msqrt>
                <mo>⋅</mo>
                <msub>
                <mi>α</mi>
                <mn>S</mn>
                </msub>
              </mtd>
            </mtr>
          </mtable>
        </mrow>
      </math>
    </dd>
  </dl>
  </p>
</section>

</section>
<section>
<h2 id="WaveShaperNode">The WaveShaperNode Interface</h2>

<p>
<a><code>WaveShaperNode</code></a> is an <a><code>AudioNode</code></a> processor implementing non-linear
distortion effects.
</p>

<p>
Non-linear waveshaping distortion is commonly used for both subtle non-linear
warming, or more obvious distortion effects. Arbitrary non-linear shaping curves
may be specified.
</p>

<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>

<p>
  The number of channels of the output always equals the number of channels of
  the input.
</p>

<dl title="enum OverSampleType" class="idl">
  <dt> none </dt>
  <dd> Don't oversample</dd>
  <dt> 2x </dt>
  <dd> Oversample two times </dd>
  <dt> 4x </dt>
  <dd> Oversample four times </dd>
</dl>

<dl title="interface WaveShaperNode : AudioNode" class="idl" data-merge="OverSampleType">
  <dt> attribute Float32Array? curve </dt>
  <dd>
    <p>
      The shaping curve used for the waveshaping effect. The input signal is
      nominally within the range [-1; 1]. Each input sample within this range
      will index into the shaping curve, with a signal level of zero
      corresponding to the center value of the curve array if there are an odd
      number of entries, or interpolated between the two centermost values if
      there are an even number of entries in the array. Any sample value less
      than -1 will correspond to the first value in the curve array. Any sample
      value greater than +1 will correspond to the last value in the curve
      array.
    </p>
    <p>
      The implementation must perform linear interpolation between adjacent
      points in the curve.  Initially the curve attribute is null, which means
      that the WaveShaperNode will pass its input to its output without
      modification.
    </p>
    <p>
      Values of the curve are spread with equal spacing in the [-1; 1] range.
      This means that a <a><code>curve</code></a> with a even number of value
      will not have a value for a signal at zero, and a
      <a><code>curve</code></a> with an odd number of value will have a value
      for a signal at zero.
    </p>
    <p>
      A <code>InvalidAccessError</code> MUST be thrown if this attribute is set
      with a <code>Float32Array</code> that has a <code>length</code> less than
      2.
    </p>
  </dd>
  <dt> attribute OverSampleType oversample </dt>
    <dd>
    <p>
      Specifies what type of oversampling (if any) should be used when applying
      the shaping curve. The default value is "none", meaning the curve will
      be applied directly to the input samples.  A value of "2x" or "4x" can
      improve the quality of the processing by avoiding some aliasing, with the
      "4x" value yielding the highest quality.  For some applications, it's
      better to use no oversampling in order to get a very precise shaping
      curve.
    </p>
    <p>
      A value of "2x" or "4x" means that the following steps must be performed:
    </p>
    <ol>
      <li>
        Up-sample the input samples to 2x or 4x the sample-rate of the
        <a><code>AudioContext</code></a>.  Thus for each processing block of 128 samples,
        generate 256 (for 2x) or 512 (for 4x) samples.
      </li>
      <li>Apply the shaping curve.</li>
      <li>
        Down-sample the result back to the sample-rate of the <a><code>AudioContext</code></a>.
        Thus taking the 256 (or 512) processed samples, generating 128 as the
        final result.
      </li>
    </ol>
    <p>
      The exact up-sampling and down-sampling filters are not specified, and can
      be tuned for sound quality (low aliasing, etc.), low latency, and
      performance.
    </p>
    </dd>
</dl>

</section>

<section>
<h2>The OscillatorNode Interface</h2>

<p>
  <a><code>OscillatorNode</code></a> represents an audio source generating a periodic waveform.
  It can be set to a few commonly used waveforms. Additionally, it can be set to
  an arbitrary periodic waveform through the use of a <a><code>PeriodicWave</code></a> object.
</p>

<p>
  Oscillators are common foundational building blocks in audio synthesis.  An
  OscillatorNode will start emitting sound at the time specified by the
  <code>start()</code> method.
</p>

<p>
  Mathematically speaking, a <em>continuous-time</em> periodic waveform can have
  very high (or infinitely high) frequency information when considered in the
  frequency domain.  When this waveform is sampled as a discrete-time digital
  audio signal at a particular sample-rate, then care must be taken to discard
  (filter out) the high-frequency information higher than the <em>Nyquist</em>
  frequency (half the sample-rate) before converting the waveform to a digital
  form.  If this is not done, then <em>aliasing</em> of higher frequencies (than
  the Nyquist frequency) will fold back as mirror images into frequencies lower
  than the Nyquist frequency.  In many cases this will cause audibly objectionable
  artifacts.  This is a basic and well understood principle of audio DSP.
</p>

<p>
  There are several practical approaches that an implementation may take to avoid
  this aliasing.  Regardless of approach, the <em>idealized</em> discrete-time
  digital audio signal is well defined mathematically.  The trade-off for the
  implementation is a matter of implementation cost (in terms of CPU usage) versus
  fidelity to achieving this ideal.
</p>

<p>
It is expected that an implementation will take some care in achieving this
ideal, but it is reasonable to consider lower-quality, less-costly approaches on
lower-end hardware.
</p>

<p>
Both .frequency and .detune are <a>a-rate</a> parameters and are used together
to determine a <em>computedFrequency</em> value:
</p>

<pre class=highlight>
  computedFrequency(t) = frequency(t) * pow(2, detune(t) / 1200)
</pre>

<p>
  The OscillatorNode's instantaneous phase at each time is the time integral of
  <em>computedFrequency</em>.
</p>

<pre>
  numberOfInputs  : 0
  numberOfOutputs : 1 (mono output)
</pre>

<dl title="enum OscillatorType" class="idl">
  <dt> sine </dt>
  <dd> A sine wave </dd>
  <dt> square </dt>
  <dd> A square wave of duty period 0.5 </dd>
  <dt> sawtooth </dt>
  <dd> A sawtooth wave </dd>
  <dt> triangle </dt>
  <dd> A triangle wave </dd>
  <dt> custom </dt>
  <dd> A custom periodic wave </dd>
</dl>

<dl title="interface OscillatorNode : AudioNode" class="idl">
    <dt> attribute OscillatorType type </dt>
    <dd>
      The shape of the periodic waveform.  It may directly be set to any of the
      type constant values except for "custom".  The <a
      href="#widl-OscillatorNode-setPeriodicWave-void-PeriodicWave-periodicWave"><code>setPeriodicWave()</code></a> method can be
      used to set a custom waveform, which results in this attribute being set to
      "custom".  The default value is "sine". When this attribute is set, the
      phase of the oscillator MUST be conserved.
    </dd>

    <dt> readonly attribute AudioParam frequency </dt>
    <dd>
      The frequency (in Hertz) of the periodic waveform. Its default
      <code>value</code> is 440. This parameter is <a>a-rate</a>.
    </dd>
    <dt> readonly attribute AudioParam detune </dt>
    <dd>
      A detuning value (in Cents) which will offset the <a><code>frequency</code></a> by
      the given amount. Its default <code>value</code> is 0.  This parameter is
      <a>a-rate</a>.
    </dd>

    <dt> void start(optional double when = 0) </dt>
    <dd>Defined as in <a><code>AudioBufferSourceNode</code></a>.</dd>
    <dt> void stop(optional double when = 0) </dt>
    <dd>Defined as in <a><code>AudioBufferSourceNode</code></a>.</dd>
    <dt> void setPeriodicWave(PeriodicWave periodicWave) </dt>
    <dd>
      Sets an arbitrary custom periodic waveform given a <a><code>PeriodicWave</code></a>.
    </dd>

    <dt> attribute EventHandler onended </dt>
    <dd>
      A property used to set the <code>EventHandler</code> (described in <cite><a
      href="http://www.whatwg.org/specs/web-apps/current-work/#eventhandler">HTML</a></cite>[[HTML]])
      for the ended event that is dispatched to <a >OscillatorNode</a>
      node types.  When the <a><code>OscillatorNode</code></a> has finished playing
      (i.e. its stop time has been reached), an event of type <code>Event</code> (described in <cite><a
      href="http://www.whatwg.org/specs/web-apps/current-work/#event">HTML</a></cite>[[HTML]])
      will be dispatched to the event handler.
    </dd>
</dl>

<section>
<h2>Basic waveform phase</h2>
<p>
  The idealized mathematical waveforms for the various oscillator types are defined here. In summary,
  all waveforms are defined mathematically to be an odd function with a positive slope at time
  0. The actual waveforms produced by the oscillator may differ to prevent aliasing affects.
</p>
<dl>
  <dt> "sine" </dt>
  <dd>
    The waveform for sine oscillator is sin(t).
  </dd>
  <dt>"square"</dt>
  <dd>
    The waveform for the square wave oscillator is 1 for 0&le; t &lt; &pi; and
    -1 for -&pi; &lt; t &lt; 0.
  </dd>
  <dt>"sawtooth"</dt>
  <dd>
    The waveform for the sawtooth oscillator is the ramp t/&pi; for -&pi; &lt; t
    &le; &pi;
  </dd>
  <dt>"triangle"</dt>
  <dd>
    The waveform for the triangle oscillator is 2/&pi;*t for 0 &le; t &le;
    &pi;/2 and 1-2/&pi;*(t-&pi;/2) for &pi;/2 &lt; t &le; &pi;. This is extended
    to all t by using the fact that the waveform is an odd function with period
    2&pi;.
  </dd>
</dl>
</section>
</section>

<section>
<h2>The PeriodicWave Interface</h2>

<p>
PeriodicWave represents an arbitrary periodic waveform to be used with an
<a><code>OscillatorNode</code></a>.  Please see
<a
  href="#widl-AudioContext-createPeriodicWave-PeriodicWave-Float32Array-real-Float32Array-imag">createPeriodicWave()</a> and <a
href="#widl-OscillatorNode-setPeriodicWave-void-PeriodicWave-periodicWave">setPeriodicWave()</a> and for more details.
</p>

<dl title="interface PeriodicWave" class="idl">
</dl>

</section>

<section>
<h2 id="MediaStreamAudioSourceNode"> The MediaStreamAudioSourceNode Interface</h2>

<p>
This interface represents an audio source from a <code>MediaStream</code>.  The
first <code>AudioMediaStreamTrack</code> from the <code>MediaStream</code> will
be used as a source of audio. Those interfaces are described in
[[!mediacapture-streams]].
</p>
<pre>
    numberOfInputs  : 0
    numberOfOutputs : 1
</pre>

<p>
  The number of channels of the output corresponds to the number of channels of
  the <code>AudioMediaStreamTrack</code>.  If there is no valid audio track,
  then the number of channels output will be one silent channel.
</p>

<dl title="interface MediaStreamAudioSourceNode : AudioNode" class="idl">
</dl>
</section>

<section>
<h2> The MediaStreamAudioDestinationNode Interface </h2>

<p>This interface is an audio destination representing a
<code>MediaStream</code> with a single <code>AudioMediaStreamTrack</code>.  This
MediaStream is created when the node is created and is accessible via the
<dfn>stream</dfn> attribute.  This stream can be used in a similar way as a
<code>MediaStream</code> obtained via <code>getUserMedia()</code>, and can, for
example, be sent to a remote peer using the <code>RTCPeerConnection</code>
(described in [[!webrtc]])
<code>addStream()</code> method.
</p>
<pre>
    numberOfInputs  : 1
    numberOfOutputs : 0

    channelCount = 2;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>

<p>
  The number of channels of the input is by default 2 (stereo).  Any connections
  to the input are up-mixed/down-mixed to the number of channels of the input.
</p>

<dl title="interface MediaStreamAudioDestinationNode : AudioNode" class="idl">
  <dt> readonly attribute MediaStream stream </dt>
  <dd>
    A MediaStream containing a single AudioMediaStreamTrack with the same
    number of channels as the node itself.
  </dd>
</dl>

</section>

</section>

<section class="informative">
<h2>Mixer Gain Structure</h2>

<h3 id="background">Background</h3>

<p>One of the most important considerations when dealing with audio processing
graphs is how to adjust the gain (volume) at various points. For example, in a
standard mixing board model, each input bus has pre-gain, post-gain, and
send-gains. Submix and master out busses also have gain control. The gain
control described here can be used to implement standard mixing boards as well
as other architectures. </p>

<section>
  <h3 id="SummingJunction">Summing Inputs</h3>

  <p>The inputs to <a><code>AudioNode</code></a>s have
  the ability to accept connections from multiple outputs. The input then acts as
  a unity gain summing junction with each output signal being added with the
  others: </p>
  <figure>
    <img alt="unity gain summing junction" src="images/unity-gain-summing-junction.png" />
    <figcaption>A graph showing Source 1 and Source 2 output summed at the input
    of Destination</figcaption>
  </figure>

  <p>In cases where the channel layouts of the outputs do not match, a mix
  (usually up-mix) will occur according to the <a href="UpMix">mixing rules</a>.
  </p>
</section>

<section>
  <h3>Gain Control</h3>

  <p>In many scenarios, it's important to be able to control the gain for each of
  the output signals. The <a><code>GainNode</code></a> gives this
  control: </p>
  <figure>
    <img alt="mixer architecture new" src="images/mixer-architecture-new.png" />
    <figcaption>A graph featuring volume control for each voice</figcaption>
  </figure>

  <p>Using these two concepts of unity gain summing junctions and GainNodes,
  it's possible to construct simple or complex mixing scenarios. </p>
</section>

<section>
  <h3 id="Example-mixer-with-send-busses">Example: Mixer with Send Busses</h3>

  <p>In a routing scenario involving multiple sends and submixes, explicit
  control is needed over the volume or "gain" of each connection to a mixer. Such
  routing topologies are very common and exist in even the simplest of electronic
  gear sitting around in a basic recording studio. </p>

  <p>Here's an example with two send mixers and a main mixer. Although possible,
  for simplicity's sake, pre-gain control and insert effects are not illustrated:
  </p>
  <figure>
    <img alt="mixer gain structure" src="images/mixer-gain-structure.png" />
    <figcaption>A graph showing a full mixer with send busses.</figcaption>
  </figure>

  <p>This diagram is using a shorthand notation where "send 1", "send 2", and
  "main bus" are actually inputs to <a><code>AudioNode</code></a>s, but here are represented as
  summing busses, where the intersections g2_1, g3_1, etc. represent the "gain"
  or volume for the given source on the given mixer. In order to expose this
  gain, an <a><code>GainNode</code></a> is used:
  </p>

  <p>Here's how the above diagram could be constructed in JavaScript: </p>

  <pre class="highlight example">

  var context = 0;
  var compressor = 0;
  var reverb = 0;
  var delay = 0;
  var s1 = 0;
  var s2 = 0;

  var source1 = 0;
  var source2 = 0;
  var g1_1 = 0;
  var g2_1 = 0;
  var g3_1 = 0;
  var g1_2 = 0;
  var g2_2 = 0;
  var g3_2 = 0;

  // Setup routing graph
  function setupRoutingGraph() {
      context = new AudioContext();

      compressor = context.createDynamicsCompressor();

      // Send1 effect
      reverb = context.createConvolver();
      // Convolver impulse response may be set here or later

      // Send2 effect
      delay = context.createDelay();

      // Connect final compressor to final destination
      compressor.connect(context.destination);

      // Connect sends 1 &amp; 2 through effects to main mixer
      s1 = context.createGain();
      reverb.connect(s1);
      s1.connect(compressor);

      s2 = context.createGain();
      delay.connect(s2);
      s2.connect(compressor);

      // Create a couple of sources
      source1 = context.createBufferSource();
      source2 = context.createBufferSource();
      source1.buffer = manTalkingBuffer;
      source2.buffer = footstepsBuffer;

      // Connect source1
      g1_1 = context.createGain();
      g2_1 = context.createGain();
      g3_1 = context.createGain();
      source1.connect(g1_1);
      source1.connect(g2_1);
      source1.connect(g3_1);
      g1_1.connect(compressor);
      g2_1.connect(reverb);
      g3_1.connect(delay);

      // Connect source2
      g1_2 = context.createGain();
      g2_2 = context.createGain();
      g3_2 = context.createGain();
      source2.connect(g1_2);
      source2.connect(g2_2);
      source2.connect(g3_2);
      g1_2.connect(compressor);
      g2_2.connect(reverb);
      g3_2.connect(delay);

      // We now have explicit control over all the volumes g1_1, g2_1, ..., s1, s2
      g2_1.gain.value = 0.2;  // For example, set source1 reverb gain

      // Because g2_1.gain is an "AudioParam",
      // an automation curve could also be attached to it.
      // A "mixing board" UI could be created in canvas or WebGL controlling these gains.
  }

   </pre>
</section>
</section>


<section>
<h2 id="DynamicLifetime">Dynamic Lifetime</h2>

<section>
<h3>Background</h3>

<p class="norm"><em>This section is non-normative. Please see <a href="#lifetime-AudioContext">AudioContext lifetime</a>
and <a href="#lifetime-AudioNode">AudioNode lifetime</a>  for normative
requirements.</em>
</p>

<p>In addition to allowing the creation of static routing configurations, it
should also be possible to do custom effect routing on dynamically allocated
voices which have a limited lifetime. For the purposes of this discussion,
let's call these short-lived voices "notes". Many audio applications
incorporate the ideas of notes, examples being drum machines, sequencers, and
3D games with many one-shot sounds being triggered according to game play. </p>

<p>In a traditional software synthesizer, notes are dynamically allocated and
released from a pool of available resources. The note is allocated when a MIDI
note-on message is received. It is released when the note has finished playing
either due to it having reached the end of its sample-data (if non-looping), it
having reached a sustain phase of its envelope which is zero, or due to a MIDI
note-off message putting it into the release phase of its envelope. In the MIDI
note-off case, the note is not released immediately, but only when the release
envelope phase has finished. At any given time, there can be a large number of
notes playing but the set of notes is constantly changing as new notes are
added into the routing graph, and old ones are released. </p>

<p>The audio system automatically deals with tearing-down the part of the
routing graph for individual "note" events. A "note" is represented by an
<a><code>AudioBufferSourceNode</code></a>, which can be directly connected to other
processing nodes. When the note has finished playing, the context will
automatically release the reference to the <a><code>AudioBufferSourceNode</code></a>,
which in turn will release references to any nodes it is connected to, and so
on. The nodes will automatically get disconnected from the graph and will be
deleted when they have no more references. Nodes in the graph which are
long-lived and shared between dynamic voices can be managed explicitly.
Although it sounds complicated, this all happens automatically with no extra
JavaScript handling required. </p>
</section>

<section>
<h3>Example</h3>
<figure>
  <img alt="dynamic allocation" src="images/dynamic-allocation.png" />
  <figcaption>A graph featuring a subgraph that will be releases early.</figcaption>
</figure>

<p>The low-pass filter, panner, and second gain nodes are directly connected
from the one-shot sound. So when it has finished playing the context will
automatically release them (everything within the dotted line). If there are no
longer any JavaScript references to the one-shot sound and connected nodes,
then they will be immediately removed from the graph and deleted. The streaming
source, has a global reference and will remain connected until it is explicitly
disconnected. Here's how it might look in JavaScript: </p>

<pre class="example highlight">

var context = 0;
var compressor = 0;
var gainNode1 = 0;
var streamingAudioSource = 0;

// Initial setup of the "long-lived" part of the routing graph
function setupAudioContext() {
    context = new AudioContext();

    compressor = context.createDynamicsCompressor();
    gainNode1 = context.createGain();

    // Create a streaming audio source.
    var audioElement = document.getElementById('audioTagID');
    streamingAudioSource = context.createMediaElementSource(audioElement);
    streamingAudioSource.connect(gainNode1);

    gainNode1.connect(compressor);
    compressor.connect(context.destination);
}

// Later in response to some user action (typically mouse or key event)
// a one-shot sound can be played.
function playSound() {
    var oneShotSound = context.createBufferSource();
    oneShotSound.buffer = dogBarkingBuffer;

    // Create a filter, panner, and gain node.
    var lowpass = context.createBiquadFilter();
    var panner = context.createPanner();
    var gainNode2 = context.createGain();

    // Make connections
    oneShotSound.connect(lowpass);
    lowpass.connect(panner);
    panner.connect(gainNode2);
    gainNode2.connect(compressor);

    // Play 0.75 seconds from now (to play immediately pass in 0)
    oneShotSound.start(context.currentTime + 0.75);
}
</pre>
</section>
</section>



<section>
<h2>Channel up-mixing and down-mixing</h2>

<p class="norm">This section is normative.</p>

<p>
<a href="#mixer-gain-structure"></a>
describes how an input to an <a><code>AudioNode</code></a> can be connected from one or more outputs
of an <a><code>AudioNode</code></a>.  Each of these connections from an output represents a stream with
a specific non-zero number of channels.  An input has <em>mixing rules</em> for combining the channels
from all of the connections to it.  As a simple example, if an input is connected from a mono output and
a stereo output, then the mono connection will usually be up-mixed to stereo and summed with
the stereo connection.  But, of course, it's important to define the exact <em>mixing rules</em> for
every input to every <a><code>AudioNode</code></a>.  The default mixing rules for all of the inputs have been chosen so that
things "just work" without worrying too much about the details, especially in the very common
case of mono and stereo streams.  Of course, the rules can be changed for advanced use cases, especially
multi-channel.
</p>

<p>
To define some terms, <em>up-mixing</em> refers to the process of taking a stream with a smaller
number of channels and converting it to a stream with a larger number of channels.  <em>down-mixing</em>
refers to the process of taking a stream with a larger number of channels and converting it to a stream
with a smaller number of channels.
</p>

<p>
An <a><code>AudioNode</code></a> input use three basic pieces of information to determine how to mix all the outputs
connected to it.  As part of this process it computes an internal value <dfn><code>computedNumberOfChannels</code></dfn>
representing the actual number of channels of the input at any given time:
</p>

<p>
The <a><code>AudioNode</code></a> attributes involved in channel up-mixing and down-mixing rules are defined
<a href="#the-audionode-interface">above</a>.  The following is a more precise specification
on what each of them mean.
</p>

<ul>
<li><a href="#widl-AudioNode-channelCount"><code>channelCount</code></a> is used to help compute <a><code>computedNumberOfChannels</code></a>.</li>

<li><a href="#widl-AudioNode-channelCountMode"><code>channelCountMode</code></a> determines how <a><code>computedNumberOfChannels</code></a> will be computed.
Once this number is computed, all of the connections will be up or down-mixed to that many channels.  For most nodes,
the default value is <a href="#idl-def-ChannelCountMode.max"><code>"max"</code></a>.
<ul>
<li><a href="#idl-def-ChannelCountMode.max"><code>"max"</code></a>: <a><code>computedNumberOfChannels</code></a> is computed as the maximum of the number of channels of all connections.
In this mode <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a> is ignored.</li>
<li><a href="#idl-def-ChannelCountMode.clamped-max"><code>"clamped-max"</code></a>: same as “max” up to a limit of the <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a></li>
<li><a href="#idl-def-ChannelCountMode.explicit"><code>"explicit"</code></a>: <a><code>computedNumberOfChannels</code></a> is the exact value as specified
in <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a></li>
</ul>

</li>

<li><a href="#widl-AudioNode-channelInterpretation"><code>channelInterpretation</code></a> determines how the individual channels will be treated.
For example, will they be treated as speakers having a specific layout, or will they
be treated as simple discrete channels?  This value influences exactly how the up and down mixing is
performed.  The default value is "speakers".

<ul>
  <li><a
    href="#idl-def-ChannelInterpretation.speakers"><code>“speakers”</code></a>:
  use <a href="#ChannelLayouts">up-down-mix equations for
  mono/stereo/quad/5.1</a>.  In cases where the number of channels do not match
any of these basic speaker layouts, revert to "discrete".
</li>
<li><a
  href="#idl-def-ChannelInterpretation.discrete"><code>“discrete”</code></a>:
up-mix by filling channels until they run out then zero out remaining channels.
down-mix by filling as many channels as possible, then dropping remaining
channels</li>
</ul>

</li>

</ul>

<p>
For each input of an <a><code>AudioNode</code></a>, an implementation must:
</p>

<ol>
<li>Compute <a><code>computedNumberOfChannels</code></a>.</li>
<li>
  For each connection to the input:
  <ul>
    <li>
      up-mix or down-mix the connection to <a><code>computedNumberOfChannels</code></a>
      according to <a href="#widl-AudioNode-channelInterpretation"><code>channelInterpretation</code></a>.
    </li>
    <li>
      Mix it together with all of the other mixed streams (from other
      connections). This is a straight-forward mixing together of each of the
      corresponding channels from each
      connection.
    </li>
  </ul>
</li>
</ol>




<section>
  <h3 id="ChannelLayouts">Speaker Channel Layouts</h3>

  <p class="norm">This section is normative.</p>

  <p>
  When <a
    href="#widl-AudioNode-channelInterpretation"><code>channelInterpretation</code></a>
  is <a href="#idl-def-ChannelInterpretation.speakers">"speakers"</a> then the up-mixing and down-mixing
  is defined for specific channel layouts.
  </p>

  <p>It's important to define the channel ordering (and define some
  abbreviations) for these speaker layouts.</p>

  <p>
  For now, only considers cases for mono, stereo, quad, 5.1. Later other channel
  layouts can be defined.
  </p>
</section>

<section>
  <h4 id ="ChannelOrdering">Channel ordering</h4>

  <pre>  Mono
      0: M: mono

    Stereo
      0: L: left
      1: R: right
    </pre>

  <pre>  Quad
      0: L:  left
      1: R:  right
      2: SL: surround left
      3: SR: surround right

    5.1
      0: L:   left
      1: R:   right
      2: C:   center
      3: LFE: subwoofer
      4: SL:  surround left
      5: SR:  surround right
  </pre>
</section>

<section><h4 id="UpMix-sub">Up Mixing speaker layouts</h4>

<pre>Mono up-mix:

    1 -&gt; 2 : up-mix from mono to stereo
        output.L = input;
        output.R = input;

    1 -&gt; 4 : up-mix from mono to quad
        output.L = input;
        output.R = input;
        output.SL = 0;
        output.SR = 0;

    1 -&gt; 5.1 : up-mix from mono to 5.1
        output.L = 0;
        output.R = 0;
        output.C = input; // put in center channel
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Stereo up-mix:

    2 -&gt; 4 : up-mix from stereo to quad
        output.L = input.L;
        output.R = input.R;
        output.SL = 0;
        output.SR = 0;

    2 -&gt; 5.1 : up-mix from stereo to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Quad up-mix:

    4 -&gt; 5.1 : up-mix from quad to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = input.SL;
        output.SR = input.SR;</pre>

</section>

<section>
  <h4 id="down-mix">Down Mixing speaker layouts</h4>

  <p>A down-mix will be necessary, for example, if processing 5.1 source
  material, but playing back stereo. </p>
  <pre>
  Mono down-mix:

      2 -&gt; 1 : stereo to mono
          output = 0.5 * (input.L + input.R);

      4 -&gt; 1 : quad to mono
          output = 0.25 * (input.L + input.R + input.SL + input.SR);

      5.1 -&gt; 1 : 5.1 to mono
          output = 0.7071 * (input.L + input.R) + input.C + 0.5 * (input.SL + input.SR)


  Stereo down-mix:

      4 -&gt; 2 : quad to stereo
          output.L = 0.5 * (input.L + input.SL);
          output.R = 0.5 * (input.R + input.SR);

      5.1 -&gt; 2 : 5.1 to stereo
          output.L = L + 0.7071 * (input.C + input.SL)
          output.R = R + 0.7071 * (input.C + input.SR)

  Quad down-mix:

      5.1 -&gt; 4 : 5.1 to quad
          output.L = L + 0.7071 * input.C
          output.R = R + 0.7071 * input.C
          output.SL = input.SL
          output.SR = input.SR

  </pre>
</section>

<section class="informative">
  <h3 id="ChannelRules-section">Channel Rules Examples</h3>

  <pre class="highlight example">
  // Set gain node to explicit 2-channels (stereo).
  gain.channelCount = 2;
  gain.channelCountMode = "explicit";
  gain.channelInterpretation = "speakers";

  // Set "hardware output" to 4-channels for DJ-app with two stereo output busses.
  context.destination.channelCount = 4;
  context.destination.channelCountMode = "explicit";
  context.destination.channelInterpretation = "discrete";

  // Set "hardware output" to 8-channels for custom multi-channel speaker array
  // with custom matrix mixing.
  context.destination.channelCount = 8;
  context.destination.channelCountMode = "explicit";
  context.destination.channelInterpretation = "discrete";

  // Set "hardware output" to 5.1 to play an HTMLAudioElement.
  context.destination.channelCount = 6;
  context.destination.channelCountMode = "explicit";
  context.destination.channelInterpretation = "speakers";

  // Explicitly down-mix to mono.
  gain.channelCount = 1;
  gain.channelCountMode = "explicit";
  gain.channelInterpretation = "speakers";
  </pre>
</section>
</section>


<section>
<h2 id="Spatialization">Spatialization / Panning </h2>

<section>
  <h3 id="Spatialization-background">Background</h3>

  <p>A common feature requirement for modern 3D games is the ability to
  dynamically spatialize and move multiple audio sources in 3D space. Game audio
  engines such as OpenAL, FMOD, Creative's EAX, Microsoft's XACT Audio, etc. have
  this ability. </p>

  <p>Using an <a><code>PannerNode</code></a>, an audio stream can be spatialized or
  positioned in space relative to an <a><code>AudioListener</code></a>. An
  <a><code>AudioContext</code></a> will contain a
  single <a><code>AudioListener</code></a>. Both panners and listeners have a position
  in 3D space using a right-handed cartesian coordinate system.
  The units used in the coordinate system are not defined, and do not need to be
  because the effects calculated with these coordinates are independent/invariant
  of any particular units such as meters or feet.  <a><code>PannerNode</code></a>
  objects (representing the source stream) have an <em>orientation</em>
  vector representing in which direction the sound is projecting. Additionally,
  they have a <em>sound cone</em> representing how directional the sound is.
  For example, the sound could be omnidirectional, in which case it would be
  heard anywhere regardless of its orientation, or it can be more directional and
  heard only if it is facing the listener. <a><code>AudioListener</code></a> objects
  (representing a person's ears) have an <em>orientation</em> and
  <em>up</em> vector representing in which direction the person is facing.
  Because both the source stream and the listener can be moving, they both have a
  <em>velocity</em> vector representing both the speed and direction of
  movement. Taken together, these two velocities can be used to generate a
  doppler shift effect which changes the pitch. </p>

  <p>
  During rendering, the <a><code>PannerNode</code></a> calculates an <em>azimuth</em>
  and <em>elevation</em>.  These values are used internally by the implementation in
  order to render the spatialization effect.  See the <a
    href="#Spatialization-panning-algorithm">Panning Algorithm</a> section for
  details of how these values are used.
  </p>

  <p>
  The following algorithm must be used to calculate the <em>azimuth</em>
  and <em>elevation</em>:
  </p>

  <pre class="code highlight">
  // Calculate the source-listener vector.
  vec3 sourceListener = source.position - listener.position;

  if (sourceListener.isZero()) {
      // Handle degenerate case if source and listener are at the same point.
      azimuth = 0;
      elevation = 0;
      return;
  }

  sourceListener.normalize();

  // Align axes.
  vec3 listenerFront = listener.orientation;
  vec3 listenerUp = listener.up;
  vec3 listenerRight = listenerFront.cross(listenerUp);
  listenerRight.normalize();

  vec3 listenerFrontNorm = listenerFront;
  listenerFrontNorm.normalize();

  vec3 up = listenerRight.cross(listenerFrontNorm);

  float upProjection = sourceListener.dot(up);

  vec3 projectedSource = sourceListener - upProjection * up;
  projectedSource.normalize();

  azimuth = 180 * acos(projectedSource.dot(listenerRight)) / PI;

  // Source in front or behind the listener.
  float frontBack = projectedSource.dot(listenerFrontNorm);
  if (frontBack &lt; 0)
      azimuth = 360 - azimuth;

  // Make azimuth relative to "front" and not "right" listener vector.
  if ((azimuth &gt;= 0) &amp;&amp; (azimuth &lt;= 270))
      azimuth = 90 - azimuth;
  else
      azimuth = 450 - azimuth;

  elevation = 90 - 180 * acos(sourceListener.dot(up)) / PI;

  if (elevation &gt; 90)
      elevation = 180 - elevation;
  else if (elevation &lt; -90)
      elevation = -180 - elevation;
  </pre>
</section>

<section>
  <h3 id="Spatialization-panning-algorithm">Panning Algorithm</h3>

  <p>
  <em>mono->stereo</em> and <em>stereo->stereo</em>  panning must be supported.
  <em>mono->stereo</em> processing is used when all connections to the input are mono.
  Otherwise <em>stereo->stereo</em> processing is used.</p>

  <p>The following algorithms must be implemented: </p>
  <ul>
    <li>Equal-power (Vector-based) panning
      <p>This is a simple and relatively inexpensive algorithm which provides
      basic, but reasonable results.  It is commonly used when panning musical sources.
      </p>
      The <em>elevation</em> value is ignored in this panning algorithm.

      <p>
      The following steps are used for processing:
      </p>

      <ol>

      <li>
      <p>
      The <em>azimuth</em> value is first contained to be within the range -90 &lt;= <em>azimuth</em> &lt;= +90 according to:
      </p>
      <pre class="highlight">
      // Clamp azimuth to allowed range of -180 -&gt; +180.
      azimuth = max(-180, azimuth);
      azimuth = min(180, azimuth);

      // Now wrap to range -90 -&gt; +90.
      if (azimuth &lt; -90)
          azimuth = -180 - azimuth;
      else if (azimuth &gt; 90)
          azimuth = 180 - azimuth;
      </pre>
      </li>

      <li>
      <p>
      A 0 -&gt; 1 normalized value <em>x</em> is calculated from <em>azimuth</em> for <em>mono->stereo</em> as:
      </p>
      <pre class="highlight">
      x = (azimuth + 90) / 180
      </pre>

      <p>
      Or for <em>stereo->stereo</em> as:
      </p>
      <pre class="highlight">
      if (azimuth &lt;= 0) { // from -90 -&gt; 0
          // inputL -> outputL and "equal-power pan" inputR as in mono case
          // by transforming the "azimuth" value from -90 -&gt; 0 degrees into the range -90 -&gt; +90.
          x = (azimuth + 90) / 90;
      } else { // from 0 -> +90
          // inputR -> outputR and "equal-power pan" inputL as in mono case
          // by transforming the "azimuth" value from 0 -&gt; +90 degrees into the range -90 -&gt; +90.
          x = azimuth / 90;
      }
      </pre>
      </li>

      <li>
      <p>
      Left and right gain values are then calculated:
      </p>
      <pre class="highlight">
      gainL = cos(0.5 * PI * x);
      gainR = sin(0.5 * PI * x);
      </pre>
      </li>

      <li>
      <p>For <em>mono->stereo</em>, the output is calculated as:</p>
      <pre class="highlight">
      outputL = input * gainL
      outputR = input * gainR
      </pre>
      <p>Else for <em>stereo->stereo</em>, the output is calculated as:</p>
      <pre class="highlight">
      if (azimuth &lt;= 0) { // from -90 -&gt; 0
          outputL = inputL + inputR * gainL;
          outputR = inputR * gainR;
      } else { // from 0 -&gt; +90
          outputL = inputL * gainL;
          outputR = inputR + inputL * gainR;
      }
      </pre>
      </li>

      </ol>



    </li>
    <li><a
      href="http://en.wikipedia.org/wiki/Head-related_transfer_function">HRTF</a>
      panning (stereo only).
      <p>This requires a set of HRTF impulse responses recorded at a variety of
      azimuths and elevations. There are a small number of open/free impulse
      responses available. The implementation requires a highly optimized
      convolution function. It is somewhat more costly than "equal-power", but
      provides a more spatialized sound. </p>
      <figure>
        <img alt="HRTF panner" src="images/HRTF_panner.png" />
        <figcaption>A diagram showing the process of panning a source using
        HRTF.</figcaption>
      </figure>
    </li>
  </ul>
</section>

<section>
  <h3 id="Spatialization-distance-effects">Distance Effects</h3>
  <p>
  Sounds which are closer are louder, while sounds further away are quieter.
  Exactly <em>how</em> a sound's volume changes according to distance from the listener
  depends on the <em>distanceModel</em> attribute.
  </p>


  <p>
  During audio rendering, a <em>distance</em> value will be calculated based on the panner and listener positions according to:
  </p>
  <pre class="highlight">
  v = panner.position - listener.position
  </pre>
  <pre class="highlight">
  distance = sqrt(dot(v, v))
  </pre>

  <p>
  <em>distance</em> will then be used to calculate <em>distanceGain</em> which
  depends on the <em>distanceModel</em> attribute.  See the <a
  href="#idl-def-DistanceModelType">distanceModel</a> section for details of
how this is calculated for each distance model.
  </p>
  <p>As part of its processing, the <a><code>PannerNode</code></a> scales/multiplies the input audio signal by <em>distanceGain</em>
  to make distant sounds quieter and nearer ones louder.
  </p>
</section>

<section>
  <h3 id="Spatialization-sound-cones">Sound Cones</h3>

  <p>The listener and each sound source have an orientation vector describing
  which way they are facing. Each sound source's sound projection characteristics
  are described by an inner and outer "cone" describing the sound intensity as a
  function of the source/listener angle from the source's orientation vector.
  Thus, a sound source pointing directly at the listener will be louder than if
  it is pointed off-axis. Sound sources can also be omni-directional. </p>

  <p>
  The following algorithm must be used to calculate the gain contribution due
  to the cone effect, given the source (the <a><code>PannerNode</code></a>)
  and the listener:
  </p>

  <pre class="highlight">
  if (source.orientation.isZero() || ((source.coneInnerAngle == 360) &amp;&amp; (source.coneOuterAngle == 360)))
      return 1; // no cone specified - unity gain

  // Normalized source-listener vector
  vec3 sourceToListener = listener.position - source.position;
  sourceToListener.normalize();

  vec3 normalizedSourceOrientation = source.orientation;
  normalizedSourceOrientation.normalize();

  // Angle between the source orientation vector and the source-listener vector
  float dotProduct = sourceToListener.dot(normalizedSourceOrientation);
  float angle = 180 * acos(dotProduct) / PI;
  float absAngle = fabs(angle);

  // Divide by 2 here since API is entire angle (not half-angle)
  float absInnerAngle = fabs(source.coneInnerAngle) / 2;
  float absOuterAngle = fabs(source.coneOuterAngle) / 2;
  float gain = 1;

  if (absAngle &lt;= absInnerAngle)
      // No attenuation
      gain = 1;
  else if (absAngle &gt;= absOuterAngle)
      // Max attenuation
      gain = source.coneOuterGain;
  else {
      // Between inner and outer cones
      // inner -&gt; outer, x goes from 0 -&gt; 1
      float x = (absAngle - absInnerAngle) / (absOuterAngle - absInnerAngle);
      gain = (1 - x) + source.coneOuterGain * x;
  }

  return gain;
  </pre>
</section>

<section>
<h3 id="Spatialization-doppler-shift">Doppler Shift</h3>
  <ul>
    <li>Introduces a pitch shift which can realistically simulate moving
    sources.</li>
    <li>Depends on: source / listener velocity vectors, speed of sound, doppler
      factor.</li>
  </ul>

  <p>
  The following algorithm must be used to calculate the doppler shift value
  which is used as an additional playback rate scalar for all
  <a><code>AudioBufferSourceNode</code></a>s connecting directly or indirectly
  to the <a><code>PannerNode</code></a>:
  </p>

  <pre class="highlight">
  float dopplerShift = 1; // Initialize to default value
  float dopplerFactor = listener.dopplerFactor;

  if (dopplerFactor &gt; 0) {
      float speedOfSound = listener.speedOfSound;

      // Don't bother if both source and listener have no velocity.
      if (!source.velocity.isZero() || !listener.velocity.isZero()) {
          // Calculate the source to listener vector.
          vec3 sourceToListener = source.position - listener.position;

          float sourceListenerMagnitude = sourceToListener.length();

          float listenerProjection = sourceToListener.dot(listener.velocity) / sourceListenerMagnitude;
          float sourceProjection = sourceToListener.dot(source.velocity) / sourceListenerMagnitude;

          listenerProjection = -listenerProjection;
          sourceProjection = -sourceProjection;

          float scaledSpeedOfSound = speedOfSound / dopplerFactor;
          listenerProjection = min(listenerProjection, scaledSpeedOfSound);
          sourceProjection = min(sourceProjection, scaledSpeedOfSound);

          dopplerShift = ((speedOfSound - dopplerFactor * listenerProjection) / (speedOfSound - dopplerFactor * sourceProjection));
          fixNANs(dopplerShift); // Avoid illegal values

          // Limit the pitch shifting to 4 octaves up and 3 octaves down.
          dopplerShift = min(dopplerShift, 16);
          dopplerShift = max(dopplerShift, 0.125);
      }
  }
  </pre>
</section>
</section>

<section>
<h2 id="Convolution">Linear Effects using Convolution</h2>

<section>
  <h3 id="Convolution-background">Background</h3>

  <p><a href="http://en.wikipedia.org/wiki/Convolution">Convolution</a> is a
  mathematical process which can be applied to an audio signal to achieve many
  interesting high-quality linear effects. Very often, the effect is used to
  simulate an acoustic space such as a concert hall, cathedral, or outdoor
  amphitheater. It can also be used for complex filter effects, like a muffled
  sound coming from inside a closet, sound underwater, sound coming through a
  telephone, or playing through a vintage speaker cabinet. This technique is very
  commonly used in major motion picture and music production and is considered to
  be extremely versatile and of high quality. </p>

  <p>Each unique effect is defined by an <em>impulse response</em>. An
  impulse response can be represented as an audio file and <a
  href="#recording-impulse-responses">can be recorded</a> from a real acoustic
  space such as a cave, or can be synthetically generated through a great variety
  of techniques. </p>
</section>

<section>
  <h3 id="Convolution-motivation">Motivation for use as a Standard</h3>

  <p>A key feature of many game audio engines (OpenAL, FMOD, Creative's EAX,
  Microsoft's XACT Audio, etc.) is a reverberation effect for simulating the
  sound of being in an acoustic space. The code used to generate this effect
  has generally been custom and algorithmic (generally using a hand-tweaked set
  of delay lines and allpass filters which feedback into each other). In nearly
  all cases, not only is the implementation custom, but the code is proprietary
  and closed-source, each company adding its own "black magic" to achieve its
  unique quality. Each implementation being custom with a different set of
  parameters makes it impossible to achieve a uniform desired effect. And the
  code being proprietary makes it impossible to adopt a single one of the
  implementations as a standard. Additionally, algorithmic reverberation effects
  are limited to a relatively narrow range of different effects, regardless of
  how the parameters are tweaked. </p>

  <p>A convolution effect solves these problems by using a very precisely defined
  mathematical algorithm as the basis of its processing. An impulse response
  represents an exact sound effect to be applied to an audio stream and is easily
  represented by an audio file which can be referenced by URL. The range of
  possible effects is enormous. </p>
</section>

<section>
  <h3 id="Convolution-implementation-guide">Implementation Guide</h3>
  <p>
  Linear convolution can be implemented efficiently.
  Here are some <a href="convolution.html">notes</a>
  describing how it can be practically implemented.
  </p>
</section>

<section>
  <h3 id="Convolution-reverb-effect">Reverb Effect (with matrixing)</h3>

  <p class="norm">This section is normative.</p>

  <p>
  In the general case the source
  has N input channels, the impulse response has K channels, and the playback
  system has M output channels. Thus it's a matter of how to matrix these
  channels to achieve the final result.
  </p>

  <p>
  The subset of N, M, K below must be implemented (note that the first image in the diagram is just illustrating
  the general case and is not normative, while the following images are normative).
  Without loss of generality, developers desiring more complex and arbitrary
  matrixing can use multiple <a><code>ConvolverNode</code></a>
  objects in conjunction with an <a><code>ChannelMergerNode</code></a>.
  </p>


  <p>Single channel convolution operates on a mono audio input, using a mono
  impulse response, and generating a mono output. To achieve a more spacious sound, 2 channel audio
  inputs and 1, 2, or 4 channel impulse responses will be considered. The following diagram, illustrates the
  common cases for stereo playback where N and M are 1 or 2 and K is 1, 2, or 4.
  </p>
  <figure>
    <img alt="reverb matrixing" src="images/reverb-matrixing.png" />
    <figcaption>A graphical representation of the different input and output channel
    count possibilities when using a <a><code>ConvolverNode</code></a>.</figcaption>
  </figure>
</section>

<section>
<h2 id="Performance">Performance Considerations</h2>

<section>
  <h3>Latency</h3>
  <figure>
    <img alt="latency" src="images/latency.png" />
    <figcaption>Use cases in which the latency can be important</figcaption>
  </figure>

  <p>For web applications, the time delay between mouse and keyboard events
  (keydown, mousedown, etc.) and a sound being heard is important. </p>

  <p>This time delay is called latency and is caused by several factors (input
  device latency, internal buffering latency, DSP processing latency, output
  device latency, distance of user's ears from speakers, etc.), and is
  cummulative. The larger this latency is, the less satisfying the user's
  experience is going to be. In the extreme, it can make musical production or
  game-play impossible. At moderate levels it can affect timing and give the
  impression of sounds lagging behind or the game being non-responsive. For
  musical applications the timing problems affect rhythm. For gaming, the timing
  problems affect precision of gameplay. For interactive applications, it
  generally cheapens the users experience much in the same way that very low
  animation frame-rates do. Depending on the application, a reasonable latency
  can be from as low as 3-6 milliseconds to 25-50 milliseconds. </p>
</section>

<section>
<h3>Audio buffer copying</h3>
<p>
  When an <a href="#acquire-the-content">acquire the content</a> operation is
  performed on an <a>AudioBuffer</a>, the entire operation can usually be
  implemented without copying channel data. In particular, the last step should be
  performed lazily at the next
  <a href="#widl-AudioBuffer-getChannelData-Float32Array-unsigned-long-channel">
  <code>getChannelData</code></a> call. That means a sequence of consecutive
  <a href="#acquire-the-content">acquire the contents</a> operations with no
  intervening
  <a href="#widl-AudioBuffer-getChannelData-Float32Array-unsigned-long-channel">
    <code>getChannelData</code></a> (e.g. multiple
  <a><code>AudioBufferSourceNode</code></a>s playing the same
  <a><code>AudioBuffer</code></a>) can be implemented with no allocations or
  copying.
</p>

<p>
  Implementations can perform an additional optimization: if
  <a href="#widl-AudioBuffer-getChannelData-Float32Array-unsigned-long-channel">
  getChannelData</a> is called on an <a>AudioBuffer</a>, fresh
  <code>ArrayBuffer</code>s have not yet been allocated, but all invokers of
  previous <a href="#acquire-the-content">acquire the content</a> operations on
  an <a>AudioBuffer</a> have stopped using the <a>AudioBuffer</a>'s data, the
  raw data buffers can be recycled for use with new <a>AudioBuffer</a>s,
  avoiding any reallocation or copying of the channel data.
</p>
</section>

<section>
  <h3>Audio Glitching</h3>

  <p>Audio glitches are caused by an interruption of the normal continuous audio
  stream, resulting in loud clicks and pops. It is considered to be a
  catastrophic failure of a multi-media system and must be avoided. It can be
  caused by problems with the threads responsible for delivering the audio stream
  to the hardware, such as scheduling latencies caused by threads not having the
  proper priority and time-constraints. It can also be caused by the audio DSP
  trying to do more work than is possible in real-time given the CPU's speed. </p>
</section>

<section class=informative>
  <h3>Hardware Scalability</h3>

  <p>The system should gracefully degrade to allow audio processing under
  resource constrained conditions without dropping audio frames. </p>

  <p>First of all, it should be clear that regardless of the platform, the audio
  processing load should never be enough to completely lock up the machine.
  Second, the audio rendering needs to produce a clean, un-interrupted audio
  stream without audible <a href="#audio-glitching">glitches</a>. </p>

  <p>The system should be able to run on a range of hardware, from mobile phones
  and tablet devices to laptop and desktop computers. The more limited
  compute resources on a phone device make it necessary to consider techniques to
  scale back and reduce the complexity of the audio rendering. For example,
  voice-dropping algorithms can be implemented to reduce the total number of
  notes playing at any given time. </p>

  <p>Here's a list of some techniques which can be used to limit CPU usage: </p>

  <section>
    <h4 id="CPU-monitoring">CPU monitoring</h4>

    <p>In order to avoid audio breakup, CPU usage must remain below 100%. </p>

  <p>The relative CPU usage can be dynamically measured for each <a><code>AudioNode</code></a> (and
    chains of connected nodes) as a percentage of the rendering time quantum. In a
    single-threaded implementation, overall CPU usage must remain below 100%. The
    measured usage may be used internally in the implementation for dynamic
    adjustments to the rendering. It may also be exposed through a
    <code>cpuUsage</code> attribute of <a><code>AudioNode</code></a> for use by
    JavaScript. </p>

    <p>In cases where the measured CPU usage is near 100% (or whatever threshold is
    considered too high), then an attempt to add additional <a><code>AudioNode</code></a>s
    into the rendering graph can trigger voice-dropping. </p>
  </section>

  <section>
    <h4 id="Voice-dropping">Voice Dropping</h4>

    <p>Voice-dropping is a technique which limits the number of voices (notes)
    playing at the same time to keep CPU usage within a reasonable range. There can
    either be an upper threshold on the total number of voices allowed at any given
    time, or CPU usage can be dynamically monitored and voices dropped when CPU
    usage exceeds a threshold. Or a combination of these two techniques can be
    applied. When CPU usage is monitored for each voice, it can be measured all the
    way from a source node through any effect processing nodes which apply
    uniquely to that voice. </p>

    <p>When a voice is "dropped", it needs to happen in such a way that it doesn't
    introduce audible clicks or pops into the rendered audio stream. One way to
    achieve this is to quickly fade-out the rendered audio for that voice before
    completely removing it from the rendering graph. </p>

    <p>When it is determined that one or more voices must be dropped, there are
    various strategies for picking which voice(s) to drop out of the total ensemble
    of voices currently playing. Here are some of the factors which can be used in
    combination to help with this decision: </p>
    <ul>
      <li>Older voices, which have been playing the longest can be dropped instead
        of more recent voices. </li>
      <li>Quieter voices, which are contributing less to the overall mix may be
        dropped instead of louder ones. </li>
      <li>Voices which are consuming relatively more CPU resources may be dropped
        instead of less "expensive" voices.</li>
      <li>An <a><code>AudioNode</code></a> can have a <code>priority</code>
      attribute to help determine the relative importance of the
      voices.</li>
    </ul>
  </section>

  <section>
    <h4 id="Simplification-of-Effects-Processing">Simplification of Effects
    Processing</h4>

    <p>Most of the effects described in this document are relatively inexpensive
    and will likely be able to run even on the slower mobile devices. However, the
    <a href="#ConvolverNode">convolution effect</a> can be configured with
    a variety of impulse responses, some of which will likely be too heavy for
    mobile devices. Generally speaking, CPU usage scales with the length of the
    impulse response and the number of channels it has. Thus, it is reasonable to
    consider that impulse responses which exceed a certain length will not be
    allowed to run. The exact limit can be determined based on the speed of the
    device. Instead of outright rejecting convolution with these long responses, it
    may be interesting to consider truncating the impulse responses to the maximum
    allowed length and/or reducing the number of channels of the impulse response.
    </p>

    <p>In addition to the convolution effect. The <a><code>PannerNode</code></a>
    may also be expensive if using the HRTF panning model. For slower devices, a
    cheaper algorithm such as EQUALPOWER can be used to conserve compute
    resources. </p>
  </section>

  <section>
    <h4 id="Sample-rate">Sample Rate</h4>

    <p>For very slow devices, it may be worth considering running the rendering at
    a lower sample-rate than normal. For example, the sample-rate can be reduced
    from 44.1KHz to 22.05KHz. This decision must be made when the
    <a><code>AudioContext</code></a> is created, because changing the sample-rate
    on-the-fly can be difficult to implement and will result in audible glitching
    when the transition is made. </p>
  </section>

  <section>
    <h4 id="pre-flighting">Pre-flighting</h4>

    <p>It should be possible to invoke some kind of "pre-flighting" code (through
    JavaScript) to roughly determine the power of the machine. The JavaScript code
    can then use this information to scale back any more intensive processing it
    may normally run on a more powerful machine. Also, the underlying
    implementation may be able to factor in this information in the voice-dropping
    algorithm. </p>

    <p><span class="ednote">TODO: add specification and more detail here </span></p>
  </section>

  <section>
    <h4 id="Authoring-for-different-user-agents">Authoring for different
    user agents</h4>
    JavaScript code can use information about user-agent to scale back any more
    intensive processing it may normally run on a more powerful machine.
  </section>

  <section>
    <h4 id="Scalability-of-Direct-JavaScript-Synthesis">Scalability of Direct JavaScript Synthesis / Processing</h4>

    <p>Any audio DSP / processing code done directly in JavaScript should also be
    concerned about scalability. To the extent possible, the JavaScript code itself
    needs to monitor CPU usage and scale back any more ambitious processing when
    run on less powerful devices. If it's an "all or nothing" type of processing,
    then user-agent check or pre-flighting should be done to avoid generating an
    audio stream with audio breakup. </p>
  </section>
</section>

<section>
<h3 id="JavaScriptPerformance">JavaScript Issues with real-time Processing and Synthesis: </h3>
While processing audio in JavaScript, it is extremely challenging to get
reliable, glitch-free audio while achieving a reasonably low-latency,
especially under heavy processor load.
<ul>
  <li>JavaScript is very much slower than heavily optimized C++ code and is not
    able to take advantage of SSE optimizations and multi-threading which is
    critical for getting good performance on today's processors. Optimized
    native code can be on the order of twenty times faster for processing FFTs
    as compared with JavaScript. It is not efficient enough for heavy-duty
    processing of audio such as convolution and 3D spatialization of large
    numbers of audio sources. </li>
  <li>setInterval() and XHR handling will steal time from the audio processing.
    In a reasonably complex game, some JavaScript resources will be needed for
    game physics and graphics. This creates challenges because audio rendering
    is deadline driven (to avoid glitches and get low enough latency).</li>
  <li>JavaScript does not run in a real-time processing thread and thus can be
    pre-empted by many other threads running on the system.</li>
  <li>Garbage Collection (and autorelease pools on Mac OS X) can cause
    unpredictable delay on a JavaScript thread. </li>
  <li>Multiple JavaScript contexts can be running on the main thread, stealing
    time from the context doing the processing. </li>
  <li>Other code (other than JavaScript) such as page rendering runs on the
    main thread. </li>
  <li>Locks can be taken and memory is allocated on the JavaScript thread. This
    can cause additional thread preemption. </li>
</ul>
The problems are even more difficult with today's generation of mobile devices
which have processors with relatively poor performance and power consumption /
battery-life issues.
</section>
</section>

<section class="informative">
  <h2 id="SecurityConsiderations">Security Considerations</h2>
</section>

<section class="informative">
  <h2 id="PrivacyConsiderations">Privacy Considerations</h2>

  <p>When giving various information on
  available <a><code>AudioNode</code></a>s, the Web Audio API potentially exposes information on
  characteristic features of the client (such as audio hardware sample-rate) to
  any page that makes use of the <a><code>AudioNode</code></a> interface. Additionally, timing
  information can be collected through the <a><code>AnalyserNode</code></a> or
  <a><code>ScriptProcessorNode</code></a> interface. The information could subsequently be used to
  create a fingerprint of the client. </p>

  <p>Currently audio input is not specified in this document, but it will involve
  gaining access to the client machine's audio input or microphone. This will
  require asking the user for permission in an appropriate way, probably via the
  <a href="http://developers.whatwg.org/">getUserMedia()
  API</a>. </p>
</section>

<section>
  <h2 id="requirements">Requirements and Use Cases</h2>

  <p>Please see <a href="#ExampleApplications">Example Applications</a>
  </p>
</section>

<section>
<h2>Acknowledgements</h2>
<p>This specification is the collective work of the W3C <a href="http://www.w3.org/2011/audio/">Audio Working Group</a>.</p>

<p>Members of the Working Group are (at the time of writing, and by alphabetical order): <br />
Adenot, Paul (Mozilla Foundation);
Akhgari, Ehsan (Mozilla Foundation);
Berkovitz, Joe (Invited Expert);
Bossart, Pierre (Intel Corporation);
Carlson, Eric (Apple, Inc.);
Geelnard, Marcus (Opera Software);
Goode, Adam (Google, Inc.);
Gregan, Matthew (Mozilla Foundation);
Jägenstedt, Philip (Opera Software);
Kalliokoski, Jussi (Invited Expert);
Lilley, Chris (W3C Staff);
Lowis, Chris (Invited Expert. WG co-chair from December 2012 to September 2013, affiliated with British Broadcasting Corporation);
Mandyam, Giridhar (Qualcomm Innovation Center, Inc);
Noble, Jer (Apple, Inc.);
O'Callahan, Robert(Mozilla Foundation);
Onumonu, Anthony (British Broadcasting Corporation);
Paradis, Matthew (British Broadcasting Corporation);
Raman, T.V. (Google, Inc.);
Schepers, Doug (W3C/MIT);
Shires, Glen (Google, Inc.);
Smith, Michael (W3C/Keio);
Thereaux, Olivier (British Broadcasting Corporation) – WG Chair;
Verdie, Jean-Charles (MStar Semiconductor, Inc.);
Wilson, Chris (Google,Inc.);
ZERGAOUI, Mohamed (INNOVIMAX)
</p>

<p>Former members of the Working Group and contributors to the specification include:<br />
Caceres, Marcos (Invited Expert);
Cardoso, Gabriel (INRIA);
Chen, Bin (Baidu, Inc.);
MacDonald, Alistair (W3C Invited Experts) — WG co-chair from March 2011 to July 2012;
Michel, Thierry (W3C/ERCIM);
Rogers, Chris (Google, Inc.) – Specification Editor until August 2013;
Wei, James (Intel Corporation);
</p>

</section>

<section>
<h2 id="ChangeLog">Web Audio API Change Log</h2>
<p>See <a href="changelog.html">changelog.html</a>.</p>
</section>
</body>
</html>
