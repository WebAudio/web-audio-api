<!DOCTYPE html>
<html>
  <head>
    <title>
      Web Audio API
    </title>
    <meta charset="utf-8">
    <link rel="icon" href="favicon.png">
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class=
    'remove'></script>
    <link rel="preload" href=
    "https://www.w3.org/scripts/MathJax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    as="script">
    <link rel="preload" href=
    "https://www.w3.org/scripts/MathJax/2.6.1/jax/output/HTML-CSS/jax.js?rev=2.6.1"
    as="script">
    <link rel="preload" href=
    "https://www.w3.org/scripts/MathJax/2.6.1/jax/output/HTML-CSS/fonts/STIX/fontdata.js?rev=2.6.1"
    as="script">
    <link rel="preload" href=
    "https://www.w3.org/scripts/MathJax/2.6.1/config/TeX-AMS-MML_HTMLorMML.js?rev=2.6.1"
    as="script">
    <link rel="preload" href=
    "https://www.w3.org/scripts/MathJax/2.6.1/jax/element/mml/optable/BasicLatin.js?rev=2.6.1"
    as="script">
    <link rel="preload" href=
    "https://www.w3.org/scripts/MathJax/2.6.1/jax/output/HTML-CSS/autoload/mtable.js?rev=2.6.1"
    as="script">
    <script class='remove'>
    var respecConfig = {
        specStatus: "ED",
        shortName:  "webaudio",
        edDraftURI: "https://webaudio.github.io/web-audio-api/",
        editors: [
              {   name:       "Paul Adenot",
                  company:    "Mozilla",
                  companyURL: "https://www.mozilla.org/",
                  mailto:     "padenot@mozilla.com",
                  w3cid:      "62410" },
              {
                  name:       "Raymond Toy",
                  company:    "Google, Inc.",
                  companyURL: "https://www.google.com/",
                  mailto:     "rtoy@google.com",
                  w3cid:      "66910" },
        ],

        license:      "w3c-software-doc",

        previousMaturity: "WD",
        previousPublishDate:  "2013-10-10",
        previousURI:  "https://www.w3.org/TR/2012/WD-webaudio-20121213/",
        wg:           "Audio Working Group",
        wgURI:        "https://www.w3.org/2011/audio/",
        wgPublicList: "public-audio",
        wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/46884/status",
        tocIntroductory: true,
        copyrightStart: 2013,
        testSuiteURI: "https://github.com/w3c/web-platform-tests/tree/master/webaudio",
        otherLinks: [
          {
            key: "Previous editors",
            data : [{value: "Chris Wilson (Until January 2016)"},
                    {value: "Chris Rogers (Until August 2013)"}] },
          {
            key: "Repository",
            href: "https://github.com/WebAudio/web-audio-api" },
          {
            key: "Bug tracker",
            href: "https://github.com/WebAudio/web-audio-api/issues?state=open" },
        ]
    };
    </script>
    <script>
    function findBadLink () {
      var old = document.querySelectorAll(".badLink");
      for (var i = 0 ; i < old.length; i++) {
        nodes[i].style.backgroundColor = "";
        nodes[i].classList.remove("badLink");
      }
      var nodes = document.querySelectorAll('a');

      for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].href) {
              var id =  nodes[i].href.split("/");
              id = id[id.length - 1];
              if (id.length != 0) {
                  if (id[0] == "#") {
                      if (document.querySelectorAll(id).length == 0) {
                        nodes[i].style.backgroundColor = "red";
                        nodes[i].classList.add("badLink");
                        console.log(nodes[i].textContent);
                    }
                 }
              }
          } else {
            nodes[i].style.backgroundColor = "red";
            nodes[i].classList.add("badLink");
          }
      }
    }

    function findMissingLink() {
      var codetags = document.querySelectorAll("code");

      for (var i = 0; i < codetags.length; i++) {
        if (!(codetags[i].parentNode instanceof HTMLAnchorElement) ||
            codetags[i].parentNode.href == "") {
          codetags[i].style.backgroundColor = 'hotpink';
          codetags[i].style.color  = 'yellow';

          console.log(codetags[i].innerHTML);
        }
      }
    }

    window.addEventListener("DOMContentLoaded", function () {
      "use strict";
      // Don't run MathJax during spec generation
      if (navigator.userAgent === "respec2html") {
        return;
      }
      new Promise(function (resolve, reject) {
        var mathjax = document.createElement('script');
        var url = "https://www.w3.org/scripts/MathJax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
        // Safari doesn't (yet) support load event on scripts so we have to poll. So ðŸ˜¢.
        var id = setInterval(function () {
          if (window.MathJax) {
            clearInterval(id);
            resolve();
          }
        }, 100);
        mathjax.onload = function () {
          clearInterval(id);
          resolve();
        };
        mathjax.onerror = function (err) {
          var error = (err instanceof Event)  ? new Error(err.message) : err;
          reject(error);
        };
        // Time out waiting after 20 seconds and reject.
        setTimeout(function(){
          mathjax.onerror(new Error("Loading timed out."));
        }, 20000);
        mathjax.id = "mathjax";
        mathjax.src = url;
        document.body.appendChild(mathjax);
      }).then(function () {
        MathJax.Hub.Config({
          tex2jax: {
            skipTags: ["script", "noscript", "style", "textarea", "code"]
          }
        });
      }).catch(function (error) {
        console.error(error);
      });
    });
    </script>
    <style>
    .todo {
      border: 1px solid red;
      background-color: rgba(255, 0, 0, 0.3);
    }
    .todo:before {
      content: "TODO:";
    }
    .synchronous:before {
      content: "âŒ› ";
    }
    .synchronous:hover{
      border-bottom: 1px dotted gray;
    }
    body#respecDocument {
      max-width: 60em;
    }
    .seclist > p {
      font-style: italic;
    }
    table.channels {
      width:100%;
      overflow: auto;
      margin: 0;
      font-size: 14px;
      font-family: /*Consolas, Monaco,*/ monospace;
    }
    table.channels th {
      width:60px;
      text-align:center;
    } 
    table.channels td {
      width:60px;
      text-align:center;
    } 
    table.channels tr:nth-child(even) {
      background: #EEE;
    }
    table.channels tr:nth-child(odd) {
      background: #FFF;
    }
    div.node-info {
      padding-left: 4em;
      padding-right: 4em;
    }                      
    div.node-info > table {
      border-collapse: collapse;
      border-top: 2px solid #707070;
      border-bottom: 2px solid #707070;
      width: 100%;
      margin: 2em 0;
    }
    div.node-info > table > tbody > tr > th,
    div.node-info > table > tbody > tr > td {
      padding: 0.2em 0.6em;
      min-width: 150px;
      border-top: 1px solid #ddd                      
    }
    div.node-info > table > tbody > tr > th {
      line-height: 2em;
      font-weight: 600;
      color: #178217;
      border-bottom: 1px solid #707070;
    }
    div.audioparam-info {
      padding-left: 2em;
      padding-right: 4em;
    }                      
    div.audioparam-info > table {
      border-collapse: collapse;
      border-top: 2px solid #707070;
      border-bottom: 2px solid #707070;
      width: 100%;
      margin: 2em 0;
    }
    div.audioparam-info > table > tbody > tr > th,
    div.audioparam-info > table > tbody > tr > td {
      padding: 0.2em 0.6em;
      min-width: 150px;
      border-top: 1px solid #ddd                      
    }
    div.audioparam-info > table > tbody > tr > th {
      line-height: 2em;
      font-weight: 600;
      color: #178217;
      border-bottom: 1px solid #707070;
    }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        This specification describes a high-level Web <abbr title=
        "Application Programming Interface">API</abbr> for processing and
        synthesizing audio in web applications. The primary paradigm is of an
        audio routing graph, where a number of <a><code>AudioNode</code></a>
        objects are connected together to define the overall audio rendering.
        The actual processing will primarily take place in the underlying
        implementation (typically optimized Assembly / C / C++ code), but
        <a href="#AudioWorklet">direct script processing and synthesis</a> is
        also supported.
      </p>
      <p>
        The <a href="#introduction">introductory</a> section covers the
        motivation behind this specification.
      </p>
      <p>
        This API is designed to be used in conjunction with other APIs and
        elements on the web platform, notably: XMLHttpRequest [[XHR]] (using
        the <code>responseType</code> and <code>response</code> attributes).
        For games and interactive applications, it is anticipated to be used
        with the <code>canvas</code> 2D [[2dcontext]] and WebGL [[WEBGL]] 3D
        graphics APIs.
      </p>
    </section>
    <section id="sotd"></section>
    <section class="introductory">
      <h2>
        Introduction
      </h2>
      <p>
        Audio on the web has been fairly primitive up to this point and until
        very recently has had to be delivered through plugins such as Flash and
        QuickTime. The introduction of the <code>audio</code> element in HTML5
        is very important, allowing for basic streaming audio playback. But, it
        is not powerful enough to handle more complex audio applications. For
        sophisticated web-based games or interactive applications, another
        solution is required. It is a goal of this specification to include the
        capabilities found in modern game audio engines as well as some of the
        mixing, processing, and filtering tasks that are found in modern
        desktop audio production applications.
      </p>
      <p>
        The APIs have been designed with a wide variety of use cases
        [[webaudio-usecases]] in mind. Ideally, it should be able to support
        <i>any</i> use case which could reasonably be implemented with an
        optimized C++ engine controlled via script and run in a browser. That
        said, modern desktop audio software can have very advanced
        capabilities, some of which would be difficult or impossible to build
        with this system. Apple's Logic Audio is one such application which has
        support for external MIDI controllers, arbitrary plugin audio effects
        and synthesizers, highly optimized direct-to-disk audio file
        reading/writing, tightly integrated time-stretching, and so on.
        Nevertheless, the proposed system will be quite capable of supporting a
        large range of reasonably complex games and interactive applications,
        including musical ones. And it can be a very good complement to the
        more advanced graphics features offered by WebGL. The API has been
        designed so that more advanced capabilities can be added at a later
        time.
      </p>
      <section>
        <h2 id="Features">
          Features
        </h2>
        <p>
          The API supports these primary features:
        </p>
        <ul>
          <li>
            <a href="#ModularRouting">Modular routing</a> for simple or complex
            mixing/effect architectures, including <a href=
            "#mixer-gain-structure">multiple sends and submixes</a>.
          </li>
          <li>High dynamic range, using 32bits floats for internal processing.
          </li>
          <li>
            <a href="#AudioParam">Sample-accurate scheduled sound playback</a>
            with low <a href="#latency">latency</a> for musical applications
            requiring a very high degree of rhythmic precision such as drum
            machines and sequencers. This also includes the possibility of
            <a href="#DynamicLifetime">dynamic creation</a> of effects.
          </li>
          <li>Automation of audio parameters for envelopes, fade-ins /
          fade-outs, granular effects, filter sweeps, LFOs etc.
          </li>
          <li>Flexible handling of channels in an audio stream, allowing them
          to be split and merged.
          </li>
          <li>Processing of audio sources from an <code>audio</code> or <code>
            video</code> <a href="#MediaElementAudioSourceNode">media
            element</a>.
          </li>
          <li>Processing live audio input using a <a href=
          "#MediaStreamTrackAudioSourceNode">MediaStream</a> from
          getUserMedia().
          </li>
          <li>Integration with WebRTC
            <ul>
              <li>Processing audio received from a remote peer using a
              <a><code>MediaStreamTrackAudioSourceNode</code></a> and
              [[!webrtc]].
              </li>
              <li>Sending a generated or processed audio stream to a remote
              peer using a <a><code>MediaStreamAudioDestinationNode</code></a>
              and [[!webrtc]].
              </li>
            </ul>
          </li>
          <li>Audio stream synthesis and processing <a href=
          "#AudioWorklet">directly using scripts</a>.
          </li>
          <li>
            <a href="#Spatialization">Spatialized audio</a> supporting a wide
            range of 3D games and immersive environments:
            <ul>
              <li>Panning models: equalpower, HRTF, pass-through
              </li>
              <li>Distance Attenuation
              </li>
              <li>Sound Cones
              </li>
              <li>Obstruction / Occlusion
              </li>
              <li>Source / Listener based
              </li>
            </ul>
          </li>
          <li>A <a href="convolution.html">convolution engine</a> for a wide
          range of linear effects, especially very high-quality room effects.
          Here are some examples of possible effects:
            <ul>
              <li>Small / large room
              </li>
              <li>Cathedral
              </li>
              <li>Concert hall
              </li>
              <li>Cave
              </li>
              <li>Tunnel
              </li>
              <li>Hallway
              </li>
              <li>Forest
              </li>
              <li>Amphitheater
              </li>
              <li>Sound of a distant room through a doorway
              </li>
              <li>Extreme filters
              </li>
              <li>Strange backwards effects
              </li>
              <li>Extreme comb filter effects
              </li>
            </ul>
          </li>
          <li>Dynamics compression for overall control and sweetening of the
          mix
          </li>
          <li>Efficient <a href="#the-analysernode-interface">real-time
          time-domain and frequency analysis / music visualizer support</a>
          </li>
          <li>Efficient biquad filters for lowpass, highpass, and other common
          filters.
          </li>
          <li>A Waveshaping effect for distortion and other non-linear effects
          </li>
          <li>Oscillators
          </li>
        </ul>
        <section>
          <h2 id="ModularRouting">
            Modular Routing
          </h2>
          <p>
            Modular routing allows arbitrary connections between different
            <a><code>AudioNode</code></a> objects. Each node can have
            <dfn>inputs</dfn> and/or <dfn>outputs</dfn>. A <dfn>source
            node</dfn> has no inputs and a single output. A <dfn>destination
            node</dfn> has one input and no outputs. Other nodes such as
            filters can be placed between the source and destination nodes. The
            developer doesn't have to worry about low-level stream format
            details when two objects are connected together; <a href=
            "#channel-up-mixing-and-down-mixing">the right thing just
            happens</a>. For example, if a mono audio stream is connected to a
            stereo input it should just mix to left and right channels <a href=
            "#channel-up-mixing-and-down-mixing">appropriately</a>.
          </p>
          <p>
            In the simplest case, a single source can be routed directly to the
            output. All routing occurs within an <a href=
            "#AudioContext"><code>AudioContext</code></a> containing a single
            <a href=
            "#AudioDestinationNode"><code>AudioDestinationNode</code></a>:
          </p>
          <figure>
            <img alt="modular routing" src="images/modular-routing1.png" width=
            "305" height="128">
            <figcaption>
              A simple example of modular routing.
            </figcaption>
          </figure>
          <p>
            Illustrating this simple routing, here's a simple example playing a
            single sound:
          </p>
          <pre class="example">

var context = new AudioContext();

function playSound() {
    var source = context.createBufferSource();
    source.buffer = dogBarkingBuffer;
    source.connect(context.destination);
    source.start(0);
}
</pre>
          <p>
            Here's a more complex example with three sources and a convolution
            reverb send with a dynamics compressor at the final output stage:
          </p>
          <figure>
            <img alt="modular routing2" src="images/modular-routing2.png"
            width="561" height="411">
            <figcaption>
              A more complex example of modular routing.
            </figcaption>
          </figure>
          <pre class="example">

var context = 0;
var compressor = 0;
var reverb = 0;

var source1 = 0;
var source2 = 0;
var source3 = 0;

var lowpassFilter = 0;
var waveShaper = 0;
var panner = 0;

var dry1 = 0;
var dry2 = 0;
var dry3 = 0;

var wet1 = 0;
var wet2 = 0;
var wet3 = 0;

var masterDry = 0;
var masterWet = 0;

function setupRoutingGraph () {
    context = new AudioContext();

    // Create the effects nodes.
    lowpassFilter = context.createBiquadFilter();
    waveShaper = context.createWaveShaper();
    panner = context.createPanner();
    compressor = context.createDynamicsCompressor();
    reverb = context.createConvolver();

    // Create master wet and dry.
    masterDry = context.createGain();
    masterWet = context.createGain();

    // Connect final compressor to final destination.
    compressor.connect(context.destination);

    // Connect master dry and wet to compressor.
    masterDry.connect(compressor);
    masterWet.connect(compressor);

    // Connect reverb to master wet.
    reverb.connect(masterWet);

    // Create a few sources.
    source1 = context.createBufferSource();
    source2 = context.createBufferSource();
    source3 = context.createOscillator();

    source1.buffer = manTalkingBuffer;
    source2.buffer = footstepsBuffer;
    source3.frequency.value = 440;

    // Connect source1
    dry1 = context.createGain();
    wet1 = context.createGain();
    source1.connect(lowpassFilter);
    lowpassFilter.connect(dry1);
    lowpassFilter.connect(wet1);
    dry1.connect(masterDry);
    wet1.connect(reverb);

    // Connect source2
    dry2 = context.createGain();
    wet2 = context.createGain();
    source2.connect(waveShaper);
    waveShaper.connect(dry2);
    waveShaper.connect(wet2);
    dry2.connect(masterDry);
    wet2.connect(reverb);

    // Connect source3
    dry3 = context.createGain();
    wet3 = context.createGain();
    source3.connect(panner);
    panner.connect(dry3);
    panner.connect(wet3);
    dry3.connect(masterDry);
    wet3.connect(reverb);

    // Start the sources now.
    source1.start(0);
    source2.start(0);
    source3.start(0);
}
</pre>
          <p>
            Modular routing also permits the output of
            <a><code>AudioNode</code></a>s to be routed to an
            <a><code>AudioParam</code></a> parameter that controls the behavior
            of a different <a><code>AudioNode</code></a>. In this scenario, the
            output of a node can act as a modulation signal rather than an
            input signal.
          </p>
          <figure>
            <img alt="modular routing3" src="images/modular-routing3.png"
            width="346" height="337">
            <figcaption>
              Modular routing illustrating one Oscillator modulating the
              frequency of another.
            </figcaption>
          </figure>
          <pre class="example">
function setupRoutingGraph() {
  var context = new AudioContext();

  // Create the low frequency oscillator that supplies the modulation signal
  var lfo = context.createOscillator();
  lfo.frequency.value = 1.0;

  // Create the high frequency oscillator to be modulated
  var hfo = context.createOscillator();
  hfo.frequency.value = 440.0;

  // Create a gain node whose gain determines the amplitude of the modulation signal
  var modulationGain = context.createGain();
  modulationGain.gain.value = 50;

  // Configure the graph and start the oscillators
  lfo.connect(modulationGain);
  modulationGain.connect(hfo.detune);
  hfo.connect(context.destination);
  hfo.start(0);
  lfo.start(0);
}
</pre>
        </section>
      </section>
      <section>
        <h2 id="APIOverview">
          API Overview
        </h2>
        <p>
          The interfaces defined are:
        </p>
        <ul>
          <li>An <a class="dfnref" href="#AudioContext">AudioContext</a>
          interface, which contains an audio signal graph representing
          connections between <a><code>AudioNode</code></a>s.
          </li>
          <li>An <a><code>AudioNode</code></a> interface, which represents
          audio sources, audio outputs, and intermediate processing modules.
          <a><code>AudioNode</code></a>s can be dynamically connected together
          in a <a href="#ModularRouting">modular fashion</a>.
          <a><code>AudioNode</code></a>s exist in the context of an
          <a><code>AudioContext</code></a>.
          </li>
          <li>An <a><code>AnalyserNode</code></a> interface, an
          <a><code>AudioNode</code></a> for use with music visualizers, or
          other visualization applications.
          </li>
          <li>An <a><code>AudioBuffer</code></a> interface, for working with
          memory-resident audio assets. These can represent one-shot sounds, or
          longer audio clips.
          </li>
          <li>An <a><code>AudioBufferSourceNode</code></a> interface, an
          <a><code>AudioNode</code></a> which generates audio from an
          AudioBuffer.
          </li>
          <li>An <a><code>AudioDestinationNode</code></a> interface, an
          <a><code>AudioNode</code></a> subclass representing the final
          destination for all rendered audio.
          </li>
          <li>An <a><code>AudioParam</code></a> interface, for controlling an
          individual aspect of an <a><code>AudioNode</code></a>'s functioning,
          such as volume.
          </li>
          <li>An <a><code>AudioListener</code></a> interface, which works with
          a <a>PannerNode</a> for spatialization.
          </li>
          <li>An <a><code>AudioWorklet</code></a> interface representing a
          factory for creating custom nodes that can process audio directly
          using scripts.
          </li>
          <li>An <a><code>AudioWorkletGlobalScope</code></a> interface, the
          context in which AudioWorkletProcessor processing scripts run.
          </li>
          <li>An <a><code>AudioWorkletNode</code></a> interface, an
          <a><code>AudioNode</code></a> representing a node processed in an
          AudioWorkletProcessor.
          </li>
          <li>An <a><code>AudioWorkletProcessor</code></a> interface,
          representing a single node instance inside an audio worker.
          </li>
          <li>A <a><code>BiquadFilterNode</code></a> interface, an
          <a><code>AudioNode</code></a> for common low-order filters such as:
            <ul>
              <li>Low Pass
              </li>
              <li>High Pass
              </li>
              <li>Band Pass
              </li>
              <li>Low Shelf
              </li>
              <li>High Shelf
              </li>
              <li>Peaking
              </li>
              <li>Notch
              </li>
              <li>Allpass
              </li>
            </ul>
          </li>
          <li>A <a><code>ChannelMergerNode</code></a> interface, an
          <a><code>AudioNode</code></a> for combining channels from multiple
          audio streams into a single audio stream.
          </li>
          <li>A <a><code>ChannelSplitterNode</code></a> interface, an <a><code>
            AudioNode</code></a> for accessing the individual channels of an
            audio stream in the routing graph.
          </li>
          <li>A <a><code>ConstantSourceNode</code></a> interface, an
          <a>AudioNode</a> for generating a nominally constant output value
          with an <a>AudioParam</a> to allow automation of the value.
          </li>
          <li>A <a><code>ConvolverNode</code></a> interface, an
          <a><code>AudioNode</code></a> for applying a <a href=
          "convolution.html">real-time linear effect</a> (such as the sound of
          a concert hall).
          </li>
          <li>A <a><code>DelayNode</code></a> interface, an
          <a><code>AudioNode</code></a> which applies a dynamically adjustable
          variable delay.
          </li>
          <li>A <a><code>DynamicsCompressorNode</code></a> interface, an
          <a><code>AudioNode</code></a> for dynamics compression.
          </li>
          <li>A <a><code>GainNode</code></a> interface, an
          <a><code>AudioNode</code></a> for explicit gain control. Because
          inputs to <a><code>AudioNode</code></a>s support multiple connections
          (as a unity-gain summing junction), mixers can be <a href=
          "#mixer-gain-structure">easily built</a> with GainNodes.
          </li>
          <li>An <a><code>IIRFilterNode</code></a> interface, an
          <a><code>AudioNode</code></a> for a general IIR filter.
          </li>
          <li>A <a><code>MediaElementAudioSourceNode</code></a> interface, an
          <a><code>AudioNode</code></a> which is the audio source from an
          <code>audio</code>, <code>video</code>, or other media element.
          </li>
          <li>A <a><code>MediaStreamAudioSourceNode</code></a> interface, an
          <a><code>AudioNode</code></a> which is the audio source from a
          MediaStream such as live audio input, or from a remote peer.
          </li>
          <li>A <a><code>MediaStreamTrackAudioSourceNode</code></a> interface,
          an <a><code>AudioNode</code></a> which is the audio source from a
          <code>MediaStreamTrack</code>.
          </li>
          <li>A <a><code>MediaStreamAudioDestinationNode</code></a> interface,
          an <a><code>AudioNode</code></a> which is the audio destination to a
          MediaStream sent to a remote peer.
          </li>
          <li>A <a><code>PannerNode</code></a> interface, an
          <a><code>AudioNode</code></a> for spatializing / positioning audio in
          3D space.
          </li>
          <li>A <a><code>PeriodicWave</code></a> interface for specifying
          custom periodic waveforms for use by the
          <a><code>OscillatorNode</code></a>.
          </li>
          <li>An <a><code>OscillatorNode</code></a> interface, an
          <a><code>AudioNode</code></a> for generating a periodic waveform.
          </li>
          <li>A <a><code>StereoPannerNode</code></a> interface, an
          <a><code>AudioNode</code></a> for equal-power positioning of audio
          input in a stereo stream.
          </li>
          <li>A <a><code>WaveShaperNode</code></a> interface, an
          <a><code>AudioNode</code></a> which applies a non-linear waveshaping
          effect for distortion and other more subtle warming effects.
          </li>
        </ul>
        <p>
          There are also several features that have been deprecated from the
          Web Audio API but not yet removed, pending implementation experience
          of their replacements:
        </p>
        <ul>
          <li>A <a><code>ScriptProcessorNode</code></a> interface, an <a><code>
            AudioNode</code></a> for generating or processing audio directly
            using scripts.
          </li>
          <li>An <a><code>AudioProcessingEvent</code></a> interface, which is
          an event type used with <a><code>ScriptProcessorNode</code></a>
          objects.
          </li>
        </ul>
      </section>
    </section>
    <section id="conformance">
      <p>
        The following conformance classes are defined by this specification:
      </p>
      <dl>
        <dt>
          <dfn>conforming implementation</dfn>
        </dt>
        <dd>
          <p>
            A user agent is considered to be a <a>conforming implementation</a>
            if it satisfies all of the MUST-, REQUIRED- and SHALL-level
            criteria in this specification that apply to implementations.
          </p>
        </dd>
      </dl>
      <p>
        User agents that use ECMAScript to implement the APIs defined in this
        specification MUST implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]] as
        this specification uses that specification and terminology.
      </p>
    </section>
    <section id="audioapi">
      <h2 id="API">
        The Audio API
      </h2>
      <section>
        <h2 id="BaseAudioContext">
          The <dfn>BaseAudioContext</dfn> Interface
        </h2>
        <p>
          This interface represents a set of <a><code>AudioNode</code></a>
          objects and their connections. It allows for arbitrary routing of
          signals to an <a><code>AudioDestinationNode</code></a>. Nodes are
          created from the context and are then <a href=
          "#ModularRouting">connected</a> together.
        </p>
        <p>
          <a><code>BaseAudioContext</code></a> is not instantiated directly,
          but is instead extended by the concrete interfaces
          <a><code>AudioContext</code></a> (for real-time rendering) and
          <a><code>OfflineAudioContext</code></a> (for offline rendering).
        </p>
        <pre class="idl">
enum <dfn>AudioContextState</dfn> {
    "suspended",
    "running",
    "closed"
};
        </pre>
        <table class="simple" data-dfn-for="AudioContextState" data-link-for=
        "AudioContextState">
          <tbody>
            <tr>
              <th colspan="2">
                Enumeration description
              </th>
            </tr>
            <tr>
              <td>
                <code><dfn>suspended</dfn></code>
              </td>
              <td>
                <p>
                  This context is currently suspended (context time is not
                  proceeding, audio hardware may be powered down/released).
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <code><dfn>running</dfn></code>
              </td>
              <td>
                Audio is being processed.
              </td>
            </tr>
            <tr>
              <td>
                <code><dfn>closed</dfn></code>
              </td>
              <td>
                This context has been released, and can no longer be used to
                process audio. All system audio resources have been released.
                <span class="synchronous">Attempts to create new Nodes on the
                AudioContext will throw <code>InvalidStateError</code></span>.
                (AudioBuffers may still be created, through <a data-link-for=
                "BaseAudioContext">createBuffer</a>, <a data-link-for=
                "BaseAudioContext">decodeAudioData</a>, or the
                <a>AudioBuffer</a> constructor.)
              </td>
            </tr>
          </tbody>
        </table>
        <pre class="idl">
callback DecodeErrorCallback = void (DOMException error);

callback DecodeSuccessCallback = void (AudioBuffer decodedData);

[Exposed=Window]
interface BaseAudioContext : EventTarget {
    readonly        attribute AudioDestinationNode destination;
    readonly        attribute float                sampleRate;
    readonly        attribute double               currentTime;
    readonly        attribute AudioListener        listener;
    readonly        attribute AudioContextState    state;
    Promise&lt;void&gt;          resume ();
                    attribute EventHandler         onstatechange;
    AudioBuffer            createBuffer (unsigned long numberOfChannels, unsigned long length, float sampleRate);
    Promise&lt;AudioBuffer&gt;   decodeAudioData (ArrayBuffer audioData, optional DecodeSuccessCallback successCallback, optional DecodeErrorCallback errorCallback);
    AudioBufferSourceNode  createBufferSource ();
    ConstantSourceNode     createConstantSource ();
    ScriptProcessorNode    createScriptProcessor (optional unsigned long bufferSize = 0
              , optional unsigned long numberOfInputChannels = 2
              , optional unsigned long numberOfOutputChannels = 2
              );
    AnalyserNode           createAnalyser ();
    GainNode               createGain ();
    DelayNode              createDelay (optional double maxDelayTime = 1.0
              );
    BiquadFilterNode       createBiquadFilter ();
    IIRFilterNode          createIIRFilter (sequence&lt;double&gt; feedforward, sequence&lt;double&gt; feedback);
    WaveShaperNode         createWaveShaper ();
    PannerNode             createPanner ();
    StereoPannerNode       createStereoPanner ();
    ConvolverNode          createConvolver ();
    ChannelSplitterNode    createChannelSplitter (optional unsigned long numberOfOutputs = 6
              );
    ChannelMergerNode      createChannelMerger (optional unsigned long numberOfInputs = 6
              );
    DynamicsCompressorNode createDynamicsCompressor ();
    OscillatorNode         createOscillator ();
    PeriodicWave           createPeriodicWave (sequence&lt;float&gt; real, sequence&lt;float&gt; imag, optional PeriodicWaveConstraints constraints);
};
        </pre>
        <section>
          <h2>
            Attributes
          </h2>
          <dl class="attributes" data-dfn-for="BaseAudioContext" data-link-for=
          "BaseAudioContext">
            <dt>
              <code><dfn>currentTime</dfn></code> of type <span class=
              "idlAttrType"><a>double</a></span>, readonly
            </dt>
            <dd>
              <p>
                This is the time in seconds of the sample frame immediately
                following the last sample-frame in the block of audio most
                recently processed by the context's rendering graph. If the
                context's rendering graph has not yet processed a block of
                audio, then <a data-link-for=
                "BaseAudioContext"><code>currentTime</code></a> has a value of
                zero.
              </p>
              <p>
                In the time coordinate system of <a data-link-for=
                "BaseAudioContext"><code>currentTime</code></a>, the value of
                zero corresponds to the first sample-frame in the first block
                processed by the graph. Elapsed time in this system corresponds
                to elapsed time in the audio stream generated by the
                <a><code>BaseAudioContext</code></a>, which may not be
                synchronized with other clocks in the system. (For an
                <a><code>OfflineAudioContext</code></a>, since the stream is
                not being actively played by any device, there is not even an
                approximation to real time.)
              </p>
              <p>
                All scheduled times in the Web Audio API are relative to the
                value of <a data-link-for=
                "BaseAudioContext"><code>currentTime</code></a>.
              </p>
              <p>
                When the <a><code>BaseAudioContext</code></a> is in the
                <a data-link-for="AudioContextState">running</a> state, the
                value of this attribute is monotonically increasing and is
                updated by the rendering thread in uniform increments,
                corresponding to one <a>render quantum</a>. Thus, for a running
                context, <code>currentTime</code> increases steadily as the
                system processes audio blocks, and always represents the time
                of the start of the next audio block to be processed. It is
                also the earliest possible time when any change scheduled in
                the current state might take effect.
              </p>
              <p>
                <code>currentTime</code> MUST be read <a data-lt=
                "atomic">atomically</a> on the control thread before being
                returned.
              </p>
            </dd>
            <dt>
              <code><dfn>destination</dfn></code> of type <span class=
              "idlAttrType"><a>AudioDestinationNode</a></span>, readonly
            </dt>
            <dd>
              <p>
                An <a href=
                "#AudioDestinationNode"><code>AudioDestinationNode</code></a>
                with a single input representing the final destination for all
                audio. Usually this will represent the actual audio hardware.
                All <a><code>AudioNode</code></a>s actively rendering audio
                will directly or indirectly connect to <a data-link-for=
                "BaseAudioContext"><code>destination</code></a>.
              </p>
            </dd>
            <dt>
              <code><dfn>listener</dfn></code> of type <span class=
              "idlAttrType"><a>AudioListener</a></span>, readonly
            </dt>
            <dd>
              <p>
                An <a href="#AudioListener"><code>AudioListener</code></a>
                which is used for 3D <a href=
                "#Spatialization">spatialization</a>.
              </p>
            </dd>
            <dt>
              <code><dfn>onstatechange</dfn></code> of type <span class=
              "idlAttrType"><a>EventHandler</a></span>
            </dt>
            <dd>
              <p>
                A property used to set the <code>EventHandler</code> for an
                event that is dispatched to
                <a><code>BaseAudioContext</code></a> when the state of the
                AudioContext has changed (i.e. when the corresponding promise
                would have resolved). An event of type
                <a><code>Event</code></a> will be dispatched to the event
                handler, which can query the AudioContext's state directly. A
                newly-created AudioContext will always begin in the
                <code>suspended</code> state, and a state change event will be
                fired whenever the state changes to a different state. This
                event is fired before the <a><code>oncomplete</code></a> event
                is fired.
              </p>
            </dd>
            <dt>
              <code><dfn>sampleRate</dfn></code> of type <span class=
              "idlAttrType"><a>float</a></span>, readonly
            </dt>
            <dd>
              The sample rate (in sample-frames per second) at which the
              <a>BaseAudioContext</a> handles audio. It is assumed that all
              <a>AudioNode</a>s in the context run at this rate. In making this
              assumption, sample-rate converters or "varispeed" processors are
              not supported in real-time processing. The <dfn>Nyquist
              frequency</dfn> is half this sample-rate value.
            </dd>
            <dt>
              <code><dfn>state</dfn></code> of type <span class=
              "idlAttrType"><a>AudioContextState</a></span>, readonly
            </dt>
            <dd>
              Describes the current state of the <a>AudioContext</a>, on the
              <a>control thread</a>.
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Methods
          </h2>
          <dl class="methods" data-dfn-for="BaseAudioContext" data-link-for=
          "BaseAudioContext">
            <dt>
              <code><dfn>createAnalyser</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for an <a><code>AnalyserNode</code></a>.
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>AnalyserNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createBiquadFilter</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for a <a><code>BiquadFilterNode</code></a>
              representing a second order filter which can be configured as one
              of several common filter types.
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>BiquadFilterNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createBuffer</dfn></code>
            </dt>
            <dd>
              Creates an AudioBuffer of the given size. The audio data in the
              buffer will be zero-initialized (silent). <span class=
              "synchronous">A <code>NotSupportedError</code> exception MUST be
              thrown if any of the arguments is negative, zero, or outside its
              nominal range.</span>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Type
                    </th>
                    <th>
                      Nullable
                    </th>
                    <th>
                      Optional
                    </th>
                    <th>
                      Description
                    </th>
                  </tr>
                  <tr>
                    <td class="prmName">
                      numberOfChannels
                    </td>
                    <td class="prmType">
                      <code>unsigned long</code>
                    </td>
                    <td class="prmNullFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmOptFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmDesc">
                      Determines how many channels the buffer will have. An
                      implementation MUST support at least 32 channels.
                    </td>
                  </tr>
                  <tr>
                    <td class="prmName">
                      length
                    </td>
                    <td class="prmType">
                      <code>unsigned long</code>
                    </td>
                    <td class="prmNullFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmOptFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmDesc">
                      Determines the size of the buffer in sample-frames.
                    </td>
                  </tr>
                  <tr>
                    <td class="prmName">
                      sampleRate
                    </td>
                    <td class="prmType">
                      <code>float</code>
                    </td>
                    <td class="prmNullFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmOptFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmDesc">
                      Describes the sample-rate of the linear PCM audio data in
                      the buffer in sample-frames per second. An implementation
                      MUST support sample rates in at least the range 8000 to
                      96000.
                    </td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>AudioBuffer</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createBufferSource</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for a
              <a><code>AudioBufferSourceNode</code></a>.
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>AudioBufferSourceNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createChannelMerger</dfn></code>
            </dt>
            <dd>
              <p>
                <a>Factory method</a> for a
                <a><code>ChannelMergerNode</code></a> representing a channel
                merger. <span class="synchronous">An
                <code>IndexSizeError</code> exception MUST be thrown for
                invalid parameter values.</span>
              </p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Type
                    </th>
                    <th>
                      Nullable
                    </th>
                    <th>
                      Optional
                    </th>
                    <th>
                      Description
                    </th>
                  </tr>
                  <tr>
                    <td class="prmName">
                      numberOfInputs
                    </td>
                    <td class="prmType">
                      <code>unsigned long = 6</code>
                    </td>
                    <td class="prmNullFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmOptTrue">
                      <span role="img" aria-label="True">âœ”</span>
                    </td>
                    <td class="prmDesc">
                      The <dfn>numberOfInputs</dfn> parameter determines the
                      number of inputs. Values of up to 32 MUST be supported.
                      If not specified, then 6 will be used.
                    </td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>ChannelMergerNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createChannelSplitter</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for a
              <a><code>ChannelSplitterNode</code></a> representing a channel
              splitter. <span class="synchronous">An
              <code>IndexSizeError</code> exception MUST be thrown for invalid
              parameter values.</span>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Type
                    </th>
                    <th>
                      Nullable
                    </th>
                    <th>
                      Optional
                    </th>
                    <th>
                      Description
                    </th>
                  </tr>
                  <tr>
                    <td class="prmName">
                      numberOfOutputs
                    </td>
                    <td class="prmType">
                      <code>unsigned long = 6</code>
                    </td>
                    <td class="prmNullFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmOptTrue">
                      <span role="img" aria-label="True">âœ”</span>
                    </td>
                    <td class="prmDesc">
                      The number of outputs. Values of up to 32 MUST be
                      supported. If not specified, then 6 will be used.
                    </td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>ChannelSplitterNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createConstantSource</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for a
              <a><code>ConstantSourceNode</code></a>.
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>ConstantSourceNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createConvolver</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for a <a><code>ConvolverNode</code></a>.
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>ConvolverNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createDelay</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for a <a>DelayNode</a>. The initial default
              delay time will be 0 seconds.
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Type
                    </th>
                    <th>
                      Nullable
                    </th>
                    <th>
                      Optional
                    </th>
                    <th>
                      Description
                    </th>
                  </tr>
                  <tr>
                    <td class="prmName">
                      maxDelayTime
                    </td>
                    <td class="prmType">
                      <code>double = 1.0</code>
                    </td>
                    <td class="prmNullFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmOptTrue">
                      <span role="img" aria-label="True">âœ”</span>
                    </td>
                    <td class="prmDesc">
                      The <dfn>maxDelayTime</dfn> parameter is optional and
                      specifies the maximum delay time in seconds allowed for
                      the delay line. <span class="synchronous">If specified,
                      this value MUST be greater than zero and less than three
                      minutes or a <code>NotSupportedError</code> exception
                      MUST be thrown.</span>
                    </td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>DelayNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createDynamicsCompressor</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for a
              <a><code>DynamicsCompressorNode</code></a>.
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>DynamicsCompressorNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createGain</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for <a>GainNode</a>.
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>GainNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createIIRFilter</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for an <a><code>IIRFilterNode</code></a>
              representing a general IIR Filter.
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    feedforward
                  </td>
                  <td class="prmType">
                    <code>sequence&lt;double&gt;</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    An array of the feedforward (numerator) coefficients for
                    the transfer function of the IIR filter. The maximum length
                    of this array is 20. If all of the values are zero,
                    <span class="synchronous">an <code>InvalidStateError</code>
                    <em class="rfc2119" title="MUST">MUST</em> be
                    thrown</span>. <span class="synchronous">A
                    <code>NotSupportedError</code> <em class="rfc2119" title=
                    "MUST">MUST</em> be thrown if the array length is 0 or
                    greater than 20</span>.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    feedback
                  </td>
                  <td class="prmType">
                    <code>sequence&lt;double&gt;</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    An array of the feedback (denominator) coefficients for the
                    transfer function of the IIR filter. The maximum length of
                    this array is 20. If the first element of the array is 0,
                    <span class="synchronous">an <code>InvalidStateError</code>
                    <em class="rfc2119" title="MUST">MUST</em> be
                    thrown</span>. <span class="synchronous">A
                    <code>NotSupportedError</code> <em class="rfc2119" title=
                    "MUST">MUST</em> be thrown if the array length is 0 or
                    greater than 20</span>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>IIRFilterNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createOscillator</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for an <a><code>OscillatorNode</code></a>.
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>OscillatorNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createPanner</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for a <a><code>PannerNode</code></a>.
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>PannerNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createPeriodicWave</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> to create a
              <a><code>PeriodicWave</code></a>. When calling this method,
              execute these steps:
              <ol class="algorithm">
                <li>If <var>real</var> and <var>imag</var> are not of the same
                length, an <var>IndexSizeError</var> MUST be thrown.
                </li>
                <li>Let <var>o</var> a new object of type
                <a>PeriodicWaveOption</a>.
                </li>
                <li>Respectively set the <code>real</code> and
                <code>imag</code> parameters passed to this factory method to
                the attributes of the same name on <var>o</var>.
                </li>
                <li>Set the <code>disableNormalization</code> attribute on
                <var>o</var> to the value of the
                <code>disableNormalization</code> attribute of the
                <code>constraints</code> attribute passed to the factory
                method.
                </li>
                <li>Return the result of constructing a new <a>PeriodicWave</a>
                <var>p</var>, passing the <a>BaseAudioContext</a> this factory
                method has been called on as a first argument, and
                <var>o</var>.
                </li>
              </ol>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    real
                  </td>
                  <td class="prmType">
                    <code>sequence&lt;float&gt;</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    A sequence of cosine parameters. See its <a data-link-for=
                    "PeriodicWaveOptions">real</a> constructor argument for a
                    more detailed description.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    imag
                  </td>
                  <td class="prmType">
                    <code>sequence&lt;float&gt;</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    A sequence of sine parameters. See its <a data-link-for=
                    "PeriodicWaveOptions">imag</a> constructor argument for a
                    more detailed description.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    constraints
                  </td>
                  <td class="prmType">
                    <a>PeriodicWaveConstraints</a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    If not given, the waveform is normalized. Otherwise, the
                    waveform is normalized according the value given by
                    <code>constraints</code>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>PeriodicWave</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createScriptProcessor</dfn></code>
            </dt>
            <dd>
              <p>
                <a>Factory method</a> for a <a>ScriptProcessorNode</a>. This
                method is DEPRECATED, as it is intended to be replaced by
                <a href="#AudioWorkletNode"><code>AudioWorkletNode</code></a>.
                Creates a <a><code>ScriptProcessorNode</code></a> for direct
                audio processing using scripts. <span class="synchronous">An
                <code>IndexSizeError</code> exception MUST be thrown if
                <a><code>bufferSize</code></a> or
                <a><code>numberOfInputChannels</code></a> or
                <a><code>numberOfOutputChannels</code></a> are outside the
                valid range.</span>
              </p>
              <p>
                It is invalid for both
                <a><code>numberOfInputChannels</code></a> and
                <a><code>numberOfOutputChannels</code></a> to be zero. In this
                case an <code>IndexSizeError</code> MUST be thrown.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    bufferSize
                  </td>
                  <td class="prmType">
                    <code>unsigned long = 0</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    The <a href="#dfn-buffersize" class="internalDFN"
                    data-link-type="dfn"><code>bufferSize</code></a> parameter
                    determines the buffer size in units of sample-frames. If
                    it's not passed in, or if the value is 0, then the
                    implementation will choose the best buffer size for the
                    given environment, which will be constant power of 2
                    throughout the lifetime of the node. Otherwise if the
                    author explicitly specifies the bufferSize, it <em class=
                    "rfc2119" title="MUST">MUST</em> be one of the following
                    values: 256, 512, 1024, 2048, 4096, 8192, 16384. This value
                    controls how frequently the <a data-link-for=
                    "ScriptProcessorNode"><code>onaudioprocess</code></a> event
                    is dispatched and how many sample-frames need to be
                    processed each call. Lower values for <a href=
                    "#dfn-buffersize" class="internalDFN" data-link-type=
                    "dfn"><code>bufferSize</code></a> will result in a lower
                    (better) <a href="#latency">latency</a>. Higher values will
                    be necessary to avoid audio breakup and <a href=
                    "#audio-glitching">glitches</a>. It is recommended for
                    authors to not specify this buffer size and allow the
                    implementation to pick a good buffer size to balance
                    between <a href="#latency">latency</a> and audio quality.
                    If the value of this parameter is not one of the allowed
                    power-of-2 values listed above, <span class=
                    "synchronous">an <code>IndexSizeError</code> <em class=
                    "rfc2119" title="MUST">MUST</em> be thrown</span>.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    <dfn>numberOfInputChannels</dfn>
                  </td>
                  <td class="prmType">
                    <code>unsigned long = 2</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    This parameter determines the number of channels for this
                    node's input. Values of up to 32 must be supported.
                    <span class="synchronous">A <code>NotSupportedError</code>
                    must be thrown if the number of channels is not
                    supported.</span>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    <dfn>numberOfOutputChannels</dfn>
                  </td>
                  <td class="prmType">
                    <code>unsigned long = 2</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    This parameter determines the number of channels for this
                    node's output. Values of up to 32 must be supported.
                    <span class="synchronous">A <code>NotSupportedError</code>
                    must be thrown if the number of channels is not
                    supported.</span>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>ScriptProcessorNode</code>
              </div>
            </dd>
            <dd>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>Node</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createStereoPanner</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for a <a><code>StereoPannerNode</code></a>.
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>StereoPannerNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createWaveShaper</dfn></code>
            </dt>
            <dd>
              <a>Factory method</a> for a <a><code>WaveShaperNode</code></a>
              representing a non-linear distortion.
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>WaveShaperNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>decodeAudioData</dfn></code>
            </dt>
            <dd>
              <p>
                Asynchronously decodes the audio file data contained in the
                <code>ArrayBuffer</code>. The <code>ArrayBuffer</code> can, for
                example, be loaded from an <code>XMLHttpRequest</code>'s
                <code>response</code> attribute after setting the
                <code>responseType</code> to <code>"arraybuffer"</code>. Audio
                file data can be in any of the formats supported by the
                <code>audio</code> element. The buffer passed to
                <a data-link-for="AudioContext">decodeAudioData</a> has its
                content-type determined by sniffing, as described in
                [[mimesniff]].
              </p>
              <p>
                Although the primary method of interfacing with this function
                is via its promise return value, the callback parameters are
                provided for legacy reasons. The system shall ensure that the
                <a>AudioContext</a> is not garbage collected before the promise
                is resolved or rejected and any callback function is called and
                completes.
              </p>
              <p>
                <span class="synchronous">When <code>decodeAudioData</code> is
                called, the following steps MUST be performed on the control
                thread:</span>
              </p>
              <ol class="algorithm">
                <li>Let <var>promise</var> be a new promise.
                </li>
                <li>If the operation <a href=
                "https://tc39.github.io/ecma262/#sec-isdetachedbuffer"><code>IsDetachedBuffer</code></a>
                (described in [[!ECMASCRIPT]]) on <a>audioData</a> is
                <code>false</code>, execute the following steps:
                  <ol>
                    <li>
                      <a href=
                      "https://tc39.github.io/ecma262/#sec-detacharraybuffer">Detach</a>
                      the <a>audioData</a> <code>ArrayBuffer</code>. This
                      operation is described in [[!ECMASCRIPT]].
                    </li>
                    <li>Queue a decoding operation to be performed on another
                    thread.
                    </li>
                  </ol>
                </li>
                <li>Else, execute the following steps:
                  <ol>
                    <li>Let <var>error</var> be a <code>DataCloneError</code>.
                    </li>
                    <li>Reject <var>promise</var> with <var>error</var>.
                    </li>
                    <li>Queue a task to invoke <a>errorCallback</a> with <var>
                      error</var>.
                    </li>
                  </ol>
                </li>
                <li>Return <var>promise</var>.
                </li>
              </ol>
              <p>
                When queuing a decoding operation to be performed on another
                thread, the following steps MUST happen on a thread that is not
                the <a>control thread</a> nor the <a>rendering thread</a>,
                called the <em>decoding thread</em>.
              </p>
              <div class="note">
                Multiple <em>decoding threads</em> can run in parallel to
                service multiple calls to <code>decodeAudioData</code>.
              </div>
              <ol class="algorithm">
                <li>Attempt to decode the encoded <a>audioData</a> into linear
                PCM.
                </li>
                <li>If a decoding error is encountered due to the audio format
                not being recognized or supported, or because of
                corrupted/unexpected/inconsistent data, then queue a task to
                execute the following step, on the <a>control thread</a>'s
                event loop:
                  <ol>
                    <li>Let <var>error</var> be a <code>DOMException</code>
                    whose name is <code>"EncodingError"</code>.
                    </li>
                    <li>Reject <var>promise</var> with <var>error</var>.
                    </li>
                    <li>If <dfn>errorCallback</dfn> is not missing, invoke <a>
                      errorCallback</a> with <var>error</var>.
                    </li>
                  </ol>
                </li>
                <li>Otherwise:
                  <ol>
                    <li>Take the result, representing the decoded linear PCM
                    audio data, and resample it to the sample-rate of the
                    <a><code>AudioContext</code></a> if it is different from
                    the sample-rate of <a>audioData</a>.
                    </li>
                    <li>Queue a task on the <a>control thread</a>'s event loop
                    to execute the following steps:
                      <ol>
                        <li>Let <var>buffer</var> be an
                        <code>AudioBuffer</code> containing the final result
                        (after possibly sample-rate conversion).
                        </li>
                        <li>Resolve <var>promise</var> with <var>buffer</var>.
                        </li>
                        <li>If <dfn>successCallback</dfn> is not missing,
                        invoke <a>successCallback</a> with <var>buffer</var>.
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    audioData
                  </td>
                  <td class="prmType">
                    <code>ArrayBuffer</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    An ArrayBuffer containing compressed audio data.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    successCallback
                  </td>
                  <td class="prmType">
                    <a>DecodeSuccessCallback</a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    A callback function which will be invoked when the decoding
                    is finished. The single argument to this callback is an
                    AudioBuffer representing the decoded PCM audio data.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    errorCallback
                  </td>
                  <td class="prmType">
                    <a>DecodeErrorCallback</a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    A callback function which will be invoked if there is an
                    error decoding the audio file.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;AudioBuffer&gt;</code>
              </div>
            </dd>
            <dt>
              <code><dfn>resume</dfn></code>
            </dt>
            <dd>
              <p>
                Resumes the progression of the <a>BaseAudioContext</a>'s
                <a data-link-for="AudioContext">currentTime</a> when it has
                been suspended.
              </p>
              <p>
                <span class="synchronous">When resume is called, execute these
                steps:</span>
              </p>
              <ol class="algorithm">
                <li>Let <em>promise</em> be a new Promise.
                </li>
                <li>If the <em>control thread state</em> flag on the
                <a>BaseAudioContext</a> is <code>closed</code> reject the
                promise with <code>InvalidStateError</code>, abort these steps,
                returning <em>promise</em>.
                </li>
                <li>If the <a data-link-for="BaseAudioContext">state</a>
                attribute of the <a>BaseAudioContext</a> is already
                <code>running</code>, resolve <em>promise</em>, return it, and
                abort these steps.
                </li>
                <li>If the <a>BaseAudioContext</a> is not <a>allowed to
                start</a>, append <em>promise</em> to
                <a>pendingResumePromises</a> and abort these steps, returning
                <em>promise</em>.
                </li>
                <li>Set the <em>control thread state</em> flag on the
                <a>BaseAudioContext</a> to <code>running</code>.
                </li>
                <li>
                  <a href="#queue">Queue a control message</a> to resume the
                  <a>BaseAudioContext</a>.
                </li>
                <li>Return <em>promise</em>.
                </li>
              </ol>
              <p>
                Running a <a>control message</a> to resume an
                <a>BaseAudioContext</a> means running these steps on the
                <a>rendering thread</a>:
              </p>
              <ol class="algorithm">
                <li>Attempt to <a href="#acquiring">acquire system
                resources</a>.
                </li>
                <li>Set the <a>rendering thread state</a> flag on the
                <a>BaseAudioContext</a> to <code>running</code>.
                </li>
                <li>Start <a href="#rendering-loop">rendering the audio
                graph</a>.
                </li>
                <li>In case of failure, queue a task on the <a>control
                thread</a> to execute the following, and abort these steps
                  <ol>
                    <li>Reject all promises from <a>pendingResumePromises</a>
                    in order, then clear <a>pendingResumePromises</a>.
                    </li>
                    <li>Reject <em>promise</em>.
                    </li>
                  </ol>
                </li>
                <li>Queue a task on the <a>control thread</a>'s event loop, to
                execute these steps:
                  <ol>
                    <li>Resolve all promises from <a>pendingResumePromises</a>
                    in order, then clear <a>pendingResumePromises</a>.
                    </li>
                    <li>Resolve <em>promise</em>.
                    </li>
                    <li>If the <a data-link-for="BaseAudioContext">state</a>
                    attribute of the <a>BaseAudioContext</a> is not already
                    <code>running</code>:
                      <ol>
                        <li>Set the <a data-link-for=
                        "BaseAudioContext">state</a> attribute of the
                        <a>BaseAudioContext</a> to <code>running</code>.
                        </li>
                        <li>Queue a task to fire a simple event named
                        <code>statechange</code> at the
                        <a>BaseAudioContext</a>.
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>Node</code>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Callback <dfn>DecodeSuccessCallback</dfn> Parameters
          </h2>
          <dl class="attributes" data-dfn-for="DecodeSuccessCallback"
          data-link-for="DecodeSuccessCallback">
            <dt>
              <code><dfn>decodedData</dfn></code> of type <span class=
              "idlAttrType"><a>AudioBuffer</a></span>
            </dt>
            <dd>
              The AudioBuffer containing the decoded audio data.
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Callback <dfn>DecodeErrorCallback</dfn> Parameters
          </h2>
          <dl class="attributes" data-dfn-for="DecodeErrorCallback"
          data-link-for="DecodeErrorCallback">
            <dt>
              <code><dfn>error</dfn></code> of type <span class=
              "idlAttrType"><a>DOMException</a></span>
            </dt>
            <dd>
              The error that occurred while decoding.
            </dd>
          </dl>
        </section>
        <section>
          <h3 id="lifetime-AudioContext" class="informative">
            Lifetime
          </h3>
          <p>
            Once created, an <code>AudioContext</code> will continue to play
            sound until it has no more sound to play, or the page goes away.
          </p>
        </section>
        <section class="informative">
          <h3>
            Lack of introspection or serialization primitives
          </h3>
          <p>
            The Web Audio API takes a <em>fire-and-forget</em> approach to
            audio source scheduling. That is, <a>source nodes</a> are created
            for each note during the lifetime of the <a>AudioContext</a>, and
            never explicitly removed from the graph. This is incompatible with
            a serialization API, since there is no stable set of nodes that
            could be serialized.
          </p>
          <p>
            Moreover, having an introspection API would allow content script to
            be able to observe garbage collections.
          </p>
        </section>
        <section>
          <h3>
            System resources associated with BaseAudioContext subclasses
          </h3>
          <p>
            The subclasses <a>AudioContext</a> and <a>OfflineAudioContext</a>
            should be considered expensive objects. Creating these objects may
            involve creating a high-priority thread, or using a low-latency
            system audio stream, both having an impact on energy consumption.
            It is usually not necessary to create more than one
            <a>AudioContext</a> in a document.
          </p>
          <p>
            Constructing or resuming a <a>BaseAudioContext</a> subclass
            involves <dfn id="acquiring">acquiring system resources</dfn> for
            that context. For <a>AudioContext</a>, this also requires creation
            of a system audio stream. These operations return when the context
            begins generating output from its associated audio graph.
          </p>
          <p>
            Additionally, a user-agent can have an implementation-defined
            maximum number of <a>AudioContext</a>s, after which any attempt to
            create a new <a>AudioContext</a> will fail, <span class=
            "synchronous">throwing <code>NotSupportedError</code></span>.
          </p>
          <p>
            <a data-link-for="AudioContext">suspend</a> and <a data-link-for=
            "AudioContext">close</a> allow authors to <dfn id=
            "releasing">release system resources</dfn>, including threads,
            processes and audio streams. Suspending a <a>BaseAudioContext</a>
            permits implementations to release some of its resources, and
            allows it to continue to operate later by invoking
            <a data-link-for="BaseAudioContext">resume</a>. Closing an
            <a>AudioContext</a> permits implementations to release all of its
            resources, after which it cannot be used or resumed again.
          </p>
          <p class="note">
            For example, this can involve waiting for the audio callbacks to
            fire regularly, or to wait for the hardware to be ready for
            processing.
          </p>
        </section>
      </section>
      <section>
        <h2 id="AudioContext">
          The AudioContext Interface
        </h2>
        <p>
          This interface represents an audio graph whose
          <a><code>AudioDestinationNode</code></a> is routed to a real-time
          output device that produces a signal directed at the user. In most
          use cases, only a single <a><code>AudioContext</code></a> is used per
          document.
        </p>
        <p>
          An <a><code>AudioContext</code></a> is said to be <dfn>allowed to
          start</dfn> if the user agent and the system allow audio output in
          the current context. In other words, if the
          <a><code>AudioContext</code></a> <em>control thread state</em> is
          allowed to transition from <code>suspended</code> to
          <code>running</code>.
        </p>
        <p class='note'>
          For example, a user agent could require that an
          <a><code>AudioContext</code></a> control thread state change to
          running is <a href=
          "https://html.spec.whatwg.org/multipage/interaction.html#triggered-by-user-activation">
          triggered by a user activation</a> (as described in [[HTML]]).
        </p>
        <pre class="idl">
[Exposed=Window]
enum <dfn>AudioContextLatencyCategory</dfn> {
    "balanced",
    "interactive",
    "playback"
};
        </pre>
        <table class="simple" data-dfn-for="AudioContextLatencyCategory"
        data-link-for="AudioContextLatencyCategory">
          <tbody>
            <tr>
              <th colspan="2">
                Enumeration description
              </th>
            </tr>
            <tr>
              <td>
                <code><dfn>balanced</dfn></code>
              </td>
              <td>
                Balance audio output latency and power consumption.
              </td>
            </tr>
            <tr>
              <td>
                <code><dfn>interactive</dfn></code>
              </td>
              <td>
                Provide the lowest audio output latency possible without
                glitching. This is the default.
              </td>
            </tr>
            <tr>
              <td>
                <code><dfn>playback</dfn></code>
              </td>
              <td>
                Prioritize sustained playback without interruption over audio
                output latency. Lowest power consumption.
              </td>
            </tr>
          </tbody>
        </table>
        <pre class="idl">
[Exposed=Window,
 Constructor,
 Constructor (optional AudioContextOptions contextOptions)]
interface AudioContext : BaseAudioContext {
    readonly        attribute double baseLatency;
    readonly        attribute double outputLatency;
    AudioTimestamp                  getOutputTimestamp ();
    Promise&lt;void&gt;                   suspend ();
    Promise&lt;void&gt;                   close ();
    MediaElementAudioSourceNode     createMediaElementSource (HTMLMediaElement mediaElement);
    MediaStreamAudioSourceNode      createMediaStreamSource (MediaStream mediaStream);
    MediaStreamTrackAudioSourceNode createMediaStreamTrackSource (MediaStreamTrack mediaStreamTrack);
    MediaStreamAudioDestinationNode createMediaStreamDestination ();
};              
        </pre>
        <section>
          <h2>
            Constructors
          </h2>
          <dl class="methods" data-dfn-for="AudioContext" data-link-for=
          "AudioContext">
            <dt>
              <code><dfn>AudioContext</dfn></code>
            </dt>
            <dd>
              <p>
                <span class="synchronous">When creating an <a>AudioContext</a>,
                execute these steps:</span>
              </p>
              <ol class="algorithm">
                <li>Set a <code>control thread state</code> to
                <code>suspended</code> on the <a>AudioContext</a>.
                </li>
                <li>Set a <dfn>rendering thread state</dfn> to
                <code>suspended</code> on the <a>AudioContext</a>.
                </li>
                <li>Let <dfn>pendingResumePromises</dfn> be an empty ordered
                list of promises.
                </li>
                <li>If <code>contextOptions</code> is given, apply the options:
                  <ol>
                    <li>Set the internal latency of this <a>AudioContext</a>
                    according to <code>contextOptions.<a data-link-for=
                    "AudioContextOptions">latencyHint</a></code>, as described
                    in <a data-link-for="AudioContextOptions">latencyHint</a>.
                    </li>
                    <li>If <code>contextOptions.<a data-link-for=
                    "AudioContextOptions">sampleRate</a></code> is specified,
                    set the <a data-link-for="BaseAudioContext">sampleRate</a>
                    of this <a>AudioContext</a> to this value. Otherwise, use
                    the sample rate of the default output device. If the
                    selected sample rate differs from the sample rate of the
                    output device, this <a>AudioContext</a> MUST resample the
                    audio output to match the sample rate of the output device.
                      <p class="note">
                        If resampling is required, the latency of the
                        AudioContext may be affected, possibly by a large
                        amount.
                      </p>
                    </li>
                  </ol>
                </li>
                <li>If the <a>AudioContext</a> is not <a>allowed to start</a>,
                abort these steps.
                </li>
                <li>Send a <a>control message</a> to start processing.
                </li>
              </ol>
              <p>
                Sending a <a>control message</a> to start processing means
                executing the following steps:
              </p>
              <ol class="algorithm">
                <li>Attempt to <a href="#acquiring">acquire system
                resources</a>.
                </li>
                <li>In case of failure, abort these steps.
                </li>
                <li>Set the <a>rendering thread state</a> to
                <code>running</code> on the <a>AudioContext</a>.
                </li>
                <li>Queue a task on the <a>control thread</a> event loop, to
                execute these steps:
                  <ol>
                    <li>Set the <a data-link-for="audiocontext">state</a>
                    attribute of the <a>AudioContext</a> to
                    <code>running</code>.
                    </li>
                    <li>Queue a task to fire a simple event named
                    <code>statechange</code> at the <a>AudioContext</a>.
                    </li>
                  </ol>
                </li>
              </ol>
              <p class="note">
                It is unfortunately not possible to programatically notify
                authors that the creation of the <a>AudioContext</a> failed.
                User-Agents are encouraged to log an informative message if
                they have access to a logging mechanism, such as a developer
                tools console.
              </p>
            </dd>
            <dd>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    <code>contextOptions</code>
                  </td>
                  <td class="prmtype">
                    <a>AudioContextOptions</a>
                  </td>
                  <td class="prmNullTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    User-specified options controlling how the
                    <a>AudioContext</a> should be constructed.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Attributes
          </h2>
          <dl class="attributes" data-dfn-for="AudioContext" data-link-for=
          "AudioContext">
            <dt>
              <dfn>baseLatency</dfn> of type <span class=
              "idlAttrType"><a>double</a></span>, readonly
            </dt>
            <dd>
              <p>
                This represents the number of seconds of processing latency
                incurred by the <a>AudioContext</a> passing the audio from the
                <a>AudioDestinationNode</a> to the audio subsystem. It does not
                include any additional latency that might be caused by any
                other processing between the output of the
                <a>AudioDestinationNode</a> and the audio hardware and
                specifically does not include any latency incurred the audio
                graph itself.
              </p>
              <p>
                For example, if the audio context is running at 44.1 kHz and
                the <a>AudioDestinationNode</a> implements double buffering
                internally and can process and output audio each <a>render
                quantum</a>, then the processing latency is \((2\cdot128)/44100
                = 5.805 \mathrm{ ms}\), approximately.
              </p>
            </dd>
            <dt>
              <dfn>outputLatency</dfn> of type <span class=
              "idlAttrType"><a>double</a></span>, readonly
            </dt>
            <dd>
              <p>
                The estimation in seconds of audio output latency, i.e., the
                interval between the time the UA requests the host system to
                play a buffer and the time at which the first sample in the
                buffer is actually processed by the audio output device. For
                devices such as speakers or headphones that produce an acoustic
                signal, this latter time refers to the time when a sample's
                sound is produced.
              </p>
              <p>
                The <a><code>outputLatency</code></a> attribute value depends
                on the platform and the connected hardware audio output device.
                The <a><code>outputLatency</code></a> attribute value does not
                change for the context's lifetime as long as the connected
                audio output device remains the same. If the audio output
                device is changed the <a><code>outputLatency</code></a>
                attribute value will be updated accordingly.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Methods
          </h2>
          <dl class="methods" data-dfn-for="AudioContext" data-link-for=
          "AudioContext">
            <dt>
              <code><dfn>close</dfn></code>
            </dt>
            <dd>
              <p>
                Closes the <a>AudioContext</a>, <a>releasing the system
                resources</a> it's using. This will not automatically release
                all <a>AudioContext</a>-created objects, but will suspend the
                progression of the <a><code>AudioContext</code></a>'s
                <a data-link-for="AudioContext">currentTime</a>, and stop
                processing audio data.
              </p>
              <p>
                <span class="synchronous">When close is called, execute these
                steps:</span>
              </p>
              <ol>
                <li>Let <em>promise</em> be a new Promise.
                </li>
                <li>If the <em>control thread state</em> flag on the
                <a>AudioContext</a> is <code>closed</code> reject the promise
                with <code>InvalidStateError</code>, abort these steps,
                returning <em>promise</em>.
                </li>
                <li>If the <a data-link-for="AudioContext">state</a> attribute
                of the <a>AudioContext</a> is already <code>closed</code>,
                resolve <em>promise</em>, return it, and abort these steps.
                </li>
                <li>Set the <em>control thread state</em> flag on the
                <a>AudioContext</a> to <code>closed</code>.
                </li>
                <li>
                  <a href="#queue">Queue a control message</a> to the
                  <a>AudioContext</a>.
                </li>
                <li>Return <em>promise</em>.
                </li>
              </ol>
              <p>
                Running a <a>control message</a> to close an
                <a>AudioContext</a> means running these steps on the
                <a>rendering thread</a>:
              </p>
              <ol>
                <li>Attempt to <a>release system resources</a>.
                </li>
                <li>Set the <a>rendering thread state</a> to
                <code>suspended</code>.
                </li>
                <li>Queue a task on the <a>control thread</a>'s event loop, to
                execute these steps:
                  <ol>
                    <li>Resolve <em>promise</em>.
                    </li>
                    <li>If the <a data-link-for="audiocontext">state</a>
                    attribute of the <a>AudioContext</a> is not already <code>
                      closed</code>:
                      <ol>
                        <li>Set the <a data-link-for="audiocontext">state</a>
                        attribute of the <a>AudioContext</a> to
                        <code>closed</code>.
                        </li>
                        <li>Queue a task to fire a simple event named
                        <code>statechange</code> at the <a>AudioContext</a>.
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
              <p>
                When an <a>AudioContext</a> is closed, any
                <code>MediaStream</code>s and <code>HTMLMediaElement</code>s
                that were connected to an <a>AudioContext</a> will have their
                output ignored. That is, these will no longer cause any output
                to speakers or other output devices. For more flexibility in
                behavior, consider using <a href=
                "https://w3c.github.io/mediacapture-fromelement/#dom-htmlmediaelement-capturestream()">
                <code>HTMLEMediaElement.captureStream()</code></a>.
              </p>
              <p class="note">
                When an <a>AudioContext</a> has been closed, implementation can
                choose to aggressively release more resources than when
                suspending.
              </p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>Promise&lt;void&gt;</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createMediaElementSource</dfn></code>
            </dt>
            <dd>
              <p>
                Creates a <a href=
                "#MediaElementAudioSourceNode">MediaElementAudioSourceNode</a>
                given an HTMLMediaElement. As a consequence of calling this
                method, audio playback from the HTMLMediaElement will be
                re-routed into the processing graph of the
                <a><code>AudioContext</code></a>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    mediaElement
                  </td>
                  <td class="prmtype">
                    <code>HTMLMediaElement</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The media element that will be re-routed.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>MediaElementAudioSourceNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createMediaStreamDestination</dfn></code>
            </dt>
            <dd>
              <p>
                Creates a <a><code>MediaStreamAudioDestinationNode</code></a>
              </p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>MediaStreamAudioDestinationNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createMediaStreamSource</dfn></code>
            </dt>
            <dd>
              <p>
                Creates a <a><code>MediaStreamAudioSourceNode</code></a>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    mediaStream
                  </td>
                  <td class="prmType">
                    MediaStream
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The media stream that will act as source.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>MediaStreamAudioSourceNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>createMediaStreamTrackSource</dfn></code>
            </dt>
            <dd>
              <p>
                Creates a <a><code>MediaStreamTrackAudioSourceNode</code></a>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    mediaStreamTrack
                  </td>
                  <td class="prmType">
                    <code>MediaStreamTrack</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>MediaStreamTrack</code> that will act as source.
                    <span class="synchronous">The value of its
                    <code>kind</code> attribute must be equal to
                    <code>"audio"</code>, or an <code>InvalidStateError</code>
                    exception MUST be thrown.</span>
                  </td>
                </tr>
              </table>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>MediaStreamTrackAudioSourceNode</code>
              </div>
            </dd>
            <dt>
              <code><dfn>getOutputTimestamp</dfn></code>
            </dt>
            <dd>
              <p>
                Returns a new <a><code>AudioTimestamp</code></a> instance
                containing two correlated context's audio stream position
                values: the <a data-link-for=
                "AudioTimestamp"><code>contextTime</code></a> member contains
                the time of the sample frame which is currently being rendered
                by the audio output device (i.e., output audio stream
                position), in the same units and origin as context's
                <a data-link-for=
                "BaseAudioContext"><code>currentTime</code></a>; the
                <a data-link-for=
                "AudioTimestamp"><code>performanceTime</code></a> member
                contains the time estimating the moment when the sample frame
                corresponding to the stored <code>contextTime</code> value was
                rendered by the audio output device, in the same units and
                origin as <code>performance.now()</code> (described in
                [[!hr-time-2]]).
              </p>
              <p>
                If the context's rendering graph has not yet processed a block
                of audio, then <a><code>getOutputTimestamp</code></a> call
                returns an <code>AudioTimestamp</code> instance with both
                members containing zero.
              </p>
              <p>
                After the context's rendering graph has started processing of
                blocks of audio, its <a data-link-for=
                "BaseAudioContext"><code>currentTime</code></a> attribute value
                always exceeds the <a data-link-for=
                "AudioTimestamp"><code>contextTime</code></a> value obtained
                from <a data-link-for=
                "AudioContext"><code>getOutputTimestamp</code></a> method call.
              </p>
              <p>
                The value returned from <a><code>getOutputTimestamp</code></a>
                method can be used to get performance time estimation for the
                slightly later context's time value:
              </p>
              <pre class="example">
            function outputPerformanceTime(contextTime) {
                var timestamp = context.getOutputTimestamp();
                var elapsedTime = contextTime - timestamp.contextTime;
                return timestamp.performanceTime + elapsedTime * 1000;
            }
</pre>
              <p>
                In the above example the accuracy of the estimation depends on
                how close the argument value is to the current output audio
                stream position: the closer the given <code>contextTime</code>
                is to <code>timestamp.contextTime</code>, the better the
                accuracy of the obtained estimation.
              </p>
              <p class="note">
                The difference between the values of the context's
                <a data-link-for=
                "BaseAudioContext"><code>currentTime</code></a> and the
                <a data-link-for="AudioTimestamp"><code>contextTime</code></a>
                obtained from <a data-link-for=
                "AudioContext"><code>getOutputTimestamp</code></a> method call
                cannot be considered as a reliable output latency estimation
                because <a data-link-for=
                "BaseAudioContext"><code>currentTime</code></a> may be
                incremented at non-uniform time intervals, so <a data-link-for=
                "AudioContext"><code>outputLatency</code></a> attribute should
                be used instead.
              </p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>AudioTimestamp</code>
              </div>
            </dd>
            <dt>
              <code><dfn>suspend</dfn></code>
            </dt>
            <dd>
              <p>
                Suspends the progression of <a>AudioContext</a>'s
                <a data-link-for="BaseAudioContext">currentTime</a>, allows any
                current context processing blocks that are already processed to
                be played to the destination, and then allows the system to
                release its claim on audio hardware. This is generally useful
                when the application knows it will not need the
                <a>AudioContext</a> for some time, and wishes to temporarily
                <a>release system resource</a> associated with the
                <a>AudioContext</a>. The promise resolves when the frame buffer
                is empty (has been handed off to the hardware), or immediately
                (with no other effect) if the context is already
                <code>suspended</code>. The promise is rejected if the context
                has been closed.
              </p>
              <p>
                <span class="synchronous">When suspend is called, execute these
                steps:</span>
              </p>
              <ol>
                <li>Let <em>promise</em> be a new Promise.
                </li>
                <li>If the <em>control thread state</em> flag on the
                <a>AudioContext</a> is <code>closed</code> reject the promise
                with <code>InvalidStateError</code>, abort these steps,
                returning <em>promise</em>.
                </li>
                <li>If the <a data-link-for="AudioContext">state</a> attribute
                of the <a>AudioContext</a> is already <code>suspended</code>,
                resolve <em>promise</em>, return it, and abort these steps.
                </li>
                <li>Set the <em>control thread state</em> flag on the
                <a>AudioContext</a> to <code>suspended</code>.
                </li>
                <li>
                  <a href="#queue">Queue a control message</a> to suspend the
                  <a>AudioContext</a>.
                </li>
                <li>Return <em>promise</em>.
                </li>
              </ol>
              <p>
                Running a <a>control message</a> to suspend an
                <a>AudioContext</a> means running these steps on the
                <a>rendering thread</a>:
              </p>
              <ol>
                <li>Attempt to <a>release system resources</a>.
                </li>
                <li>Set the <a>rendering thread state</a> on the
                <a>AudioContext</a> to <code>suspended</code>.
                </li>
                <li>Queue a task on the <a>control thread</a>'s event loop, to
                execute these steps:
                  <ol>
                    <li>Resolve <em>promise</em>.
                    </li>
                    <li>If the <a data-link-for="audiocontext">state</a>
                    attribute of the <a>AudioContext</a> is not already <code>
                      suspended</code>:
                      <ol>
                        <li>Set the <a data-link-for="audiocontext">state</a>
                        attribute of the <a>AudioContext</a> to
                        <code>suspended</code>.
                        </li>
                        <li>Queue a task to fire a simple event named
                        <code>statechange</code> at the <a>AudioContext</a>.
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
              <p>
                While an <a>AudioContext</a> is suspended,
                <code>MediaStream</code>s will have their output ignored; that
                is, data will be lost by the real time nature of media streams.
                <code>HTMLMediaElement</code>s will similarly have their output
                ignored until the system is resumed. <a>AudioWorkletNode</a>s
                and <a>ScriptProcessorNode</a>s will cease to have their
                processing handlers invoked while suspended, but will resume
                when the context is resumed. For the purpose of
                <a>AnalyserNode</a> window functions, the data is considered as
                a continuous stream - i.e. the
                <code>resume()</code>/<code>suspend()</code> does not cause
                silence to appear in the <a>AnalyserNode</a>'s stream of data.
                In particular, calling <a>AnalyserNode</a> functions repeatedly
                when a <a>AudioContext</a> is suspended MUST return the same
                data.
              </p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>Promise&lt;void&gt;</code>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            <dfn>AudioContextOptions</dfn>
          </h3>
          <p>
            The <a><code>AudioContextOptions</code></a> dictionary is used to
            specify user-specified options for an <a>AudioContext</a>.
          </p>
          <pre class="idl">
[Exposed=Window]
dictionary AudioContextOptions {
             (AudioContextLatencyCategory or double) latencyHint = "interactive";
             float                                   sampleRate;
};
          </pre>
          <section>
            <h4>
              Dictionary <a>AudioContextOptions</a> Members
            </h4>
            <dl class="attributes" data-dfn-for="AudioContextOptions"
            data-link-for="AudioContextOptions">
              <dt>
                <code><dfn>latencyHint</dfn></code> of type <span class=
                "idlAttrType"><a>AudioContextLatencyCategory</a> or
                <a>double</a></span>, defaulting to "interactive"
              </dt>
              <dd>
                <p>
                  Identify the type of playback, which affects tradeoffs
                  between audio output latency and power consumption.
                </p>
                <p>
                  The preferred value of the <code>latencyHint</code> is a
                  value from <a>AudioContextLatencyCategory</a>. However, a
                  double can also be specified for the number of seconds of
                  latency for finer control to balance latency and power
                  consumption. It is at the browser's discretion to interpret
                  the number appropriately. The actual latency used is given by
                  AudioContext's <a data-link-for=
                  "BaseAudioContext">baseLatency</a> attribute.
                </p>
              </dd>
              <dt>
                <code><dfn>sampleRate</dfn></code> of type <span class=
                "idlAttrType"><a>float</a></span>
              </dt>
              <dd>
                <p>
                  Set the <a data-link-for=
                  "BaseAudioContext"><code>sampleRate</code></a> to this value
                  for the <a>AudioContext</a> that will be created. The
                  supported values are the same as the sample rates for an
                  <a>AudioBuffer</a>. <span class="synchronous">A
                  <code>NotSupportedError</code> exception MUST be thrown if
                  the specified sample rate is not supported.</span>
                </p>
                <p>
                  If <a data-link-for=
                  "AudioContextOptions"><code>sampleRate</code></a> is not
                  specified, the preferred sample rate of the output device for
                  this <a>AudioContext</a> is used.
                </p>
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h3>
            <dfn>AudioTimestamp</dfn>
          </h3>
          <pre class="idl">
[Exposed=Window]
dictionary AudioTimestamp {
             double              contextTime;
             DOMHighResTimeStamp performanceTime;
};
          </pre>
          <section>
            <h4>
              Dictionary <a>AudioTimestamp</a> Members
            </h4>
            <dl class="attributes" data-dfn-for="AudioTimestamp" data-link-for=
            "AudioTimestamp">
              <dt>
                <code><dfn>contextTime</dfn></code> of type <span class=
                "idlAttrType"><a>double</a></span>
              </dt>
              <dd>
                Represents a point in the time coordinate system of
                BaseAudioContext's <a data-link-for=
                "BaseAudioContext"><code>currentTime</code></a>.
              </dd>
              <dt>
                <code><dfn>performanceTime</dfn></code> of type <span class=
                "idlAttrType"><a>DOMHighResTimeStamp</a></span>
              </dt>
              <dd>
                Represents a point in the time coordinate system of a
                <code>Performance</code> interface implementation (described in
                [[!hr-time-2]]).
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2 id="OfflineAudioContext">
          The OfflineAudioContext Interface
        </h2>
        <p>
          <a><code>OfflineAudioContext</code></a> is a particular type of
          <a><code>BaseAudioContext</code></a> for rendering/mixing-down
          (potentially) faster than real-time. It does not render to the audio
          hardware, but instead renders as quickly as possible, fulfilling the
          returned promise with the rendered result as an
          <code>AudioBuffer</code>.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (OfflineAudioContextOptions contextOptions),
 Constructor (unsigned long numberOfChannels, unsigned long length, float sampleRate)]
interface OfflineAudioContext : BaseAudioContext {
    Promise&lt;AudioBuffer&gt; startRendering ();
    Promise&lt;void&gt;        suspend (double suspendTime);
    readonly        attribute unsigned long length;
                    attribute EventHandler  oncomplete;
};
        </pre>
        <section>
          <h2>
            Constructors
          </h2>
          <dl class="methods" data-dfn-for="OfflineAudioContext" data-link-for=
          "OfflineAudioContext">
            <dt>
              <code><dfn>OfflineAudioContext</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>c</var> be a new <a>OfflineAudioContext</a> object.
                Initialize <var>c</var> as follows:
              </p>
              <ol>
                <li>Set the <code>control thread state</code> for <var>c</var>
                to <code>"suspended"</code>.
                </li>
                <li>Set the <code>rendering thread state</code> for
                <var>c</var> to <code>"suspended"</code>.
                </li>
                <li>Construct an <a>AudioDestinationNode</a> with its
                <a data-link-for="AudioNode">channelCount</a> set to
                <code>contextOptions.numberOfChannels</code>.
                </li>
              </ol>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    <a><code>contextOptions</code></a>
                  </td>
                  <td class="prmType">
                    <a><code>OfflineAudioContextOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The initial parameters needed to construct this context.
                  </td>
                </tr>
              </table>
            </dd>
            <dt>
              <code>OfflineAudioContext</code>
            </dt>
            <dd>
              <p>
                The OfflineAudioContext can constructed with the same arguments
                as AudioContext.createBuffer. <span class="synchronous">A
                <code>NotSupportedError</code> exception MUST be thrown if any
                of the arguments is negative, zero, or outside its nominal
                range.</span>
              </p>
              <p>
                The OfflineAudioContext is constructed as if
              </p>
              <pre>
  new OfflineAudioContext({
      numberOfChannels: numberOfChannels,
      length: length,
      sampleRate: sampleRate
  })
</pre>
              <p>
                were called instead.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    <a><code>numberOfChannels</code></a>
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    Determines how many channels the buffer will have. See
                    <a data-link-for="BaseAudioContext">createBuffer</a> for
                    the supported number of channels.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    <a><code>length</code></a>
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    Determines the size of the buffer in sample-frames.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    <a><code>sampleRate</code></a>
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    Describes the sample-rate of the linear PCM audio data in
                    the buffer in sample-frames per second. See
                    <a data-link-for="BaseAudioContext">createBuffer</a> for
                    valid sample rates.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Attributes
          </h2>
          <dl class="attributes" data-dfn-for="OfflineAudioContext"
          data-link-for="OfflineAudioContext">
            <dt>
              <dfn>length</dfn> of type <span class="idlAttrType"><a>unsigned
              long</a></span>, readonly
            </dt>
            <dd>
              The size of the buffer in sample-frames. This is the same as the
              value of the <code>length</code> parameter for the constructor.
            </dd>
            <dt>
              <dfn>oncomplete</dfn> of type <span class=
              "idlAttrType"><a>EventHandler</a></span>, readonly
            </dt>
            <dd>
              An EventHandler of type <a href=
              "#OfflineAudioCompletionEvent">OfflineAudioCompletionEvent</a>.
              It is the last event fired on an <a>OfflineAudioContext</a>.
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Methods
          </h2>
          <dl class="methods" data-dfn-for="OfflineAudioContext" data-link-for=
          "OfflineAudioContext">
            <dt>
              <code><dfn>startRendering</dfn></code>
            </dt>
            <dd>
              <p>
                Given the current connections and scheduled changes, starts
                rendering audio. The system shall ensure that the
                <code>OfflineAudioContext</code> is not garbage collected until
                either the promise is resolved and any callback function is
                called and completes, or until the <code>suspend</code>
                function is called.
              </p>
              <p>
                Although the primary method of getting the rendered audio data
                is via its promise return value, the instance will also fire an
                event named <code>complete</code> for legacy reasons.
              </p>
              <p>
                <span class="synchronous">When <code>startRendering</code> is
                called, the following steps MUST be performed on the <a>control
                thread</a>:</span>
              </p>
              <ol>
                <li>Set a flag called <var>renderingStarted</var> on the
                <a>OfflineAudioContext</a> to <em>true</em>.
                </li>
                <li>If the <em>renderingStarted</em> flag on the
                <a>OfflineAudioContext</a> is <em>true</em>, return a rejected
                promise with <code>InvalidStateError</code>, and abort these
                steps.
                </li>
                <li>Let <var>promise</var> be a new promise.
                </li>
                <li>Create a new <code>AudioBuffer</code>, with a number of
                channels, length and sample rate equal respectively to the
                <code>numberOfChannels</code>, <code>length</code> and
                <code>sampleRate</code> values passed to this instance's
                constructor in the <code>contextOptions</code> parameter.
                Assign this buffer to an internal slot <a><var>[[rendered
                buffer]]</var></a> in the <a>OfflineAudioContext</a>.
                </li>
                <li>If an exception was thrown during the preceding
                <code>AudioBuffer</code> constructor call, reject
                <var>promise</var> with this exception.
                </li>
                <li>Otherwise, in the case that the buffer was successfully
                constructed, <a>begin offline rendering</a>.
                </li>
                <li>Return <var>promise</var>.
                </li>
              </ol>
              <p>
                To <dfn>begin offline rendering</dfn>, the following steps MUST
                happen on a <a>rendering thread</a> that is created for the
                occasion.
              </p>
              <ol>
                <li>Given the current connections and scheduled changes, start
                rendering <code>length</code> sample-frames of audio into
                <a><var>[[rendered buffer]]</var></a>.
                </li>
                <li>For every <a>render quantum</a>, check and suspend the
                rendering if necessary.
                </li>
                <li>If a suspended context is resumed, continue to render the
                buffer.
                </li>
                <li>Once the rendering is complete, queue a task on the
                <a>control thread</a>'s event loop to perform the following
                steps:
                  <ol>
                    <li>Resolve <var>promise</var> with <a><var>[[rendered
                    buffer]]</var></a>.
                    </li>
                    <li>Queue a task to fire an event named
                    <code>complete</code> at this instance, using an instance
                    of <a><code>OfflineAudioCompletionEvent</code></a> whose
                    <code>renderedBuffer</code> property is set to
                    <a><var>[[rendered buffer]]</var></a>.
                    </li>
                  </ol>
                </li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>Promise&lt;AudioBuffer&gt;</code>
              </div>
            </dd>
            <dt>
              <code><dfn>suspend</dfn></code>
            </dt>
            <dd>
              <p>
                Schedules a suspension of the time progression in the audio
                context at the specified time and returns a promise. This is
                generally useful when manipulating the audio graph
                synchronously on <a><code>OfflineAudioContext</code></a>.
              </p>
              <p>
                Note that the maximum precision of suspension is the size of
                the <a>render quantum</a> and the specified suspension time
                will be rounded down to the nearest <a>render quantum</a>
                boundary. For this reason, it is not allowed to schedule
                multiple suspends at the same quantized frame. Also, scheduling
                should be done while the context is not running to ensure
                precise suspension.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    suspendTime
                  </td>
                  <td class="prmType">
                    <code>double</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    Schedules a suspension of the rendering at the specified
                    time, which is quantized and rounded down to the <a>render
                    quantum</a> size. If the quantized frame number
                    <ol>
                      <li>is negative or
                      </li>
                      <li>is less than or equal to the current time or
                      </li>
                      <li>is greater than or equal to the total render duration
                      or
                      </li>
                      <li>is scheduled by another suspend for the same time,
                      </li>
                    </ol>then the promise is rejected with
                    <code>InvalidStateError</code>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;void&gt;</code>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            <dfn>OfflineAudioContextOptions</dfn>
          </h3>
          <p>
            This specifies the options to use in constructing an
            <a>OfflineAudioContext</a>.
          </p>
          <pre class="idl">
[Exposed=Window]
dictionary OfflineAudioContextOptions {
             unsigned long numberOfChannels = 1;
    required unsigned long length;
    required float         sampleRate;
};
          </pre>
          <section>
            <h4>
              Dictionary <a>OfflineAudioContextOptions</a> Members
            </h4>
            <dl class="attributes" data-dfn-for="OfflineAudioContextOptions"
            data-link-for="OfflineAudioContextOptions">
              <dt>
                <code><dfn>length</dfn></code> of type <span class=
                "idlAttrType"><a>unsigned long</a></span>, required
              </dt>
              <dd>
                The length of the rendered <a>AudioBuffer</a> in sample-frames.
              </dd>
              <dt>
                <code><dfn>numberOfchannels</dfn></code> of type <span class=
                "idlAttrType"><a>unsigned long</a></span>, required, defaulting
                to 1
              </dt>
              <dd>
                The number of channels for this <a>OfflineAudioContext</a>.
              </dd>
              <dt>
                <code><dfn>sampleRate</dfn></code> of type <span class=
                "idlAttrType"><a>double</a></span>, required
              </dt>
              <dd>
                The sample rate for this <a>OfflineAudioContext</a>.
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h2 id="OfflineAudioCompletionEvent">
            The <dfn>OfflineAudioCompletionEvent</dfn> Interface
          </h2>
          <p>
            This is an <code>Event</code> object which is dispatched to
            <a><code>OfflineAudioContext</code></a> for legacy reasons.
          </p>
          <pre class="idl">
[Exposed=Window,
 Constructor (DOMString type, OfflineAudioCompletionEventInit eventInitDict)]
interface OfflineAudioCompletionEvent : Event {
    readonly        attribute AudioBuffer renderedBuffer;
};
          </pre>
          <section>
            <h3>
              Attributes
            </h3>
            <dl class="attributes" data-dfn-for="OfflineAudioCompletionEvent"
            data-link-for="OfflineAudioCompletionEvent">
              <dt>
                <code><dfn>renderedBuffer</dfn></code> of type <span class=
                "idlAttrType"><a>AudioBuffer</a></span>, readonly
              </dt>
              <dd>
                An <code>AudioBuffer</code> containing the rendered audio data.
              </dd>
            </dl>
          </section>
          <section>
            <h3>
              <dfn>OfflineAudioCompletionEventInit</dfn>
            </h3>
            <pre class="idl">
[Exposed=Window]
dictionary OfflineAudioCompletionEventInit : EventInit {
    required AudioBuffer renderedBuffer;
};
            </pre>
            <section>
              <h4>
                Dictionary <a>OfflineAudioCompletionEventInit</a> Members
              </h4>
              <dl class="attributes" data-dfn-for=
              "OfflineAudioCompletionEventInit" data-link-for=
              "OfflineAudioCompletionEventInit">
                <dt>
                  <code><dfn>renderedBuffer</dfn></code> of type <span class=
                  "idlAttrType"><a>AudioBuffer</a></span>, readonly
                </dt>
                <dd>
                  Value to be assigned to the <a data-link-for=
                  "OfflineAudioCompletionEvent"><code>renderedBuffer</code></a>
                  attribute of the event.
                </dd>
              </dl>
            </section>
          </section>
        </section>
      </section>
      <section>
        <h2>
          The <dfn>AudioNode</dfn> Interface
        </h2>
        <p>
          <a>AudioNode</a>s are the building blocks of an <a href=
          "#AudioContext"><code>AudioContext</code></a>. This interface
          represents audio sources, the audio destination, and intermediate
          processing modules. These modules can be connected together to form
          <a href="#ModularRouting">processing graphs</a> for rendering audio
          to the audio hardware. Each node can have <a>inputs</a> and/or
          <a>outputs</a>. A <a>source node</a> has no inputs and a single
          output. Most processing nodes such as filters will have one input and
          one output. Each type of <a><code>AudioNode</code></a> differs in the
          details of how it processes or synthesizes audio. But, in general, an
          <a><code>AudioNode</code></a> will process its inputs (if it has
          any), and generate audio for its outputs (if it has any).
        </p>
        <p>
          Each output has one or more channels. The exact number of channels
          depends on the details of the specific <a><code>AudioNode</code></a>.
        </p>
        <p>
          An output may connect to one or more <a><code>AudioNode</code></a>
          inputs, thus <em>fan-out</em> is supported. An input initially has no
          connections, but may be connected from one or more <a>AudioNode</a>
          outputs, thus <em>fan-in</em> is supported. When the
          <code>connect()</code> method is called to connect an output of an
          <a>AudioNode</a> to an input of an <a>AudioNode</a>, we call that a
          <dfn>connection</dfn> to the input.
        </p>
        <p>
          Each <a>AudioNode</a> <dfn>input</dfn> has a specific number of
          channels at any given time. This number can change depending on the
          <a>connection</a>(s) made to the input. If the input has no
          connections then it has one channel which is silent.
        </p>
        <p>
          For each <a>input</a>, an <a><code>AudioNode</code></a> performs a
          mixing (usually an up-mixing) of all connections to that input.
          Please see <a href="#mixer-gain-structure"></a> for more informative
          details, and the <a href="#channel-up-mixing-and-down-mixing"></a>
          section for normative requirements.
        </p>
        <p>
          The processing of inputs and the internal operations of an
          <a>AudioNode</a> take place continuously with respect to
          <a>AudioContext</a> time, regardless of whether the node has
          connected outputs, and regardless of whether these outputs ultimately
          reach an <a>AudioContext</a>'s <a>AudioDestinationNode</a>.
        </p>
        <p>
          For performance reasons, practical implementations will need to use
          block processing, with each <a><code>AudioNode</code></a> processing
          a fixed number of sample-frames of size <em>block-size</em>. In order
          to get uniform behavior across implementations, we will define this
          value explicitly. <em>block-size</em> is defined to be 128
          sample-frames which corresponds to roughly 3ms at a sample-rate of
          44.1 kHz.
        </p>
        <section>
          <h3>
            AudioNode Creation
          </h3>
          <p>
            <a>AudioNode</a>s can be created in two ways: by using the
            constructor for this particular interface, or by using the
            <dfn>factory method</dfn> on the <a>BaseAudioContext</a> or
            <a>AudioContext</a>.
          </p>
          <p>
            The <a>BaseAudioContext</a> passed as first argument of the
            constructor of an <a>AudioNode</a>s is called the <dfn id=
            "associated">associated <a>BaseAudioContext</a></dfn> of the
            <a>AudioNode</a> to be created. Similarly, when using the factory
            method, the <a>associated <code>BaseAudioContext</code></a> of the
            <a>AudioNode</a> is the <a>BaseAudioContext</a> this factory method
            is called on.
          </p>
          <p>
            To create a new <a>AudioNode</a> of a particular type <var>n</var>
            using its constructor, with a <a>BaseAudioContext</a> <var>c</var>
            as first argument, and an <a>associated option object</a>
            <var>option</var> as second argument, from the <a href=
            "https://html.spec.whatwg.org/multipage/webappapis.html#concept-relevant-global">
            relevant global</a> of <var>c</var>, execute these steps:
          </p>
          <ol>
            <li>Let <var>o</var> be a new object of type <var>n</var>.
            </li>
            <li>
              <a href="#audionode-constructor-init">Initialize</a>
              <var>o</var>, with <var>c</var> and <var>option</var> as
              arguments.
            </li>
            <li>Return <var>o</var>
            </li>
          </ol>
          <p>
            To create a new <a>AudioNode</a> of a particular type <var>n</var>
            using its <a>factory method</a>, called on a
            <var>BaseAudioContext</var> <var>c</var>, execute these steps:
          </p>
          <ol>
            <li>Let <var>o</var> be a new object of type <var>n</var>.
            </li>
            <li>Let <var>option</var> be a dictionary of the type <a href=
            "#dfn-associated-option-object">associated</a> to the interface
            <a href="#dfn-associated-interface">associated</a> to this factory
            method.
            </li>
            <li>For each parameter passed to the factory method, set the
            dictionary member of the same name on <var>option</var> to the
            value of this parameter.
            </li>
            <li>
              <a href="#audionode-constructor-init">Initialize</a> <var>o</var>
              with <var>c</var> and <var>option</var> as arguments.
            </li>
            <li>Return <var>o</var>
            </li>
          </ol>
          <p>
            <dfn id="audionode-constructor-init">Initializing</dfn> an object
            <var>o</var> of interface <var>n</var> that inherits from
            <a>AudioNode</a> means executing the following steps, given the
            arguments <var>context</var> and <var>dict</var> passed to the
            constructor of this interface.
          </p>
          <ol>
            <li>Set <var>o</var>'s associated <a>BaseAudioContext</a> to <var>
              context</var>.
            </li>
            <li>Set its value for <a data-link-for=
            "AudioNode">numberOfInputs</a>, <a data-link-for=
            "AudioNode">numberOfOutputs</a>, <a data-link-for=
            "AudioNode">channelCount</a>, <a data-link-for=
            "AudioNode">channelCountMode</a>, <a data-link-for=
            "AudioNode">channelInterpretation</a> to the default value for this
            specific interface outlined in the section for each
            <a>AudioNode</a>.
            </li>
            <li>If the <a>AudioNode</a> being constructed is a
            <a>ConvolverNode</a>, set its <a data-link-for=
            "ConvolverNode">normalize</a> attribute with the inverse of the
            value of the <a data-link-for=
            "ConvolverOptions">disableNormalization</a> in <var>dict</var>, and
            then set its <a data-link-for="ConvolverNode">buffer</a> attribute
            to the value of the <a data-link-for="ConvolverOptions">buffer</a>
            in <var>dict</var> member, in this order, and jump to the last step
            of this algorithm.
              <div class="note">
                This means that the buffer will be normalized according to the
                value of the <a data-link-for="ConvolverNode">normalize</a>
                attribute.
              </div>
            </li>
            <li>For each member of <var>dict</var> passed in, execute these
            steps, with <var>k</var> the key of the member, and <var>v</var>
            its value:
              <ol>
                <li>If <var>k</var> is <code>disableNormalization</code> or
                <code>buffer</code> and <var>n</var> is <a>ConvolverNode</a>,
                jump to the beginning of this loop.
                </li>
                <li>If <var>k</var> is the name of an <a>AudioParam</a> on this
                interface, set the <a data-link-for="AudioParam">value</a>
                attribute of this <a>AudioParam</a> to <var>v</var>.
                </li>
                <li>Else if <var>k</var> is the name of an attribute on this
                interface, set the object associated with this attribute to
                <var>v</var>.
                </li>
              </ol>
            </li>
          </ol>
          <p>
            The <dfn>associated interface</dfn> for a factory method is the
            interface of the objects that are returned from this method. The
            <dfn>associated option object</dfn> for an interface is the option
            object that can be passed to the constructor for this interface.
          </p>
        </section>
        <p>
          <a>AudioNode</a>s are <em>EventTarget</em>s, as described in
          <cite><a href="https://dom.spec.whatwg.org/">DOM</a></cite> [[!DOM]].
          This means that it is possible to dispatch events to
          <a><code>AudioNode</code></a>s the same way that other EventTargets
          accept events.
        </p>
        <pre class="idl">
[Exposed=Window]
enum ChannelCountMode {
    "max",
    "clamped-max",
    "explicit"
};
        </pre>
        <table class="simple" data-dfn-for="ChannelCountMode" data-link-for=
        "ChannelCountMode">
          <tr>
            <th colspan="2">
              Enumeration description
            </th>
          </tr>
          <tr>
            <td>
              <dfn>max</dfn>
            </td>
            <td>
              <a><code>computedNumberOfChannels</code></a> is computed as the
              maximum of the number of channels of all connections. In this
              mode channelCount is ignored
            </td>
          </tr>
          <tr>
            <td>
              <dfn>clamped-max</dfn>
            </td>
            <td>
              Same as â€œmaxâ€ up to a limit of the channelCount
            </td>
          </tr>
          <tr>
            <td>
              <dfn>explicit</dfn>
            </td>
            <td>
              <a><code>computedNumberOfChannels</code></a> is the exact value
              as specified in channelCount
            </td>
          </tr>
        </table>
        <pre class="idl">
[Exposed=Window]
enum ChannelInterpretation {
    "speakers",
    "discrete"
};
        </pre>
        <table class="simple" data-dfn-for="ChannelInterpretation"
        data-link-for="ChannelInterpretation">
          <tr>
            <th colspan="2">
              Enumeration description
            </th>
          </tr>
          <tr>
            <td>
              <dfn>speakers</dfn>
            </td>
            <td>
              use <a href="#UpMix-sub">up-mix equations</a> or <a href=
              "#down-mix">down-mix equations</a>. In cases where the number of
              channels do not match any of these basic speaker layouts, revert
              to "<a data-link-for="ChannelInterpretation">discrete</a>".
            </td>
          </tr>
          <tr>
            <td>
              <dfn>discrete</dfn>
            </td>
            <td>
              Up-mix by filling channels until they run out then zero out
              remaining channels. down-mix by filling as many channels as
              possible, then dropping remaining channels.
            </td>
          </tr>
        </table>
        <pre class="idl">
[Exposed=Window]
interface AudioNode : EventTarget {
    AudioNode connect (AudioNode destination, optional unsigned long output = 0
              , optional unsigned long input = 0
              );
    void      connect (AudioParam destination, optional unsigned long output = 0
              );
    void      disconnect ();
    void      disconnect (unsigned long output);
    void      disconnect (AudioNode destination);
    void      disconnect (AudioNode destination, unsigned long output);
    void      disconnect (AudioNode destination, unsigned long output, unsigned long input);
    void      disconnect (AudioParam destination);
    void      disconnect (AudioParam destination, unsigned long output);
    readonly        attribute BaseAudioContext      context;
    readonly        attribute unsigned long         numberOfInputs;
    readonly        attribute unsigned long         numberOfOutputs;
                    attribute unsigned long         channelCount;
                    attribute ChannelCountMode      channelCountMode;
                    attribute ChannelInterpretation channelInterpretation;
};
        </pre>
        <section>
          <h2>
            Attributes
          </h2>
          <dl class="attributes" data-dfn-for="AudioNode" data-link-for=
          "AudioNode">
            <dt>
              <code><dfn>channelCount</dfn></code> of type <span class=
              "idlAttrType"><a><code>unsigned long</code></a></span>
            </dt>
            <dd>
              <p>
                <a>channelCount</a> is the number of channels used when
                up-mixing and down-mixing connections to any inputs to the
                node. The default value is 2 except for specific nodes where
                its value is specially determined. This attribute has no effect
                for nodes with no inputs. <span class="synchronous">If this
                value is set to zero or to a value greater than the
                implementation's maximum number of channels the implementation
                MUST throw a <code>NotSupportedError</code> exception.</span>
              </p>
              <p>
                In addition, some nodes have additional <dfn>channelCount
                constraints</dfn> on the possible values for the channel count:
              </p>
              <dl>
                <dt>
                  <a>AudioDestinationNode</a>
                </dt>
                <dd>
                  <p>
                    The behavior depends on whether the destination node is the
                    destination of an <a>AudioContext</a> or
                    <a>OfflineAudioContext</a>
                  </p>
                  <dl>
                    <dt>
                      <a>AudioContext</a>
                    </dt>
                    <dd>
                      The channel count MUST be between 1 and
                      <a>maxChannelCount</a>. An <span class=
                      "synchronous"><code>IndexSizeError</code> exception MUST
                      be thrown for any attempt to set the count outside this
                      range</span>.
                    </dd>
                    <dt>
                      <a>OfflineAudioContext</a>
                    </dt>
                    <dd>
                      The channel count cannot be changed. An <span class=
                      "synchronous"><code>InvalidStateError</code> exception
                      MUST be thrown for any attempt to change the
                      value.</span>
                    </dd>
                  </dl>
                </dd>
                <dt>
                  <a>ChannelSplitterNode</a>
                </dt>
                <dd>
                  The channel count cannot be changed, and an <span class=
                  "synchronous"><code>InvalidStateError</code> exception MUST
                  be thrown for any attempt to change the value.</span>
                </dd>
                <dt>
                  <a>ChannelMergerNode</a>
                </dt>
                <dd>
                  The channel count cannot be changed, and an <span class=
                  "synchronous"><code>InvalidStateError</code> exception MUST
                  be thrown for any attempt to change the value.</span>
                </dd>
                <dt>
                  <a>ConvolverNode</a>
                </dt>
                <dd>
                  The channel count cannot changed from two, and a <span class=
                  "synchronous"><code>NotSupportedError</code> exception MUST
                  be thrown for any attempt to change the value..</span>
                </dd>
                <dt>
                  <a>DynamicsCompressorNode</a>
                </dt>
                <dd>
                  The channel count cannot be greater than two, and a
                  <span class="synchronous"><code>NotSupportedError</code>
                  exception MUST be thrown for any attempt to change the to a
                  value greater than two.</span>
                </dd>
                <dt>
                  <a>PannerNode</a>
                </dt>
                <dd>
                  The channel count cannot be greater than two, and a
                  <span class="synchronous"><code>NotSupportedError</code>
                  exception MUST be thrown for any attempt to change the to a
                  value greater than two.</span>
                </dd>
                <dt>
                  <a>ScriptProcessorNode</a>
                </dt>
                <dd>
                  The channel count cannot be changed, and an <span class=
                  "synchronous"><code>InvalidStateError</code> exception MUST
                  be thrown for any attempt to change the value.</span>
                </dd>
                <dt>
                  <a>StereoPannerNode</a>
                </dt>
                <dd>
                  The channel count cannot be greater than two, and a
                  <span class="synchronous"><code>NotSupportedError</code>
                  exception MUST be thrown for any attempt to change the to a
                  value greater than two.</span>
                </dd>
              </dl>
              <p>
                See the <a href="#channel-up-mixing-and-down-mixing"></a>
                section for more information on this attribute.
              </p>
            </dd>
            <dt>
              <code><dfn>channelCountMode</dfn></code> of type <span class=
              "idlAttrType"><a><code>ChannelCountMode</code></a></span>
            </dt>
            <dd>
              <p>
                <a>channelCountMode</a> determines how channels will be counted
                when up-mixing and down-mixing connections to any inputs to the
                node. This attribute has no effect for nodes with no inputs.
              </p>
              <p>
                In addition, some nodes have additional <dfn>channelCountMode
                constraints</dfn> on the possible values for the channel count
                mode:
              </p>
              <dl>
                <dt>
                  <a>AudioDestinationNode</a>
                </dt>
                <dd>
                  If the <a>AudioDestinationNode</a> is the <a data-link-for=
                  "BaseAudioContext">destination</a> node of an
                  <a>OfflineAudioContext</a>, then the channel count mode
                  cannot be changed. An <span class=
                  "synchronous"><code>InvalidStateError</code> exception MUST
                  be thrown for any attempt to change the value.</span>
                </dd>
                <dt>
                  <a>ChannelSplitterNode</a>
                </dt>
                <dd>
                  The channel count mode cannot be changed from "explicit" and
                  an <span class="synchronous"><code>InvalidStateError</code>
                  exception MUST be thrown for any attempt to change the
                  value.</span>
                </dd>
                <dt>
                  <a>ChannelMergerNode</a>
                </dt>
                <dd>
                  The channel count mode cannot be changed from "explicit" and
                  an <span class="synchronous"><code>InvalidStateError</code>
                  exception MUST be thrown for any attempt to change the
                  value.</span>
                </dd>
                <dt>
                  <a>ConvolverNode</a>
                </dt>
                <dd>
                  The channel count mode cannot be changed from "clamped-max",
                  and a <span class=
                  "synchronous"><code>NotSupportedError</code> exception MUST
                  be thrown for any attempt to change the value.</span>
                </dd>
                <dt>
                  <a>DynamicsCompressorNode</a>
                </dt>
                <dd>
                  The channel count mode cannot be set to "max", and a
                  <span class="synchronous"><code>NotSupportedError</code>
                  exception MUST be thrown for any attempt to set it to
                  "max".</span>
                </dd>
                <dt>
                  <a>PannerNode</a>
                </dt>
                <dd>
                  The channel count mode cannot be set to "max", and a
                  <span class="synchronous"><code>NotSupportedError</code>
                  exception MUST be thrown for any attempt to set it to
                  "max".</span>
                </dd>
                <dt>
                  <a>ScriptProcessorNode</a>
                </dt>
                <dd>
                  The channel count mode cannot be changed from "explicit" and
                  an <span class="synchronous"><code>InvalidStateError</code>
                  exception MUST be thrown for any attempt to change the
                  value.</span>
                </dd>
                <dt>
                  <a>StereoPannerNode</a>
                </dt>
                <dd>
                  The channel count mode cannot be set to "max", and a
                  <span class="synchronous"><code>NotSupportedError</code>
                  exception MUST be thrown for any attempt to set it to
                  "max".</span>
                </dd>
              </dl>
              <p>
                See the <a href="#channel-up-mixing-and-down-mixing"></a>
                section for more information on this attribute.
              </p>
            </dd>
            <dt>
              <code><dfn>channelInterpretation</dfn></code> of type
              <span class="idlAttrType"><a><code>ChannelInterpretation</code></a></span>
            </dt>
            <dd>
              <p>
                <a>channelInterpretation</a> determines how individual channels
                will be treated when up-mixing and down-mixing connections to
                any inputs to the node. This attribute has no effect for nodes
                with no inputs.
              </p>
              <p>
                In addition, some nodes have additional
                <dfn>channelInterpretation constraints</dfn> on the possible
                values for the channel interpretation:
              </p>
              <dl>
                <dt>
                  <a>ChannelSplitterNode</a>
                </dt>
                <dd>
                  The channel intepretation can not be changed from
                  "<a data-link-for="ChannelInterpretation">discrete</a>" and a
                  <span class="synchronous"><code>InvalidStateError</code>
                  exception MUST be thrown for any attempt to change the
                  value.</span>
                </dd>
              </dl>
              <p>
                See the <a href="#channel-up-mixing-and-down-mixing"></a>
                section for more information on this attribute.
              </p>
            </dd>
            <dt>
              <code><dfn>context</dfn></code> of type <span class=
              "idlAttrType"><a><code>BaseAudioContext</code></a></span>,
              readonly
            </dt>
            <dd>
              The <a>BaseAudioContext</a> which owns this <a>AudioNode</a>.
            </dd>
            <dt>
              <code><dfn>numberOfInputs</dfn></code> of type <span class=
              "idlAttrType"><a><code>unsigned long</code></a></span>, readonly
            </dt>
            <dd>
              The number of inputs feeding into the <a>AudioNode</a>. For
              <dfn>source nodes</dfn>, this will be 0. This attribute is
              predetermined for many <a>AudioNode</a> types, but some
              <a>AudioNode</a>s, like the <a>ChannelMergerNode</a> and the
              <a>AudioWorkletNode</a>, have variable number of inputs.
            </dd>
            <dt>
              <code><dfn>numberOfOutputs</dfn></code> of type <span class=
              "idlAttrType"><a><code>unsigned long</code></a></span>, readonly
            </dt>
            <dd>
              The number of outputs coming out of the <a>AudioNode</a>. This
              attribute is predetermined for some <a>AudioNode</a> types, but
              can be variable, like for the <a>ChannelSplitterNode</a> and the
              <a>AudioWorkletNode</a>.
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            Methods
          </h2>
          <dl class="methods" data-dfn-for="AudioNode" data-link-for=
          "AudioNode">
            <dt>
              <dfn>connect</dfn>
            </dt>
            <dd>
              <p>
                There can only be one connection between a given output of one
                specific node and a given input of another specific node.
                Multiple connections with the same termini are ignored. For
                example:
              </p>
              <pre class="example">
    nodeA.connect(nodeB);
    nodeA.connect(nodeB);

</pre>
              <p>
                will have the same effect as
              </p>
              <pre class="example">
      nodeA.connect(nodeB);

</pre>
              <p>
                This method returns <code>destination</code>
                <a><code>AudioNode</code></a> object.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    destination
                  </td>
                  <td class="prmType">
                    <a><code>AudioNode</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>destination</code> parameter is the
                    <a><code>AudioNode</code></a> to connect to. If the
                    <code>destination</code> parameter is an
                    <a><code>AudioNode</code></a> that has been created using
                    another <a><code>AudioContext</code></a>, an
                    <code>InvalidAccessError</code> MUST be thrown. That is,
                    <a><code>AudioNodes</code></a> cannot be shared between
                    <a><code>AudioContext</code></a>s.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    output
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long = 0</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    The <code>output</code> parameter is an index describing
                    which output of the <a><code>AudioNode</code></a> from
                    which to connect. <span class="synchronous">If this
                    parameter is out-of-bound, an <code>IndexSizeError</code>
                    exception MUST be thrown.</span> It is possible to connect
                    an <a><code>AudioNode</code></a> output to more than one
                    input with multiple calls to connect(). Thus, "fan-out" is
                    supported.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    input
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long = 0</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    The <code>input</code> parameter is an index describing
                    which input of the destination
                    <a><code>AudioNode</code></a> to connect to. <span class=
                    "synchronous">If this parameter is out-of-bounds, an
                    <code>IndexSizeError</code> exception MUST be
                    thrown.</span> It is possible to connect an
                    <a><code>AudioNode</code></a> to another
                    <a><code>AudioNode</code></a> which creates a
                    <dfn>cycle</dfn>: an <a><code>AudioNode</code></a> may
                    connect to another <a><code>AudioNode</code></a>, which in
                    turn connects back to the first
                    <a><code>AudioNode</code></a>. This is allowed only if
                    there is at least one <a><code>DelayNode</code></a> in the
                    <em>cycle</em> <span class="synchronous">or a
                    <code>NotSupportedError</code> exception MUST be
                    thrown.</span>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a>AudioNode</a>
              </div>
            </dd>
            <dt>
              connect
            </dt>
            <dd>
              <p>
                Connects the <a><code>AudioNode</code></a> to an
                <a><code>AudioParam</code></a>, controlling the parameter value
                with an audio-rate signal.
              </p>
              <p>
                It is possible to connect an <a><code>AudioNode</code></a>
                output to more than one <a><code>AudioParam</code></a> with
                multiple calls to connect(). Thus, "fan-out" is supported.
              </p>
              <p>
                It is possible to connect more than one
                <a><code>AudioNode</code></a> output to a single
                <a><code>AudioParam</code></a> with multiple calls to
                connect(). Thus, "fan-in" is supported.
              </p>
              <p>
                An <a><code>AudioParam</code></a> will take the rendered audio
                data from any <a><code>AudioNode</code></a> output connected to
                it and <a href="#down-mix">convert it to mono</a> by
                down-mixing if it is not already mono, then mix it together
                with other such outputs and finally will mix with the
                <em>intrinsic</em> parameter value (the <code>value</code> the
                <a><code>AudioParam</code></a> would normally have without any
                audio connections), including any timeline changes scheduled
                for the parameter.
              </p>
              <p>
                The down-mixing to mono is equivalent to the down-mixing for an
                <a>AudioNode</a> with <a>channelCount</a> = 1,
                <a>channelCountMode</a> = "<a data-link-for=
                "ChannelCountMode">explicit</a>", and
                <a>channelInterpetation</a> = "<a data-link-for=
                "ChannelInterpretation">speakers</a>".
              </p>
              <p>
                There can only be one connection between a given output of one
                specific node and a specific <a><code>AudioParam</code></a>.
                Multiple connections with the same termini are ignored. For
                example:
              </p>
              <pre>
      nodeA.connect(param);
      nodeA.connect(param);

</pre>
              <p>
                will have the same effect as
              </p>
              <pre>
      nodeA.connect(param);

</pre>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    destination
                  </td>
                  <td class="prmType">
                    <a><code>AudioParam</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>destination</code> parameter is the
                    <a><code>AudioParam</code></a> to connect to. This method
                    does not return <code>destination</code>
                    <a><code>AudioParam</code></a> object. <span class=
                    "synchronous">If <var>destination</var> belongs to an
                    <a>AudioNode</a> that belongs to a <a>BaseAudioContext</a>
                    that is different from the <a>BaseAudioContext</a> that has
                    created the <a>AudioNode</a> on which this method was
                    called, an <code>InvalidAccessError</code> MUST be
                    thrown.</span>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    output
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long = 0</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    The <code>output</code> parameter is an index describing
                    which output of the <a><code>AudioNode</code></a> from
                    which to connect. <span class="synchronous">If the
                    <code>parameter</code> is out-of-bound, an
                    <code>IndexSizeError</code> exception MUST be
                    thrown.</span>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              <dfn>disconnect</dfn>
            </dt>
            <dd>
              <p>
                Disconnects all outgoing connections from the
                <a><code>AudioNode</code></a>.
              </p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              disconnect
            </dt>
            <dd>
              <p>
                Disconnects a single output of the
                <a><code>AudioNode</code></a> from any other
                <a><code>AudioNode</code></a> or <a><code>AudioParam</code></a>
                objects to which it is connected.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    output
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    This parameter is an index describing which output of the
                    <a><code>AudioNode</code></a> to disconnect. It disconnects
                    all outgoing connections from the given output.
                    <span class="synchronous">If this parameter is
                    out-of-bounds, an <code>IndexSizeError</code> exception
                    MUST be thrown.</span>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              disconnect
            </dt>
            <dd>
              <p>
                Disconnects all outputs of the <a><code>AudioNode</code></a>
                that go to a specific destination
                <a><code>AudioNode</code></a>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    destination
                  </td>
                  <td class="prmType">
                    <a><code>AudioNode</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>destination</code> parameter is the
                    <a><code>AudioNode</code></a> to disconnect. It disconnects
                    all outgoing connections to the given
                    <code>destination</code>. <span class="synchronous">If
                    there is no connection to the <code>destination</code>, an
                    <code>InvalidAccessError</code> exception MUST be
                    thrown.</span>
                  </td>
                </tr>
              </table>
            </dd>
            <dt>
              disconnect
            </dt>
            <dd>
              <p>
                Disconnects a specific output of the
                <a><code>AudioNode</code></a> from a specific input of some
                destination <a><code>AudioNode</code></a>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    destination
                  </td>
                  <td class="prmType">
                    <a><code>AudioNode</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>destination</code> parameter is the
                    <a><code>AudioNode</code></a> to disconnect. <span class=
                    "synchronous">If there is no connection to the
                    <code>destination</code> from the given output, an
                    <code>InvalidAccessError</code> exception MUST be
                    thrown.</span>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    output
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>output</code> parameter is an index describing
                    which output of the <a><code>AudioNode</code></a> from
                    which to disconnect. <span class="synchronous">If this
                    parameter is out-of-bound, an <code>IndexSizeError</code>
                    exception MUST be thrown.</span>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              disconnect
            </dt>
            <dd>
              <p>
                Disconnects a specific output of the
                <a><code>AudioNode</code></a> from a specific input of some
                destination <a><code>AudioNode</code></a>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    destination
                  </td>
                  <td class="prmType">
                    <a><code>AudioNode</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>destination</code> parameter is the
                    <a><code>AudioNode</code></a> to disconnect. <span class=
                    "synchronous">If there is no connection to the
                    <code>destination</code> from the given output, an
                    <code>InvalidAccessError</code> exception MUST be
                    thrown.</span>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    output
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>output</code> parameter is an index describing
                    which output of the <a><code>AudioNode</code></a> from
                    which to disconnect. <span class="synchronous">If this
                    parameter is out-of-bound, an <code>IndexSizeError</code>
                    exception MUST be thrown.</span>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    input
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>input</code> parameter is an index describing
                    which input of the destination
                    <a><code>AudioNode</code></a> to disconnect. <span class=
                    "synchronous">If this parameter is out-of-bounds, an
                    <code>IndexSizeError</code> exception MUST be
                    thrown.</span>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              disconnect
            </dt>
            <dd>
              <p>
                Disconnects all outputs of the <a><code>AudioNode</code></a>
                that go to a specific destination
                <a><code>AudioParam</code></a>. The contribution of this
                <a><code>AudioNode</code></a> to the computed parameter value
                goes to 0 when this operation takes effect. The intrinsic
                parameter value is not affected by this operation.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    destination
                  </td>
                  <td class="prmType">
                    <a><code>AudioParam</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>destination</code> parameter is the
                    <a><code>AudioParam</code></a> to disconnect. <span class=
                    "synchronous">If there is no connection to the
                    <code>destination</code>, an
                    <code>InvalidAccessError</code> exception MUST be
                    thrown.</span>
                  </td>
                </tr>
              </table>
            </dd>
            <dt>
              disconnect
            </dt>
            <dd>
              <p>
                Disconnects a specific output of the
                <a><code>AudioNode</code></a> from a specific destination
                <a><code>AudioParam</code></a>. The contribution of this
                <a><code>AudioNode</code></a> to the computed parameter value
                goes to 0 when this operation takes effect. The intrinsic
                parameter value is not affected by this operation.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    destination
                  </td>
                  <td class="prmType">
                    <a><code>AudioParam</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>destination</code> parameter is the
                    <a><code>AudioParam</code></a> to disconnect. <span class=
                    "synchronous">If there is no connection to the
                    <code>destination</code>, an
                    <code>InvalidAccessError</code> exception MUST be
                    thrown.</span>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    output
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <code>output</code> parameter is an index describing
                    which output of the <a><code>AudioNode</code></a> from
                    which to disconnect. <span class="synchronous">If the
                    <code>parameter</code> is out-of-bound, an
                    <code>IndexSizeError</code> exception MUST be
                    thrown.</span>
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>AudioNodeOptions</dfn>
          </h2>
          <p>
            This specifies the options that can be used in constructing all
            <a>AudioNode</a>s. All members are optional. However, the specific
            values used for each node depends on the actual node.
          </p>
          <pre class="idl">
dictionary AudioNodeOptions {
             unsigned long         channelCount;
             ChannelCountMode      channelCountMode;
             ChannelInterpretation channelInterpretation;
};
          </pre>
          <section>
            <h3>
              Dictionary <a>AudioNodeOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="AudioNodeOptions"
            data-link-for="AudioNodeOptions">
              <dt>
                <code><dfn>channelCount</dfn></code> of type <span class=
                "idlAttrType"><a>unsigned long</a></span>
              </dt>
              <dd>
                Desired number of channels for the <a>channelCount</a>
                attribute.
              </dd>
              <dt>
                <code><dfn>channelCountMode</dfn></code> of type <span class=
                "idlAttrType"><a>ChannelCountMode</a></span>
              </dt>
              <dd>
                Desired mode for the <a>channelCountMode</a> attribute.
              </dd>
              <dt>
                <code><dfn>channelInterpretation</dfn></code> of type
                <span class="idlAttrType"><a>ChannelInterpretation</a></span>
              </dt>
              <dd>
                Desired mode for the <a>channelInterpretation</a> attribute.
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h3 id="lifetime-AudioNode">
            Lifetime
          </h3>
          <p>
            The following behaviors provide a normative description of the
            conditions under which an <a>AudioNode</a> is alive, meaning that
            it MUST be retained in the graph by an implementation. Where these
            conditions do not apply, <a>AudioNode</a>s MAY be released by an
            implementation.
          </p>
          <p>
            There are several types of references:
          </p>
          <ol>
            <li>A <em>normal</em> reference obeying normal garbage collection
            rules.
            </li>
            <li>A <em>playing</em> reference for
            <a><code>AudioBufferSourceNode</code></a>s,
            <a><code>MediaElementAudioSourceNode</code></a>s,
            <a><code>MediaStreamAudioSourceNode</code></a>s and
            <a><code>OscillatorNode</code></a>s. These nodes maintain a
            <em>playing</em> reference to themselves while they are currently
            playing.
            </li>
            <li>An <dfn>active reference</dfn> for <a>AudioWorkletNode</a>s
            whose <a data-link-for="AudioWorkletNode">processorState</a>
            property is set to <code>running</code>.
            </li>
            <li>A <em>connection</em> reference which occurs if another
            <a>AudioNode</a> is connected to one or more of its inputs.
            Connections to a node's <a>AudioParam</a>s do not imply a
            connection reference.
            </li>
            <li>A <em><dfn>tail-time</dfn></em> reference which an
            <a><code>AudioNode</code></a> maintains on itself as long as it has
            any internal processing state which has not yet been emitted. For
            example, a <a><code>ConvolverNode</code></a> has a tail which
            continues to play even after receiving silent input (think about
            clapping your hands in a large concert hall and continuing to hear
            the sound reverberate throughout the hall). Some
            <a><code>AudioNode</code></a>s have this property. Please see
            details for specific nodes.
            </li>
            <li>
              <code>MediaStream</code>s keep a
              <a>MediaStreamAudioSourceNode</a> alive as long as the underlying
              <code>MediaStreamTrack</code> that is playing through the
              <a>MediaStreamAudioSourceNode</a> has not <a href=
              "https://w3c.github.io/mediacapture-main/#track-ended">ended</a>
              (as per [[!mediacapture-streams]]).
            </li>
            <li>
              <code>HTMLMediaElement</code>s keep their associated
              <a>MediaElementAudioSourceNode</a> alive as long as the
              <code>HTMLMediaElement</code> is in a state where audio could
              ever be played in the future.
              <div class="note">
                <p>
                  An <code>HTMLMediaElement</code> that has its
                  <code>src</code> attribute set to <code>""</code>, and all
                  its references dropped allows the
                  <a>MediaElementAudioSourceNode</a> to be released as well
                  (granted nothing keeps the <a>MediaElementAudioSourceNode</a>
                  alive).
                </p>
              </div>
            </li>
          </ol>
          <p>
            Any <a><code>AudioNode</code></a>s which are connected in a cycle
            <em>and</em> are directly or indirectly connected to a
            <a><code>AudioDestinationNode</code></a> or
            <a>MediaStreamAudioDestinationNode</a> within the
            <a><code>AudioContext</code></a> will stay alive as long as the
            <a><code>AudioContext</code></a> is alive.
          </p>
          <p class="note">
            The uninterrupted operation of <a>AudioNode</a>s implies that as
            long as live references exist to a node, the node will continue
            processing its inputs and evolving its internal state even if it is
            disconnected from the audio graph. Since this processing will
            consume CPU and power, developers should carefully consider the
            resource usage of disconnected nodes. In particular, it is a good
            idea to minimize resource consumption by explicitly putting
            disconnected nodes into a stopped state when possible.
          </p>
          <p>
            When an <a><code>AudioNode</code></a> has no references it will be
            deleted. Before it is deleted, it will disconnect itself from any
            other <a><code>AudioNode</code></a>s which it is connected to. In
            this way it releases all connection references (3) it has to other
            nodes.
          </p>
          <p>
            Regardless of any of the above references, it can be assumed that
            the <a><code>AudioNode</code></a> will be deleted when its
            <a><code>AudioContext</code></a> is deleted.
          </p>
        </section>
      </section>
      <section>
        <h2 id="AudioDestinationNode">
          The <dfn>AudioDestinationNode</dfn> Interface
        </h2>
        <p>
          This is an <a><code>AudioNode</code></a> representing the final audio
          destination and is what the user will ultimately hear. It can often
          be considered as an audio output device which is connected to
          speakers. All rendered audio to be heard will be routed to this node,
          a "terminal" node in the <a><code>AudioContext</code></a>'s routing
          graph. There is only a single AudioDestinationNode per
          <a><code>AudioContext</code></a>, provided through the
          <code>destination</code> attribute of
          <a><code>AudioContext</code></a>.
        </p>
        <p>
          The output of a <a><code>AudioDestinationNode</code></a> is produced
          by <a href="#SummingJunction">summing its input</a>, allowing to
          capture the output of an <a><code>AudioContext</code></a> into, for
          example, a <a><code>MediaStreamAudioDestinationNode</code></a>, or a
          <code>MediaRecorder</code> (described in [[mediastream-recording]]).
        </p>
        <pre>
      numberOfInputs  : 1
      numberOfOutputs : 1

</pre>
        <p>
          The <a>AudioDestinationNode</a> can be either the destination of an
          <a>AudioContext</a> or <a>OfflineAudioContext</a>, and the channel
          properties depend on what the context is.
        </p>
        <p>
          For an <a>AudioContext</a>, the defaults are
        </p>
        <pre>
      channelCount = 2
      channelCountMode = "explicit"
      channelInterpretation = "speakers"
</pre>
        <p>
          The <a data-link-for="AudioNode">channelCount</a> can be set to any
          value less than or equal to <a data-link-for=
          "AudioDestinationNode">maxChannelCount</a>. <span class=
          "synchronous">An <code>IndexSizeError</code> exception MUST be thrown
          if this value is not within the valid range.</span> Giving a concrete
          example, if the audio hardware supports 8-channel output, then we may
          set <a data-link-for="AudioNode">channelCount</a> to 8, and render 8
          channels of output.
        </p>
        <p>
          For an <a>OfflineAudioContext</a>, the defaults are
        </p>
        <pre>
      channelCount = numberOfChannels
      channelCountMode = "explicit"
      channelInterpretation = "speakers"
</pre>
        <p>
          where <code>numberOfChannels</code> is the number of channels
          specified when constructing the <a>OfflineAudioContext</a>. This
          value may not be changed; <span class="synchronous">a
          <code>NotSupportedError</code> exception MUST be thrown if
          <a data-link-for="AudioNode">channelCount</a> is changed to a
          different value</span>.
        </p>
        <pre class="idl">
[Exposed=Window]
interface AudioDestinationNode : AudioNode {
    readonly        attribute unsigned long maxChannelCount;
};
        </pre>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="AudioDestinationNode"
          data-link-for="AudioDestinationNode">
            <dt>
              <code><dfn>maxChannelCount</dfn></code> of type <span class=
              "idlAttrType"><code>unsigned long</code></span>, readonly
            </dt>
            <dd>
              The maximum number of channels that the <a data-link-for=
              "AudioNode"><code>channelCount</code></a> attribute can be set
              to. An <a><code>AudioDestinationNode</code></a> representing the
              audio hardware end-point (the normal case) can potentially output
              more than 2 channels of audio if the audio hardware is
              multi-channel. <code>maxChannelCount</code> is the maximum number
              of channels that this hardware is capable of supporting.
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h2 id="AudioParam">
          The <dfn>AudioParam</dfn> Interface
        </h2>
        <p>
          <a><code>AudioParam</code></a> controls an individual aspect of an
          <a><code>AudioNode</code></a>'s functioning, such as volume. The
          parameter can be set immediately to a particular value using the
          <code>value</code> attribute. Or, value changes can be scheduled to
          happen at very precise times (in the coordinate system of
          <a><code>AudioContext</code></a>'s <a data-link-for=
          "BaseAudioContext">currentTime</a> attribute), for envelopes, volume
          fades, LFOs, filter sweeps, grain windows, etc. In this way,
          arbitrary timeline-based automation curves can be set on any
          <a><code>AudioParam</code></a>. Additionally, audio signals from the
          outputs of <a><code>AudioNode</code></a>s can be connected to an
          <a><code>AudioParam</code></a>, summing with the <em>intrinsic</em>
          parameter value.
        </p>
        <p>
          Some synthesis and processing <a><code>AudioNode</code></a>s have
          <code>AudioParams</code> as attributes whose values MUST be taken
          into account on a per-audio-sample basis. For other
          <code>AudioParams</code>, sample-accuracy is not important and the
          value changes can be sampled more coarsely. Each individual
          <code>AudioParam</code> will specify that it is either an
          <a>a-rate</a> parameter which means that its values MUST be taken
          into account on a per-audio-sample basis, or it is a <a>k-rate</a>
          parameter.
        </p>
        <p>
          Implementations MUST use block processing, with each
          <a><code>AudioNode</code></a> processing one <a>render quantum</a>.
        </p>
        <p>
          For each <a>render quantum</a>, the value of a <dfn id=
          "k-rate">k-rate</dfn> parameter MUST be sampled at the time of the
          very first sample-frame, and that value MUST be used for the entire
          block. <dfn id="a-rate">a-rate</dfn> parameters MUST be sampled for
          each sample-frame of the block.
        </p>
        <p>
          Each <code>AudioParam</code> includes <a data-link-for=
          "AudioParam"><code>minValue</code></a> and <a data-link-for=
          "AudioParam"><code>maxValue</code></a> attributes that together form
          the <dfn>simple nominal range</dfn> for the parameter. In effect,
          value of the parameter is clamped to the range \([\mathrm{minValue},
          \mathrm{maxValue}]\). See the section <a href=
          "#computation-of-value">Computation of Value</a> for full details.
        </p>
        <p>
          For many <a>AudioParam</a>s the <a data-link-for=
          "AudioParam">minValue</a> and <a data-link-for=
          "AudioParam">maxValue</a> is intended to be set to the maximum
          possible range. In this case, <a data-link-for=
          "AudioParam">maxValue</a> should be set to the
          <dfn>most-positive-single-float</dfn> value, which is 3.4028235e38.
          (However, in Javascript which only supports IEEE-754 double precision
          float values, this must be written as 3.4028234663852886e38.)
          Similarly, <a data-link-for="AudioParam">minValue</a> should be set
          to the <dfn>most-negative-single-float</dfn> value, which is the
          negative of the <a>most-positive-single-float</a>: -3.4028235e38.
          (Similarly, this must be written in Javascript as
          -3.4028234663852886e38)
        </p>
        <p>
          An <code>AudioParam</code> maintains a list of zero or more <dfn id=
          "dfn-automation-event">automation events</dfn>. Each automation event
          specifies changes to the parameter's value over a specific time
          range, in relation to its <dfn>automation event time</dfn> in the
          time coordinate system of the <a><code>AudioContext</code></a>'s
          <a data-link-for="BaseAudioContext">currentTime</a> attribute. The
          list of automation events is maintained in ascending order of
          automation event time.
        </p>
        <p>
          The behavior of a given automation event is a function of the
          <a>AudioContext</a>'s current time, as well as the automation event
          times of this event and of adjacent events in the list. The following
          <dfn id="dfn-automation-method">automation methods</dfn> change the
          event list by adding a new event to the event list, of a type
          specific to the method:
        </p>
        <ul>
          <li>
            <a data-link-for="AudioParam">setValueAtTime()</a> -
            <em>SetValue</em>
          </li>
          <li>
            <a data-link-for="AudioParam">linearRampToValueAtTime()</a> -
            <em>LinearRampToValue</em>
          </li>
          <li>
            <a data-link-for="AudioParam">exponentialRampToValueAtTime()</a> -
            <em>ExponentialRampToValue</em>
          </li>
          <li>
            <a data-link-for="AudioParam">setTargetAtTime()</a> -
            <em>SetTarget</em>
          </li>
          <li>
            <a data-link-for="AudioParam">setValueCurveAtTime()</a> -
            <em>SetValueCurve</em>
          </li>
        </ul>
        <p>
          The following rules will apply when calling these methods:
        </p>
        <ul>
          <li>
            <a href="#dfn-automation-event-time">Automation event times</a> are
            not quantized with respect to the prevailing sample rate. Formulas
            for determining curves and ramps are applied to the exact numerical
            times given when scheduling events.
          </li>
          <li>If one of these events is added at a time where there is already
          one or more events, then it will be placed in the list after them,
          but before events whose times are after the event.
          </li>
          <li>
            <span class="synchronous">If <a data-link-for=
            "AudioParam">setValueCurveAtTime()</a> is called for time \(T\) and
            duration \(D\) and there are any events having a time greater than
            \(T\), but less than \(T + D\), then a
            <code>NotSupportedError</code> exception MUST be thrown.</span> In
            other words, it's not ok to schedule a value curve during a time
            period containing other events.
          </li>
          <li>
            <span class="synchronous">Similarly a
            <code>NotSupportedError</code> exception MUST be thrown if any
            <a href="#dfn-automation-method">automation method</a> is called at
            a time which is inside of the time interval of a
            <em>SetValueCurve</em> event at time \(T\) and duration
            \(D\).</span>
          </li>
        </ul>
        <p class="note">
          <code>AudioParam</code> attributes are read only, with the exception
          of the <a data-link-for="AudioParam">value</a> attribute.
        </p>
        <p>
          Each <a>AudioParam</a> has an internal slot <var>[[current
          value]]</var>, initially set to the <a>AudioParam</a>'s
          <a data-link-for="AudioParam">defaultValue</a>.
        </p>
        <pre class="idl">
[Exposed=Window]
interface AudioParam {
                    attribute float value;
    readonly        attribute float defaultValue;
    readonly        attribute float minValue;
    readonly        attribute float maxValue;
    AudioParam setValueAtTime (float value, double startTime);
    AudioParam linearRampToValueAtTime (float value, double endTime);
    AudioParam exponentialRampToValueAtTime (float value, double endTime);
    AudioParam setTargetAtTime (float target, double startTime, float timeConstant);
    AudioParam setValueCurveAtTime (sequence&lt;float&gt; values, double startTime, double duration);
    AudioParam cancelScheduledValues (double cancelTime);
    AudioParam cancelAndHoldAtTime (double cancelTime);
};
        </pre>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="AudioParam" data-link-for=
          "AudioParam">
            <dt>
              <code><dfn>defaultValue</dfn></code> of type <span class=
              "idlAttrType"><code>float</code></span>, readonly
            </dt>
            <dd>
              Initial value for the <code>value</code> attribute.
            </dd>
            <dt>
              <code><dfn>maxValue</dfn></code> of type <span class=
              "idlAttrType"><code>float</code></span>, readonly
            </dt>
            <dd>
              The nominal maximum value that the parameter can take. Together
              with <code>minValue</code>, this forms the <a>nominal range</a>
              for this parameter.
            </dd>
            <dt>
              <code><dfn>minValue</dfn></code> of type <span class=
              "idlAttrType"><code>float</code></span>, readonly
            </dt>
            <dd>
              The nominal minimum value that the parameter can take. Together
              with <code>maxValue</code>, this forms the <a>nominal range</a>
              for this parameter.
            </dd>
            <dt>
              <code><dfn>value</dfn></code> of type <span class=
              "idlAttrType"><code>float</code></span>
            </dt>
            <dd>
              <p>
                The parameter's floating-point value. This attribute is
                initialized to the <code>defaultValue</code>.
              </p>
              <p>
                Getting this attribute returns the contents of the
                <var>[[current value]]</var> slot, which maintains the value of
                this parameter at the conclusion of the most recent render
                quantum on the audio rendering thread, or the most recently
                assigned value if no rendering has taken place.
              </p>
              <p>
                Setting this attribute has the effect of assigning the
                requested value to the <var>[[current value]]</var> slot, and
                calling the <a data-link-for="AudioParam">setValueAtTime()</a>
                method with the current <code>AudioContext</code>'s
                <code>currentTime</code> and <var>[[current value]]</var>. Any
                exceptions that would be thrown by
                <code>setValueAtTime()</code> will also be thrown by setting
                this attribute.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Methods
          </h3>
          <dl class="methods" data-dfn-for="AudioParam" data-link-for=
          "AudioParam">
            <dt>
              <dfn>cancelAndHoldAtTime</dfn>
            </dt>
            <dd>
              <p>
                This is similar to <a data-link-for=
                "AudioParam">cancelScheduledValues</a> in that it cancels all
                scheduled parameter changes with times greater than or equal to
                <code>cancelTime</code>. However, in addition, the automation
                value that would have happened at <code>cancelTime</code> is
                then proprogated for all future time until other automation
                events are introduced.
              </p>
              <p>
                The behavior of the timeline in the face of
                <code>cancelAndHoldAtTime</code> when automations are running
                and can be introduced at any time after calling
                <code>cancelAndHoldAtTime</code> and before
                <code>cancelTime</code> is reached is quite complicated. The
                behavior of <code>cancelAndHoldAtTime</code> is therefore
                specified in the following algorithm.
              </p>
              <p>
                Let \(t_c\) be the value of <code>cancelTime</code>. Then
              </p>
              <ol>
                <li>Let \(E_1\) be the event (if any) at time \(t_1\) where
                \(t_1\) is the largest number satisfying \(t_1 \le t_c\).
                </li>
                <li>Let \(E_2\) be the event (if any) at time \(t_2\) where
                \(t_2\) is the smallest number satisfying \(t_c \lt t_2\).
                </li>
                <li>If \(E_2\) exists:
                  <ol type="I">
                    <li>If \(E_2\) is a linear or exponential ramp,
                      <ol type="a">
                        <li>Effectively rewrite \(E_2\) to be the same kind of
                        ramp ending at time \(t_c\) with an end value that
                        would be the value of the original ramp at time
                        \(t_c\).<img alt=
                        "Graphical representation of calling cancelAndHoldAtTime when linearRampToValueAtTime has been called at this time."
                          src="images/cancel-linear.svg" style=
                          "height:75%;width:75%">
                        </li>
                        <li>Go to step 5.
                        </li>
                      </ol>
                    </li>
                    <li>Otherwise, go to step 4.
                    </li>
                  </ol>
                </li>
                <li>If \(E_1\) exists:
                  <ol type="I">
                    <li>If \(E_1\) is a <code>setTarget</code> event,
                      <ol type="a">
                        <li>Implicitly insert a <code>setValueAtTime</code>
                        event at time \(t_c\) with the value that the
                        <code>setTarget</code> would have at time
                        \(t_c\).<img alt=
                        "Graphical representation of calling cancelAndHoldAtTime when setTargetAtTime has been called at this time"
                          src="images/cancel-setTarget.svg" style=
                          "height:75%;width:75%">
                        </li>
                        <li>Go to step 5.
                        </li>
                      </ol>
                    </li>
                    <li>If \(E_1\) is a <code>setValueCurve</code> with a start
                    time of \(t_3\) and a duration of \(d\)
                      <ol type="a">
                        <li>If \(t_c \gt t_3 + d\), go to step 5.
                        </li>
                        <li>Otherwise,
                          <ol type="i">
                            <li>Effectively replace this event with a
                            <code>setValueCurve</code> event with a start time
                            of \(t_3\) and a new duration of \(t_c-t_3\).
                            However, this is not a true replacement; this
                            automation MUST take care to produce the same
                            output as the original, and not one computed using
                            a different duration. (That would cause sampling of
                            the value curve in a slightly different way,
                            producing different results.)<img alt=
                            "Graphical representation of calling cancelAndHoldAtTime when setValueCurve has been called at this time"
                              src="images/cancel-setValueCurve.svg" style=
                              "height:75%;width:75%">
                            </li>
                            <li>Go to step 5.
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li>Remove all events with time greater than \(t_c\).
                </li>
              </ol>
              <p>
                If no events are added, then the automation value after
                <code>cancelAndHoldAtTime</code> is the the constant value that
                the original timeline would have had at time \(t_c\).
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    cancelTime
                  </td>
                  <td class="prmType">
                    <code>double</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The time after which any previously scheduled parameter
                    changes will be cancelled. It is a time in the same time
                    coordinate system as the <a><code>AudioContext</code></a>'s
                    <a data-link-for="BaseAudioContext">currentTime</a>
                    attribute. <span class="synchronous">A RangeError exception
                    MUST be thrown if <code>cancelTime</code> is negative or is
                    not a finite number.</span> If <var>cancelTime</var> is
                    less than <a data-link-for=
                    "BaseAudioContext">currentTime</a>, it is clamped to
                    <a data-link-for="BaseAudioContext">currentTime</a>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a><code>AudioParam</code></a>
              </div>
            </dd>
            <dt>
              <dfn>cancelScheduledValues</dfn>
            </dt>
            <dd>
              Cancels all scheduled parameter changes with times greater than
              or equal to <code>cancelTime</code>. Cancelling a scheduled
              parameter change means removing the scheduled event from the
              event list. Any active automations whose <a href=
              "#dfn-automation-event-time">automation event time</a> is less
              than <code>cancelTime</code> are also cancelled, and such
              cancellations may cause discontinuities because the original
              value (from before such automation) is restored immediately. Any
              hold values scheduled by <code><a>cancelAndHoldAtTime</a></code>
              are also removed if the hold time occurs after
              <code>cancelTime</code>.
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    cancelTime
                  </td>
                  <td class="prmType">
                    <code>double</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The time after which any previously scheduled parameter
                    changes will be cancelled. It is a time in the same time
                    coordinate system as the <a><code>AudioContext</code></a>'s
                    <a data-link-for="BaseAudioContext">currentTime</a>
                    attribute. <span class="synchronous">A RangeError exception
                    MUST be thrown if <code>cancelTime</code> is negative or is
                    not a finite number.</span> If <var>cancelTime</var> is
                    less than <a data-link-for=
                    "BaseAudioContext">currentTime</a>, it is clamped to
                    <a data-link-for="BaseAudioContext">currentTime</a>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a><code>AudioParam</code></a>
              </div>
            </dd>
            <dt>
              <dfn>exponentialRampToValueAtTime</dfn>
            </dt>
            <dd>
              <p>
                Schedules an exponential continuous change in parameter value
                from the previous scheduled parameter value to the given value.
                Parameters representing filter frequencies and playback rate
                are best changed exponentially because of the way humans
                perceive sound.
              </p>
              <p>
                The value during the time interval \(T_0 \leq t &lt; T_1\)
                (where \(T_0\) is the time of the previous event and \(T_1\) is
                the <code>endTime</code> parameter passed into this method)
                will be calculated as:
              </p>
              <pre class="nohighlight">
              $$
                v(t) = V_0 \left(\frac{V_1}{V_0}\right)^\frac{t - T_0}{T_1 - T_0}
              $$
</pre>
              <p>
                where \(V_0\) is the value at the time \(T_0\) and \(V_1\) is
                the <code>value</code> parameter passed into this method. If
                \(V_0\) and \(V_1\) have opposite signs or if \(V_0\) is zero,
                then \(v(t) = V_0\) for \(T_0 \le t \lt T_1\).
              </p>
              <p>
                This also implies an exponential ramp to 0 is not possible. A
                good approximation can be achieved using <a data-link-for=
                "AudioParam">setTargetAtTime</a> with an appropriately chosen
                time constant.
              </p>
              <p>
                If there are no more events after this ExponentialRampToValue
                event then for \(t \geq T_1\), \(v(t) = V_1\).
              </p>
              <p>
                If there is no event preceding this event, the exponential ramp
                behaves as if <code>setValueAtTime(value, currentTime)</code>
                were called where <code>value</code> is the current value of
                the attribute and <code>currentTime</code> is the context
                <a data-link-for="AudioContext">currentTime</a> at the time
                <code>exponentialRampToValueAtTime</code> is called.
              </p>
              <p>
                If the preceding event is a <em>SetTarget</em> event, \(T_0\)
                and \(V_0\) are chosen from the current time and value of
                <em>SetTarget</em> automation. That is, if the
                <em>SetTarget</em> event has not started, \(T_0\) is the start
                time of the event, and \(V_0\) is the value just before the
                <em>SetTarget</em> event starts. In this case, the
                <em>ExponentialRampToValue</em> event effectively replaces the
                <em>SetTarget</em> event. If the <em>SetTarget</em> event has
                already started, \(T_0\) is the current context time, and
                \(V_0\) is the current <em>SetTarget</em> automation value at
                time \(T_0\). In both cases, the automation curve is
                continuous.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    value
                  </td>
                  <td class="prmType">
                    <code>float</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The value the parameter will exponentially ramp to at the
                    given time. <span class="synchronous">A
                    <code>RangeError</code> exception MUST be thrown if this
                    value is equal to 0.</span>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    endTime
                  </td>
                  <td class="prmType">
                    <code>double</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The time in the same time coordinate system as the
                    <a><code>AudioContext</code></a>'s <a data-link-for=
                    "BaseAudioContext">currentTime</a> attribute where the
                    exponential ramp ends. <span class="synchronous">A
                    RangeError exception MUST be thrown if <code>endTime</code>
                    is negative or is not a finite number.</span> If
                    <var>endTime</var> is less than <a data-link-for=
                    "BaseAudioContext">currentTime</a>, it is clamped to
                    <a data-link-for="BaseAudioContext">currentTime</a>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a><code>AudioParam</code></a>
              </div>
            </dd>
            <dt>
              <dfn>linearRampToValueAtTime</dfn>
            </dt>
            <dd>
              <p>
                Schedules a linear continuous change in parameter value from
                the previous scheduled parameter value to the given value.
              </p>
              <p>
                The value during the time interval \(T_0 \leq t &lt; T_1\)
                (where \(T_0\) is the time of the previous event and \(T_1\) is
                the <code>endTime</code> parameter passed into this method)
                will be calculated as:
              </p>
              <pre class="nohighlight">
              $$
                v(t) = V_0 + (V_1 - V_0) \frac{t - T_0}{T_1 - T_0}
              $$
</pre>
              <p>
                Where \(V_0\) is the value at the time \(T_0\) and \(V_1\) is
                the <code>value</code> parameter passed into this method.
              </p>
              <p>
                If there are no more events after this LinearRampToValue event
                then for \(t \geq T_1\), \(v(t) = V_1\).
              </p>
              <p>
                If there is no event preceding this event, the linear ramp
                behaves as if <code>setValueAtTime(value, currentTime)</code>
                were called where <code>value</code> is the current value of
                the attribute and <code>currentTime</code> is the context
                <a data-link-for="AudioContext">currentTime</a> at the time
                <code>linearRampToValueAtTime</code> is called.
              </p>
              <p>
                If the preceding event is a <em>SetTarget</em> event, \(T_0\)
                and \(V_0\) are chosen from the current time and value of
                <em>SetTarget</em> automation. That is, if the
                <em>SetTarget</em> event has not started, \(T_0\) is the start
                time of the event, and \(V_0\) is the value just before the
                <em>SetTarget</em> event starts. In this case, the
                <em>LinearRampToValue</em> event effectively replaces the
                <em>SetTarget</em> event. If the <em>SetTarget</em> event has
                already started, \(T_0\) is the current context time, and
                \(V_0\) is the current <em>SetTarget</em> automation value at
                time \(T_0\). In both cases, the automation curve is
                continuous.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    value
                  </td>
                  <td class="prmType">
                    <code>float</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The value the parameter will linearly ramp to at the given
                    time.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    endTime
                  </td>
                  <td class="prmType">
                    <code>double</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The time in the same time coordinate system as the
                    <a><code>AudioContext</code></a>'s <a data-link-for=
                    "BaseAudioContext">currentTime</a> attribute at which the
                    automation ends. <span class="synchronous">A RangeError
                    exception MUST be thrown if <code>endTime</code> is
                    negative or is not a finite number.</span> If
                    <var>endTime</var> is less than <a data-link-for=
                    "BaseAudioContext">currentTime</a>, it is clamped to
                    <a data-link-for="BaseAudioContext">currentTime</a>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a><code>AudioParam</code></a>
              </div>
            </dd>
            <dt>
              <dfn>setTargetAtTime</dfn>
            </dt>
            <dd>
              <p>
                Start exponentially approaching the target value at the given
                time with a rate having the given time constant. Among other
                uses, this is useful for implementing the "decay" and "release"
                portions of an ADSR envelope. Please note that the parameter
                value does not immediately change to the target value at the
                given time, but instead gradually changes to the target value.
              </p>
              <p>
                During the time interval: \(T_0 \leq t\), where \(T_0\) is the
                <code>startTime</code> parameter:
              </p>
              <pre class="nohighlight">
              $$
                v(t) = V_1 + (V_0 - V_1)\, e^{-\left(\frac{t - T_0}{\tau}\right)}
              $$

</pre>
              <p>
                where \(V_0\) is the initial value (the <code>.value</code>
                attribute) at \(T_0\) (the <code>startTime</code> parameter),
                \(V_1\) is equal to the <code>target</code> parameter, and
                \(\tau\) is the <code>timeConstant</code> parameter.
              </p>
              <p>
                If a <em>LinearRampToValue</em> or
                <em>ExponentialRampToValue</em> event follows this event, the
                behavior is described in <code><a data-link-for=
                "AudioParam">linearRampToValueAtTime</a></code> or
                <code><a data-link-for=
                "AudioParam">exponentialRampToValueAtTime</a></code>,
                respectively. For all other events, the <em>SetTarget</em>
                event ends at the time of the next event.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    target
                  </td>
                  <td class="prmType">
                    <code>float</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The value the parameter will <em>start</em> changing to at
                    the given time.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    startTime
                  </td>
                  <td class="prmType">
                    <code>double</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The time at which the exponential approach will begin, in
                    the same time coordinate system as the
                    <a><code>AudioContext</code></a>'s <a data-link-for=
                    "BaseAudioContext">currentTime</a> attribute. <span class=
                    "synchronous">A RangeError exception MUST be thrown if
                    <code>start</code> is negative or is not a finite
                    number.</span> If <var>startTime</var> is less than
                    <a data-link-for="BaseAudioContext">currentTime</a>, it is
                    clamped to <a data-link-for=
                    "BaseAudioContext">currentTime</a>.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    timeConstant
                  </td>
                  <td class="prmType">
                    <code>float</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    <p>
                      The time-constant value of first-order filter
                      (exponential) approach to the target value. The larger
                      this value is, the slower the transition will be.
                      <span class="synchronous">The value MUST be non-negative
                      or a RangeError exception MUST be thrown.</span> If
                      <code>timeConstant</code> is zero, the output value jumps
                      immediately to the final value.
                    </p>
                    <p>
                      More precisely, <em>timeConstant</em> is the time it
                      takes a first-order linear continuous time-invariant
                      system to reach the value \(1 - 1/e\) (around 63.2%)
                      given a step input response (transition from 0 to 1
                      value).
                    </p>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a><code>AudioParam</code></a>
              </div>
            </dd>
            <dt>
              <dfn>setValueAtTime</dfn>
            </dt>
            <dd>
              <p>
                Schedules a parameter value change at the given time.
              </p>
              <p>
                If there are no more events after this <em>SetValue</em> event,
                then for \(t \geq T_0\), \(v(t) = V\), where \(T_0\) is the
                <code>startTime</code> parameter and \(V\) is the
                <code>value</code> parameter. In other words, the value will
                remain constant.
              </p>
              <p>
                If the next event (having time \(T_1\)) after this
                <em>SetValue</em> event is not of type
                <em>LinearRampToValue</em> or <em>ExponentialRampToValue</em>,
                then, for \(T_0 \leq t &lt; T_1\):
              </p>
              <pre class="nohighlight">
              $$
                v(t) = V
              $$

</pre>
              <p>
                In other words, the value will remain constant during this time
                interval, allowing the creation of "step" functions.
              </p>
              <p>
                If the next event after this <em>SetValue</em> event is of type
                <em>LinearRampToValue</em> or <em>ExponentialRampToValue</em>
                then please see <code><a data-link-for=
                "AudioParam">linearRampToValueAtTime</a></code> or
                <code><a data-link-for=
                "AudioParam">exponentialRampToValueAtTime</a></code>,
                respectively.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    value
                  </td>
                  <td class="prmType">
                    <code>float</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The value the parameter will change to at the given time.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    startTime
                  </td>
                  <td class="prmType">
                    <code>double</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The time in the same time coordinate system as the
                    <a><code>BaseAudioContext</code></a>'s <a data-link-for=
                    "AudioContext">currentTime</a> attribute at which the
                    parameter changes to the given value. <span class=
                    "synchronous">A RangeError exception MUST be thrown if
                    <code>startTime</code> is negative or is not a finite
                    number.</span> If <var>startTime</var> is less than
                    <a data-link-for="BaseAudioContext">currentTime</a>, it is
                    clamped to <a data-link-for=
                    "BaseAudioContext">currentTime</a>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a><code>AudioParam</code></a>
              </div>
            </dd>
            <dt>
              <dfn>setValueCurveAtTime</dfn>
            </dt>
            <dd>
              <p>
                Sets an array of arbitrary parameter values starting at the
                given time for the given duration. The number of values will be
                scaled to fit into the desired duration.
              </p>
              <p>
                Let \(T_0\) be <code>startTime</code>, \(T_D\) be
                <code>duration</code>, \(V\) be the <code>values</code> array,
                and \(N\) be the length of the <code>values</code> array. Then,
                during the time interval: \(T_0 \le t &lt; T_0 + T_D\), let
              </p>
              <pre class="nohighlight">
              $$
                \begin{align*} k &amp;= \left\lfloor \frac{N - 1}{T_D}(t-T_0) \right\rfloor \\
                \end{align*}
              $$

</pre>
              <p>
                Then \(v(t)\) is computed by linearly interpolating between
                \(V[k]\) and \(V[k+1]\),
              </p>
              <p>
                After the end of the curve time interval (\(t \ge T_0 + T_D\)),
                the value will remain constant at the final curve value, until
                there is another automation event (if any).
              </p>
              <p>
                An implicit call to <code><a data-link-for=
                "AudioParam">setValueAtTime</a></code> is made at time \(T_0 +
                T_D\) with value \(V[N-1]\) so that following automations will
                start from the end of the <code><a data-link-for=
                "AudioParam">setValueCurveAtTime</a></code> event.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    values
                  </td>
                  <td class="prmType">
                    <code>sequence&lt;float&gt;</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    A sequence of float values representing a parameter value
                    curve. These values will apply starting at the given time
                    and lasting for the given duration. When this method is
                    called, an internal copy of the curve is created for
                    automation purposes. Subsequent modifications of the
                    contents of the passed-in array therefore have no effect on
                    the <a>AudioParam</a>.
                    <p>
                      <span class="synchronous">An
                      <code>InvalidStateError</code> MUST be thrown if this
                      attribute is a <code>sequence&lt;float&gt;</code> object
                      that has a length less than 2.</span>
                    </p>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    startTime
                  </td>
                  <td class="prmType">
                    <code>double</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The start time in the same time coordinate system as the
                    <a><code>AudioContext</code></a>'s <a data-link-for=
                    "BaseAudioContext">currentTime</a> attribute at which the
                    value curve will be applied. <span class="synchronous">A
                    RangeError exception MUST be thrown if
                    <code>startTime</code> is negative or is not a finite
                    number.</span>. If <var>startTime</var> is less than
                    <a data-link-for="BaseAudioContext">currentTime</a>, it is
                    clamped to <a data-link-for=
                    "BaseAudioContext">currentTime</a>.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    duration
                  </td>
                  <td class="prmType">
                    <code>double</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The amount of time in seconds (after the <em>time</em>
                    parameter) where values will be calculated according to the
                    <em>values</em> parameter. <span class="synchronous">A
                    <code>RangeError</code> exception MUST be thrown if
                    <code>duration</code> is not strictly positive or is not a
                    finite number</span>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a><code>AudioParam</code></a>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Computation of Value
          </h3>
          <p>
            There are two different kind of <a>AudioParam</a>s, <a>simple
            parameters</a> and <a>compound parameters</a>. <dfn data-lt=
            "simple parameter">Simple parameters</dfn> (the default) are used
            on their own to compute the final audio output of an
            <a>AudioNode</a>. <dfn data-lt="compound parameter">Compound
            parameters</dfn> are <a>AudioParam</a>s that are used with other
            <a>AudioParam</a>s to compute a value that is then used as an input
            to compute the output of an <a>AudioNode</a>.
          </p>
          <p>
            The <dfn>computedValue</dfn> is the final value controlling the
            audio DSP and is computed by the audio rendering thread during each
            rendering time quantum. It MUST be internally computed as follows:
          </p>
          <ol>
            <li>An <em>intrinsic</em> parameter value will be calculated at
            each time, which is either the value set directly to the
            <code>value</code> attribute, or, if there are any <a href=
            "#dfn-automation-event">automation events</a> with times before or
            at this time, the value as calculated from these events. When read,
            the <code>value</code> attribute always returns the
            <em>intrinsic</em> value for the current time. If automation events
            are removed from a given time range, then the <em>intrinsic</em>
            value will remain unchanged and stay at its previous value until
            either the <code>value</code> attribute is directly set, or
            automation events are added for the time range.
            </li>
            <li>The <em>computedValue</em> is the sum of the <em>intrinsic</em>
            value and the value of the <a href="#input-audioparam-buffer">input
            <code>AudioParam</code> buffer</a>. When read, the
            <code>value</code> attribute always returns the
            <em>computedValue</em> for the current time.
            </li>
            <li>If this <a>AudioParam</a> is a <a>compound parameter</a>,
            compute its final value with other <a>AudioParam</a>s.
            </li>
          </ol>
          <p>
            The <dfn>nominal range</dfn> for a <a>computedValue</a> are the
            lower and higher values this parameter can effectively have. For
            <a>simple parameters</a>, the <a>computedValue</a> is clamped to
            the <a>simple nominal range</a> for this parameter. <a>Compound
            parameters</a> have their final value clamped to their <a>nominal
            range</a> after having been computed from the different
            <a>AudioParam</a> values they are composed of.
          </p>
          <p>
            When automation methods are used, clamping is still applied.
            However, the automation is run as if there were no clamping at all.
            Only when the automation values are to be applied to the output is
            the clamping done as specified above.
          </p>
          <p>
            For example, consider a node \(N\) has an AudioParam \(p\) with a
            nominal range of \([0, 1]\), and following automation sequence
          </p>
          <pre class="example">
            N.p.setValueAtTime(0, 0);
            N.p.linearRampToValueAtTime(4, 1);
            N.p.linearRampToValueAtTime(0, 2)
</pre>
          <p>
            The initial slope of the curve is 4, until it reaches the maximum
            value of 1, at which time, the output is held constant. Finally,
            near time 2, the slope of the curve is -4. This is illustrated in
            the graph below where the dashed line indicates what would have
            happened without clipping, and the solid line indicates the actual
            expected behavior of the audioparam due to clipping to the nominal
            range.
          </p>
          <figure>
            <!-- The image here was created from
  http://googlechrome.github.io/web-audio-samples/samples/audio/timeline-limits.html -->
            <img alt="AudioParam automation clipping to nominal" src=
            "images/audioparam-automation-clipping.png">
            <figcaption>
              An example of clipping of an AudioParam automation from the
              nominal range.
            </figcaption>
          </figure>
        </section>
        <section>
          <h3 id="example1-AudioParam">
            AudioParam Automation Example
          </h3>
          <figure>
            <!-- The image here was created from
  http://googlechrome.github.io/web-audio-samples/samples/audio/timeline.html -->
            <img alt="AudioParam automation" src=
            "images/audioparam-automation1.png" width="917" height="541">
            <figcaption>
              An example of parameter automation.
            </figcaption>
          </figure>
          <pre class="code example">
var curveLength = 44100;
var curve = new Float32Array(curveLength);
for (var i = 0; i &lt; curveLength; ++i)
    curve[i] = Math.sin(Math.PI * i / curveLength);

var t0 = 0;
var t1 = 0.1;
var t2 = 0.2;
var t3 = 0.3;
var t4 = 0.325;
var t5 = 0.5;
var t6 = 0.6;
var t7 = 0.7;
var t8 = 1.0;
var timeConstant = 0.1;

param.setValueAtTime(0.2, t0);
param.setValueAtTime(0.3, t1);
param.setValueAtTime(0.4, t2);
param.linearRampToValueAtTime(1, t3);
param.linearRampToValueAtTime(0.8, t4);
param.setTargetAtTime(.5, t4, timeConstant);
// Compute where the setTargetAtTime will be at time t5 so we can make
// the following exponential start at the right point so there's no
// jump discontinuity.  From the spec, we have
//   v(t) = 0.5 + (0.8 - 0.5)*exp(-(t-t4)/timeConstant)
// Thus v(t5) = 0.5 + (0.8 - 0.5)*exp(-(t5-t4)/timeConstant)
param.setValueAtTime(0.5 + (0.8 - 0.5)*Math.exp(-(t5 - t4)/timeConstant), t5);
param.exponentialRampToValueAtTime(0.75, t6);
param.exponentialRampToValueAtTime(0.05, t7);
param.setValueCurveAtTime(curve, t7, t8 - t7);
</pre>
        </section>
      </section>
      <section>
        <h2 id="AudioScheduledSourceNode">
          The <dfn>AudioScheduledSourceNode</dfn> Interface
        </h2>
        <p>
          The interface represents the common features of the source nodes such
          as <a>AudioBufferSourceNode</a>, <a>ConstantSourceNode</a>, and
          <a>OscillatorNode</a>.
        </p>
        <p>
          Before a source is started (by calling <a data-link-for=
          "AudioScheduledSourceNode"><code>start</code></a>, the source node
          MUST output silence (0). After a source has been stopped (by calling
          <a data-link-for="AudioScheduledSourceNode"><code>stop</code></a>),
          the source MUST then output silence (0).
        </p>
        <p>
          <a>AudioScheduledSourceNode</a> cannot be instantiated directly, but
          is instead extended by the concrete interfaces for the source nodes.
        </p>
        <pre class="idl">
[Exposed=Window]
interface AudioScheduledSourceNode : AudioNode {
                    attribute EventHandler onended;
    void start (optional double when = 0);
    void stop (optional double when = 0);
};
        </pre>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="AudioScheduledSourceNode"
          data-link-for="AudioScheduledSourceNode">
            <dt>
              <code><dfn>onended</dfn></code> of type <span class=
              "idlAttrType"><code>EventHandler</code></span>
            </dt>
            <dd>
              <p>
                A property used to set the <code>EventHandler</code> (described
                in <cite><a href=
                "https://html.spec.whatwg.org/multipage/webappapis.html#eventhandler">
                HTML</a></cite>[[!HTML]]) for the ended event that is
                dispatched to <a><code>AudioScheduledSourceNode</code></a> node
                types. When the source node has stopped playing (as determined
                by the concrete node), an event of type <code>Event</code>
                (described in <cite><a href=
                "https://html.spec.whatwg.org/multipage/infrastructure.html#event">
                HTML</a></cite> [[!HTML]]) will be dispatched to the event
                handler.
              </p>
              <p>
                For all <a><code>AudioScheduledSourceNode</code></a>s, the
                <code>onended</code> event is dispatched when the stop time
                determined by <a data-link-for=
                "AudioScheduledSourceNode"><code>stop()</code></a> is reached.
                For an <a><code>AudioBufferSourceNode</code></a>, the event is
                also dispatched because the <a data-link-for=
                "AudioBufferSourceNode"><code>duration</code></a> has been
                reached or if the entire <a data-link-for=
                "AudioBufferSourceNode"><code>buffer</code></a> has been
                played.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Methods
          </h3>
          <dl class="methods" data-dfn-for="AudioScheduledSourceNode"
          data-link-for="AudioScheduledSourceNode">
            <dt>
              <dfn>start</dfn>
            </dt>
            <dd>
              <p>
                Schedules a sound to playback at an exact time.
              </p>
              <p>
                <span class="synchronous">When this method is called, execute
                these steps:</span>
              </p>
              <ol>
                <li>If <code>stop</code> has been called on this node, or if an
                earlier call to <code>start</code> has already occurred, an
                <code>InvalidStateError</code> exception MUST be thrown.
                </li>
                <li>Check for any errors that must be thrown due to parameter
                constraints described below.
                </li>
                <li>
                  <a href="#queue">Queue a control message</a> to start the
                  <a>AudioScheduledSourceNode</a>, including the parameter
                  values in the messsage.
                </li>
              </ol>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    when
                  </td>
                  <td class="prmType">
                    <code>double = 0</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    The <a><code>when</code></a> parameter describes at what
                    time (in seconds) the sound should start playing. It is in
                    the same time coordinate system as the
                    <a><code>AudioContext</code></a>'s <a data-link-for=
                    "BaseAudioContext">currentTime</a> attribute. When the
                    signal emitted by the <a>AudioScheduledSourceNode</a>
                    depends on the sound's start time, the exact value of
                    <code>when</code> is always used without rounding to the
                    nearest sample frame. If 0 is passed in for this value or
                    if the value is less than <b>currentTime</b>, then the
                    sound will start playing immediately. <span class=
                    "synchronous">A RangeError exception MUST be thrown if
                    <code>when</code> is negative.</span>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a><code>void</code></a>
              </div>
            </dd>
            <dt>
              <dfn>stop</dfn>
            </dt>
            <dd>
              <p>
                Schedules a sound to stop playback at an exact time. If
                <code>stop</code> is called again after already having been
                called, the last invocation will be the only one applied; stop
                times set by previous calls will not be applied, unless the
                buffer has already stopped prior to any subsequent calls. If
                the buffer has already stopped, further calls to
                <code>stop</code> will have no effect. If a stop time is
                reached prior to the scheduled start time, the sound will not
                play.
              </p>
              <p>
                <span class="synchronous">When this method is called, execute
                these steps:</span>
              </p>
              <ol>
                <li>If an earlier call to <code>start</code> has not already
                occurred, an <code>InvalidStateError</code> exception MUST be
                thrown.
                </li>
                <li>Check for any errors that must be thrown due to parameter
                constraints described below.
                </li>
                <li>
                  <a href="#queue">Queue a control message</a> to stop the
                  <a>AudioScheduledSourceNode</a>, including the parameter
                  values in the messsage.
                </li>
              </ol>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    when
                  </td>
                  <td class="prmType">
                    <code>double = 0</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    The <a><code>when</code></a> parameter describes at what
                    time (in seconds) the source should stop playing. It is in
                    the same time coordinate system as the
                    <a><code>AudioContext</code></a>'s <a data-link-for=
                    "BaseAudioContext">currentTime</a> attribute. If 0 is
                    passed in for this value or if the value is less than
                    <a data-link-for=
                    "BaseAudioContext"><code>currentTime</code></a>, then the
                    sound will stop playing immediately. <span class=
                    "synchronous">A RangeError exception MUST be thrown if
                    <code>when</code> is negative</span>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a><code>void</code></a>
              </div>
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h2 id="GainNode">
          The GainNode Interface
        </h2>
        <p>
          Changing the gain of an audio signal is a fundamental operation in
          audio applications. The <code>GainNode</code> is one of the building
          blocks for creating <a href="#mixer-gain-structure">mixers</a>. This
          interface is an <a><code>AudioNode</code></a> with a single input and
          single output:
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                2
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">max</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <p>
          Each sample of each channel of the input data of the
          <a><code>GainNode</code></a> MUST be multiplied by the
          <a>computedValue</a> of the <a data-link-for=
          "GainNode"><code>gain</code></a> <a><code>AudioParam</code></a>.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional GainOptions options)]
interface GainNode : AudioNode {
    readonly        attribute AudioParam gain;
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="GainNode" data-link-for="GainNode">
            <dt>
              <code><dfn>GainNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>gain</var> be a new <a>GainNode</a> object. <a href=
                "#audionode-constructor-init">Initialize</a> <var>gain</var>,
                and return <var>gain</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new <a>GainNode</a> will
                    be <a href="#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>GainOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter values for this <a>GainNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="GainNode" data-link-for=
          "GainNode">
            <dt>
              <code><dfn>gain</dfn></code> of type <span class=
              "idlAttrType"><code>AudioParam</code></span>, readonly
            </dt>
            <dd>
              <p>
                Represents the amount of gain to apply.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>a-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>GainOptions</dfn>
          </h2>
          <p>
            This specifies options to use in constructing a
            <a><code>GainNode</code></a>. All members are optional; if not
            specified, the normal defaults are used in constructing the node.
          </p>
          <pre class="idl">
dictionary GainOptions : AudioNodeOptions {
             float gain = 1.0;
};
          </pre>
          <section>
            <h3>
              Dictionary <a>GainOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="GainOptions" data-link-for=
            "GainOptions">
              <dt>
                <code><dfn>gain</dfn></code> of type <span class=
                "idlAttrType"><a>float</a></span>, defaulting to 1.0
              </dt>
              <dd>
                The initial gain value for the <a data-link-for=
                "GainNode"><code>gain</code></a> AudioParam.
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2 id="DelayNode">
          The DelayNode Interface
        </h2>
        <p>
          A delay-line is a fundamental building block in audio applications.
          This interface is an <a><code>AudioNode</code></a> with a single
          input and single output.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                2
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">max</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                Yes
              </td>
              <td>
                Continues to output non-silent audio with zero input up to the
                <a>maxDelayTime</a> of the node.
              </td>
            </tr>
          </table>
        </div>
        <p>
          The number of channels of the output always equals the number of
          channels of the input.
        </p>
        <p>
          It delays the incoming audio signal by a certain amount.
          Specifically, at each time <em>t</em>, input signal
          <em>input(t)</em>, delay time <em>delayTime(t)</em> and output signal
          <em>output(t)</em>, the output will be <em>output(t) = input(t -
          delayTime(t))</em>. The default <code>delayTime</code> is 0 seconds
          (no delay).
        </p>
        <p>
          When the number of channels in a <a>DelayNode</a>'s input changes
          (thus changing the output channel count also), there may be delayed
          audio samples which have not yet been output by the node and are part
          of its internal state. If these samples were received earlier with a
          different channel count, they MUST be upmixed or downmixed before
          being combined with newly received input so that all internal
          delay-line mixing takes place using the single prevailing channel
          layout.
        </p>
        <p class="note">
          By definition, a <a>DelayNode</a> introduces an audio processing
          latency equal to the amount of the delay.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional DelayOptions options)]
interface DelayNode : AudioNode {
    readonly        attribute AudioParam delayTime;
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="DelayNode" data-link-for=
          "DelayNode">
            <dt>
              <code><dfn>DelayNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>DelayNode</a> object. <a href=
                "#audionode-constructor-init">Initialize</a> <var>node</var>,
                and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new <a>DelayNode</a> will
                    be <a href="#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>DelayOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this <a>DelayNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="DelayNode" data-link-for=
          "DelayNode">
            <dt>
              <code><dfn>delayTime</dfn></code> of type <span class=
              "idlAttrType"><code>AudioParam</code></span>, readonly
            </dt>
            <dd>
              <p>
                An <a><code>AudioParam</code></a> object representing the
                amount of delay (in seconds) to apply. Its default
                <code>value</code> is 0 (no delay). The minimum value is 0 and
                the maximum value is determined by the
                <code>maxDelayTime</code> argument to the
                <code>AudioContext</code> method <code>createDelay</code>.
              </p>
              <p>
                If <a><code>DelayNode</code></a> is part of a <a>cycle</a>,
                then the value of the <a><code>delayTime</code></a> attribute
                is clamped to a minimum of one <a>render quantum</a>.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a data-link-for="AudioNode">maxDelayTime</a>
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>a-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>DelayOptions</dfn>
          </h2>
          <p>
            This specifies options for constructing a
            <a><code>DelayNode</code></a>. All members are optional; if not
            given, the node is constructed using the normal defaults.
          </p>
          <pre class="idl">
dictionary DelayOptions : AudioNodeOptions {
             double maxDelayTime = 1;
             double delayTime = 0;
};
          </pre>
          <section>
            <h3>
              Dictionary <a>DelayOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="DelayOptions" data-link-for=
            "DelayOptions">
              <dt>
                <code><dfn>delayTime</dfn></code> of type <span class=
                "idlAttrType"><a>double</a></span>, defaulting to 0
              </dt>
              <dd>
                The maximum delay time for the node.
              </dd>
              <dt>
                <code><dfn>maxDelayTime</dfn></code> of type <span class=
                "idlAttrType"><a>double</a></span>, defaulting to 1
              </dt>
              <dd>
                The initial delay time for the node.
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2 id="AudioBuffer">
          The AudioBuffer Interface
        </h2>
        <p>
          This interface represents a memory-resident audio asset (for one-shot
          sounds and other short audio clips). Its format is non-interleaved
          32-bit linear floating-point PCM values with a normal range of \([-1,
          1]\), but values are not limited to this range. It can contain one or
          more channels. Typically, it would be expected that the length of the
          PCM data would be fairly short (usually somewhat less than a minute).
          For longer sounds, such as music soundtracks, streaming should be
          used with the <code>audio</code> element and
          <code>MediaElementAudioSourceNode</code>.
        </p>
        <p>
          An <a>AudioBuffer</a> may be used by one or more
          <a><code>AudioContext</code></a>s, and can be shared between an
          <a><code>OfflineAudioContext</code></a> and an
          <a><code>AudioContext</code></a>.
        </p>
        <p>
          <a>AudioBuffer</a> has four internal slots:
        </p>
        <dl>
          <dt>
            <var>[[number of channels]]</var>
          </dt>
          <dd>
            The number of audio channels for this <a>AudioBuffer</a>, which is
            an unsigned long.
          </dd>
          <dt>
            <var>[[\length]]</var>
          </dt>
          <dd>
            The length of each channel of this <a>AudioBuffer</a>, which is an
            unsigned long.
          </dd>
          <dt>
            [[sample rate]]
          </dt>
          <dd>
            The sample-rate, in Hz, of this <a>AudioBuffer</a>, a float
          </dd>
          <dt>
            [[internal data]]
          </dt>
          <dd>
            A <a href="https://tc39.github.io/ecma262/#sec-data-blocks">data
            block</a> holding the audio sample data.
          </dd>
        </dl>
        <pre class="idl">
[Exposed=Window,
 Constructor (AudioBufferOptions options)]
interface AudioBuffer {
    readonly        attribute float         sampleRate;
    readonly        attribute unsigned long length;
    readonly        attribute double        duration;
    readonly        attribute unsigned long numberOfChannels;
    Float32Array getChannelData (unsigned long channel);
    void         copyFromChannel (Float32Array destination, unsigned long channelNumber, optional unsigned long startInChannel = 0);
    void         copyToChannel (Float32Array source, unsigned long channelNumber, optional unsigned long startInChannel = 0);
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="AudioBuffer" data-link-for=
          "AudioBuffer">
            <dt>
              <code><dfn>AudioBuffer</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>b</var> be a new <a>AudioBuffer</a> object.
                Respectively assign the values of the attributes
                <var>numberOfChannels</var>, <var>length</var>,
                <var>sampleRate</var> of the <a>AudioBufferOptions</a> passed
                in the constructor to the internal slots <var>[[number of
                channels]]</var>, <var>[[\length]]</var>, <var>[[sample
                rate]]</var>.
              </p>
              <p>
                Set the internal slot <var>[[internal data]]</var> of this
                <a>AudioBuffer</a> to the result of calling <a href=
                "https://tc39.github.io/ecma262/#sec-createbytedatablock"><code>
                CreateByteDataBlock([[\length]] * [[number of
                channels]])</code></a>.
              </p>
              <p class="note">
                This initializes the underlying storage to zero.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>AudioBufferOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="AudioBuffer" data-link-for=
          "AudioBuffer">
            <dt>
              <code><dfn>duration</dfn></code> of type <span class=
              "idlAttrType"><code>double</code></span>, readonly
            </dt>
            <dd>
              <p>
                Duration of the PCM audio data in seconds.
              </p>
              <p>
                This is computed from the <var>[[sample rate]]</var> and the
                <var>[[\length]]</var> of the <a>AudioBuffer</a> by performing
                a division between the <var>[[\length]]</var> and the
                <var>[[sample rate]]</var>.
              </p>
            </dd>
            <dt>
              <code><dfn>length</dfn></code> of type <span class=
              "idlAttrType"><code>unsigned long</code></span>, readonly
            </dt>
            <dd>
              Length of the PCM audio data in sample-frames. This MUST return
              the value of <var>[[\length]]</var>.
            </dd>
            <dt>
              <code><dfn>numberOfChannels</dfn></code> of type <span class=
              "idlAttrType"><code>unsigned long</code></span>, readonly
            </dt>
            <dd>
              The number of discrete audio channels. This MUST return the value
              of <var>[[number of channels]]</var>.
            </dd>
            <dt>
              <code><dfn>sampleRate</dfn></code> of type <span class=
              "idlAttrType"><code>float</code></span>, readonly
            </dt>
            <dd>
              The sample-rate for the PCM audio data in samples per second.
              This MUST return the value of <var>[[sample rate]]</var>.
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Methods
          </h3>
          <dl class="methods" data-dfn-for="AudioBuffer" data-link-for=
          "AudioBuffer">
            <dt>
              <code><dfn>copyFromChannel</dfn></code>
            </dt>
            <dd>
              <p>
                The <code>copyFromChannel</code> method copies the samples from
                the specified channel of the <a>AudioBuffer</a> to the
                <code>destination</code> array.
              </p>
              <p>
                Let <code>buffer</code> be the <a>AudioBuffer</a> buffer with
                \(N_b\) frames, let \(N_f\) be the number of elements in the
                <code>destination</code> array, and \(k\) be the value of
                <code>startInChannel</code>. Then the number of frames copied
                from <code>buffer</code> to <code>destination</code> is
                \(\min(N_b - k, N_f)\). If this is less than \(N_f\), then the
                remaining elements of <code>destination</code> are not
                modified.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    destination
                  </td>
                  <td class="prmType">
                    <a><code>Float32Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The array the channel data will be copied to.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    channelNumber
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The index of the channel to copy the data from. If
                    <code>channelNumber</code> is greater or equal than the
                    number of channel of the <a>AudioBuffer</a>, <span class=
                    "synchronous">an <code>IndexSizeError</code> MUST be
                    thrown</span>.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    startInChannel
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long = 0</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    An optional offset to copy the data from. If
                    <code>startInChannel</code> is greater than the
                    <code>length</code> of the <a>AudioBuffer</a>, <span class=
                    "synchronous">an <code>IndexSizeError</code> MUST be
                    thrown</span>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              <code><dfn>copyToChannel</dfn></code>
            </dt>
            <dd>
              <p>
                The <code>copyFromChannel</code> method copies the samples from
                the specified channel of the <a>AudioBuffer</a> to the
                <code>destination</code> array.
              </p>
              <p>
                Let <code>buffer</code> be the <a>AudioBuffer</a> buffer with
                \(N_b\) frames, let \(N_f\) be the number of elements in the
                <code>destination</code> array, and \(k\) be the value of
                <code>startInChannel</code>. Then the number of frames copied
                from <code>buffer</code> to <code>destination</code> is
                \(\min(N_b - k, N_f)\). If this is less than \(N_f\), then the
                remaining elements of <code>destination</code> are not
                modified.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    source
                  </td>
                  <td class="prmType">
                    <a><code>Float32Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The array the channel data will be copied from.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    channelNumber
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The index of the channel to copy the data to. If
                    <code>channelNumber</code> is greater or equal than the
                    number of channel of the <a>AudioBuffer</a>, <span class=
                    "synchronous">an <code>IndexSizeError</code> MUST be
                    thrown</span>.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    startInChannel
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long = 0</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    An optional offset to copy the data to. If
                    <code>startInChannel</code> is greater than the
                    <code>length</code> of the <a>AudioBuffer</a>, <span class=
                    "synchronous">an <code>IndexSizeError</code> MUST be
                    thrown</span>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              <code><dfn>getChannelData</dfn></code>
            </dt>
            <dd>
              <p>
                According to the rules described in <a href=
                "#acquire-the-content">acquire the content</a> either <a href=
                "https://heycam.github.io/webidl/#dfn-get-buffer-source-reference">
                get a reference to</a> or <a href=
                "https://heycam.github.io/webidl/#dfn-get-buffer-source-copy">get
                a copy of</a> the bytes stored in [[internal data]] in a new
                <code>Float32Array</code>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    channel
                  </td>
                  <td class="prmType">
                    <a><code>unsigned long</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    This parameter is an index representing the particular
                    channel to get data for. An index value of 0 represents the
                    first channel. <span class="synchronous">This index value
                    MUST be less than <code>numberOfChannels</code> or an
                    <code>IndexSizeError</code> exception MUST be
                    thrown.</span>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>Float32Array</code>
              </div>
            </dd>
          </dl>
        </section>
        <p class="note">
          The methods <code>copyToChannel</code> and
          <code>copyFromChannel</code> can be used to fill part of an array by
          passing in a <code>Float32Array</code> that's a view onto the larger
          array. When reading data from an <a>AudioBuffer</a>'s channels, and
          the data can be processed in chunks, <code>copyFromChannel</code>
          should be preferred to calling <code>getChannelData</code> and
          accessing the resulting array, because it may avoid unnecessary
          memory allocation and copying.
        </p>
        <p>
          An internal operation <a href="#acquire-the-content">acquire the
          contents of an <code>AudioBuffer</code></a> is invoked when the
          contents of an <a>AudioBuffer</a> are needed by some API
          implementation. This operation returns immutable channel data to the
          invoker.
        </p>
        <p>
          When an <dfn id="acquire-the-content">acquire the content</dfn>
          operation occurs on an <a>AudioBuffer</a>, run the following steps:
        </p>
        <ol>
          <li>If the operation <a href=
          "https://tc39.github.io/ecma262/#sec-isdetachedbuffer"><code>IsDetachedBuffer</code></a>
          on any of the <a>AudioBuffer</a>'s <code>ArrayBuffer</code>s return
          <code>true</code>, abort these steps, and return a zero-length
          channel data buffer to the invoker.
          </li>
          <li>
            <a href=
            "https://tc39.github.io/ecma262/#sec-detacharraybuffer">Detach</a>
            all <code>ArrayBuffer</code>s for arrays previously returned by
            <code>getChannelData</code> on this <a>AudioBuffer</a>.
          </li>
          <li>Retain the underlying <var>[[internal data]]</var> from those
          <code>ArrayBuffer</code>s and return references to them to the
          invoker.
          </li>
          <li>Attach <code>ArrayBuffer</code>s containing copies of the data to
          the <a>AudioBuffer</a>, to be returned by the next call to
          <code>getChannelData</code>.
          </li>
        </ol>The <a href="#acquire-the-content">acquire the contents of an
        AudioBuffer</a> operation is invoked in the following cases:
        <ul>
          <li>When <code>AudioBufferSourceNode.start</code> is called, it
          <a href="#acquire-the-content">acquires the contents</a> of the
          node's <code>buffer</code>. If the operation fails, nothing is
          played.
          </li>
          <li>When the <code>buffer</code> of an <a>AudioBufferSourceNode</a>
          is set and <code>AudioBufferSourceNode.start</code> has been
          previously called, the setter <a href="#acquire-the-content">acquires
          the content</a> of the <a>AudioBuffer</a>. If the operation fails,
          nothing is played.
          </li>
          <li>When a <a>ConvolverNode</a>'s <code>buffer</code> is set to an
          <a>AudioBuffer</a> while the node is connected to an output node, or
          a <a>ConvolverNode</a> is connected to an output node while the
          <a>ConvolverNode</a>'s <code>buffer</code> is set to an
          <a>AudioBuffer</a>, it <a href="#acquire-the-content">acquires the
          content</a> of the <a>AudioBuffer</a>.
          </li>
          <li>When the dispatch of an <a>AudioProcessingEvent</a> completes, it
          <a href="#acquire-the-content">acquires the contents</a> of its
          <code>outputBuffer</code>.
          </li>
        </ul>
        <p class="note">
          This means that <code>copyToChannel</code> cannot be used to change
          the content of an <a>AudioBuffer</a> currently in use by an
          <code>AudioNode</code> that has <a href=
          "#acquire-the-content">acquired the content of an AudioBuffer</a>,
          since the <a>AudioNode</a> will continue to use the data previously
          acquired.
        </p>
        <section>
          <h2>
            <dfn>AudioBufferOptions</dfn>
          </h2>
          <p>
            This specifies the options to use in constructing an
            <a><code>AudioBuffer</code></a>. The <a data-link-for=
            "AudioBufferOptions"><code>length</code></a> and <a data-link-for=
            "AudioBufferOptions"><code>sampleRate</code></a> members are
            required. A <code>NotFoundError</code> exception MUST be thrown if
            any of the required members are not specified.
          </p>
          <pre class="idl">
dictionary AudioBufferOptions {
             unsigned long numberOfChannels = 1;
    required unsigned long length;
    required float         sampleRate;
};
          </pre>
          <section>
            <h3>
              Dictionary <a>AudioBufferOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="AudioBufferOptions"
            data-link-for="AudioBufferOptions">
              <dt>
                <code><dfn>length</dfn></code> of type <span class=
                "idlAttrType"><code>unsigned long</code></span>, required
              </dt>
              <dd>
                The length in sample frames of the buffer.
              </dd>
              <dt>
                <code><dfn>numberOfChannels</dfn></code> of type <span class=
                "idlAttrType"><code>unsigned long</code></span>, defaulting to
                1
              </dt>
              <dd>
                The number of channels for the buffer.
              </dd>
              <dt>
                <code><dfn>sampleRate</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, required
              </dt>
              <dd>
                The sample rate in Hz for the buffer.
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2 id="AudioBufferSourceNode">
          The AudioBufferSourceNode Interface
        </h2>
        <p>
          This interface represents an audio source from an in-memory audio
          asset in an <code>AudioBuffer</code>. It is useful for playing audio
          assets which require a high degree of scheduling flexibility and
          accuracy. If sample-accurate playback of network- or disk-backed
          assets is required, an implementer should use
          <a><code>AudioWorkletNode</code></a> to implement playback.
        </p>
        <p>
          The <a data-link-for=
          "AudioScheduledSourceNode"><code>start()</code></a> method is used to
          schedule when sound playback will happen. The <a data-link-for=
          "AudioScheduledSourceNode"><code>start()</code></a> method may not be
          issued multiple times. The playback will stop automatically when the
          buffer's audio data has been completely played (if the
          <a data-link-for="AudioBufferSourceNode"><code>loop</code></a>
          attribute is <code>false</code>), or when the <a data-link-for=
          "AudioScheduledSourceNode"><code>stop()</code></a> method has been
          called and the specified time has been reached. Please see more
          details in the <a data-link-for=
          "AudioScheduledSourceNode"><code>start()</code></a> and
          <a data-link-for="AudioScheduledSourceNode"><code>stop()</code></a>
          description.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                0
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <p>
          The number of channels of the output always equals the number of
          channels of the AudioBuffer assigned to the <a data-link-for=
          "AudioBufferSourceNode"><code>buffer</code></a> attribute, or is one
          channel of silence if <a data-link-for=
          "AudioBufferSourceNode"><code>buffer</code></a> is <code>null</code>.
        </p>
        <p>
          A <dfn>playhead position</dfn> for an <a>AudioBufferSourceNode</a> is
          defined as any quantity representing a time offset in seconds,
          relative to the time coordinate of the first sample frame in the
          buffer. Such values are to be considered independently from the
          node's <code>playbackRate</code> and <code>detune</code> parameters.
          In general, playhead positions may be subsample-accurate and need not
          refer to exact sample frame positions. They may assume valid values
          between 0 and the duration of the buffer.
        </p>
        <p>
          <a>AudioBufferSourceNode</a>s are created with an internal boolean
          slot <code>[[buffer set]]</code>, initially set to false.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional AudioBufferSourceOptions options)]
interface AudioBufferSourceNode : AudioScheduledSourceNode {
                    attribute AudioBuffer? buffer;
    readonly        attribute AudioParam   playbackRate;
    readonly        attribute AudioParam   detune;
                    attribute boolean      loop;
                    attribute double       loopStart;
                    attribute double       loopEnd;
    void start (optional double when = 0
              , optional double offset, optional double duration);
    void stop (optional double when = 0
              );
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="AudioBufferSourceNode"
          data-link-for="AudioBufferSourceNode">
            <dt>
              <code><dfn>AudioBufferSourceNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>AudioBufferSourceNode</a>
                object. <a href="#audionode-constructor-init">Initialize</a>
                <var>node</var>, and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new
                    <a>AudioBufferSourceNode</a> will be <a href=
                    "#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>AudioBufferSourceOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>AudioBufferSourceNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="AudioBufferSourceNode"
          data-link-for="AudioBufferSourceNode">
            <dt>
              <code><dfn>buffer</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioBuffer</code></a></span>, nullable
            </dt>
            <dd>
              <p>
                Represents the audio asset to be played. To set the
                <code>buffer</code> attribute, execute these steps:
              </p>
              <ol>
                <li>Let <code>new buffer</code> be the <a>AudioBuffer</a> or
                <code>null</code> value to be assigned to <code>buffer</code>.
                </li>
                <li>If <code>new buffer</code> is not <code>null</code> and
                <var>[[buffer set]]</var> is true, throw an
                <code>InvalidStateError</code> and abort these steps.
                </li>
                <li>If <code>new buffer</code> is not <code>null</code>, set
                <var>[[buffer set]]</var> to true.
                </li>
                <li>Assign <code>new buffer</code> to the <code>buffer</code>
                attribute.
                </li>
                <li>If <code>start()</code> has previously been called on this
                node, perform the operation <a href=
                "#acquire-the-content">acquire the content</a> on
                <code>buffer</code>.
                </li>
              </ol>
            </dd>
            <dt>
              <code><dfn>detune</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                An additional parameter, in cents, to modulate the speed at
                which is rendered the audio stream. This parameter is a
                <a>compound parameter</a> with <code>playbackRate</code>.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>k-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>loop</dfn></code> of type <span class=
              "idlAttrType"><code>boolean</code></span>
            </dt>
            <dd>
              Indicates if the region of audio data designated by
              <a>loopStart</a> and <a>loopEnd</a> should be played continuously
              in a loop. The default value is <code>false</code>.
            </dd>
            <dt>
              <code><dfn>loopEnd</dfn></code> of type <span class=
              "idlAttrType"><code>double</code></span>
            </dt>
            <dd>
              An optional <a>playhead position</a> where looping should end if
              the <a>loop</a> attribute is true. Its value is exclusive of the
              content of the loop. Its default <code>value</code> is 0, and it
              may usefully be set to any value between 0 and the duration of
              the buffer. If <a>loopEnd</a> is less than or equal to 0, or if
              <a>loopEnd</a> is greater than the duration of the buffer,
              looping will end at the end of the buffer.
            </dd>
            <dt>
              <code><dfn>loopStart</dfn></code> of type <span class=
              "idlAttrType"><code>double</code></span>
            </dt>
            <dd>
              An optional <a>playhead position</a> where looping should begin
              if the <a>loop</a> attribute is true. Its default
              <code>value</code> is 0, and it may usefully be set to any value
              between 0 and the duration of the buffer. If <a>loopStart</a> is
              less than 0, looping will begin at 0. If <a>loopStart</a> is
              greater than the duration of the buffer, looping will begin at
              the end of the buffer.
            </dd>
            <dt>
              <code><dfn>playbackRate</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                The speed at which to render the audio stream. This is a
                <a>compound parameter</a> with <code>detune</code>.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>k-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Methods
          </h3>
          <dl class="methods" data-dfn-for="AudioBufferSourceNode"
          data-link-for="AudioBufferSourceNode">
            <dt>
              <code><dfn>start</dfn></code>
            </dt>
            <dd>
              <p>
                Schedules a sound to playback at an exact time.
              </p>
              <p>
                <span class="synchronous">When this method is called, execute
                these steps:</span>
              </p>
              <ol>
                <li>If <code>stop</code> has been called on this node, or if an
                earlier call to <code>start</code> has already occurred, an
                <code>InvalidStateError</code> exception MUST be thrown.
                </li>
                <li>Check for any errors that must be thrown due to parameter
                constraints described below.
                </li>
                <li>
                  <a href="#queue">Queue a control message</a> to start the
                  <a>AudioBufferSourceNode</a>, including the parameter values
                  in the messsage.
                </li>
              </ol>
              <p>
                Running a <a>control message</a> to start the
                <a>AudioBufferSourceNode</a> means invoking the
                <code>handleStart()</code> function in the <a href=
                "#playback-AudioBufferSourceNode">playback algorithm</a> which
                follows.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    when
                  </td>
                  <td class="prmType">
                    <a><code>double = 0</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    The <a><code>when</code></a> parameter describes at what
                    time (in seconds) the sound should start playing. It is in
                    the same time coordinate system as the
                    <a><code>AudioContext</code></a>'s <a data-link-for=
                    "BaseAudioContext">currentTime</a> attribute. If 0 is
                    passed in for this value or if the value is less than
                    <b>currentTime</b>, then the sound will start playing
                    immediately. <span class="synchronous">A RangeError
                    exception MUST be thrown if <code>when</code> is
                    negative.</span>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    offset
                  </td>
                  <td class="prmType">
                    <a><code>double</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    The <dfn id="dfn-offset">offset</dfn> parameter supplies a
                    <a>playhead position</a> where playback will begin. If 0 is
                    passed in for this value, then playback will start from the
                    beginning of the buffer. <span class="synchronous">A
                    RangeError exception MUST be thrown if <code>offset</code>
                    is negative.</span> If <code>offset</code> is greater than
                    <a>loopEnd</a>, playback will begin at <a>loopEnd</a> (and
                    immediately loop to <a>loopStart</a>). <code>offset</code>
                    is silently clamped to [0, <code>duration</code>], when
                    <code>startTime</code> is reached, where
                    <code>duration</code> is the value of the
                    <code>duration</code> attribute of the
                    <code>AudioBuffer</code> set to the <code>buffer</code>
                    attribute of this <code>AudioBufferSourceNode</code>.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    duration
                  </td>
                  <td class="prmType">
                    <a><code>double</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    The <a><code>duration</code></a> parameter describes the
                    duration of the sound (in seconds) to be played. If this
                    parameter is passed, this method has exactly the same
                    effect as the invocation of <code>start(when,
                    offset)</code> followed by <code>stop(when +
                    duration)</code>. <span class="synchronous">A RangeError
                    exception MUST be thrown if <code>duration</code> is
                    negative.</span>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a><code>void</code></a>
              </div>
            </dd>
            <dt>
              <code><dfn>stop</dfn></code>
            </dt>
            <dd>
              <p>
                Schedules a sound to stop playback at an exact time. If
                <code>stop</code> is called again after already having been
                called, the last invocation will be the only one applied; stop
                times set by previous calls will not be applied, unless the
                buffer has already stopped prior to any subsequent calls. If
                the buffer has already stopped, further calls to
                <code>stop</code> will have no effect. If a stop time is
                reached prior to the scheduled start time, the sound will not
                play.
              </p>
              <p>
                <span class="synchronous">When this method is called, execute
                these steps:</span>
              </p>
              <ol>
                <li>If an earlier call to <code>start</code> has not already
                occurred, an <code>InvalidStateError</code> exception MUST be
                thrown.
                </li>
                <li>Check for any errors that must be thrown due to parameter
                constraints described below.
                </li>
                <li>
                  <a href="#queue">Queue a control message</a> to stop the
                  <a>AudioBufferSourceNode</a>, including the parameter values
                  in the messsage.
                </li>
              </ol>
              <p>
                Running a <a>control message</a> to start the
                <a>AudioBufferSourceNode</a> means invoking the
                <code>handleStop()</code> function in the <a href=
                "#playback-AudioBufferSourceNode">playback algorithm</a> which
                follows.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    when
                  </td>
                  <td class="prmType">
                    <a><code>double = 0</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    The <a><code>when</code></a> parameter describes at what
                    time (in seconds) the source should stop playing. It is in
                    the same time coordinate system as the
                    <a><code>AudioContext</code></a>'s <a data-link-for=
                    "BaseAudioContext">currentTime</a> attribute. If 0 is
                    passed in for this value or if the value is less than
                    <a data-link-for=
                    "BaseAudioContext"><code>currentTime</code></a>, then the
                    sound will stop playing immediately. <span class=
                    "synchronous">A RangeError exception MUST be thrown if
                    <code>when</code> is negative</span>.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <a><code>void</code></a>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>AudioBufferSourceOptions</dfn>
          </h2>
          <p>
            This specifies options for constructing a
            <a><code>AudioBufferSourceNode</code></a>. All members are
            optional; if not specified, the normal default is used in
            constructing the node.
          </p>
          <pre class="idl">
dictionary AudioBufferSourceOptions {
             AudioBuffer? buffer;
             float        detune = 0;
             boolean      loop = false;
             double       loopEnd = 0;
             double       loopStart = 0;
             float        playbackRate = 1;
};
          </pre>
          <section>
            <h3>
              Dictionary <a>AudioBufferSourceOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="AudioBufferSourceOptions"
            data-link-for="AudioBufferSourceOptions">
              <dt>
                <code><dfn>buffer</dfn></code> of type <span class=
                "idlAttrType"><a><code>AudioBuffer</code></a></span>, nullable
              </dt>
              <dd>
                The audio asset to be played. This is equivalent to assigning
                <code>buffer</code> to the <a data-link-for=
                "AudioBufferSourceNode"><code>buffer</code></a> attribute of
                the <a>AudioBufferSourceNode</a>.
              </dd>
              <dt>
                <code><dfn>detune</dfn></code> of type <span class=
                "idlAttrType"><code>float</code>&gt;</span>, defaulting to 0
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "AudioBufferSourceNode"><code>detune</code></a> AudioParam.
              </dd>
              <dt>
                <code><dfn>loop</dfn></code> of type <span class=
                "idlAttrType"><code>boolean</code></span>, defaulting to false
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "AudioBufferSourceNode"><code>loop</code></a> attribute.
              </dd>
              <dt>
                <code><dfn>loopEnd</dfn></code> of type <span class=
                "idlAttrType"><code>double</code></span>, defaulting to 0
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "AudioBufferSourceNode"><code>loopEnd</code></a> attribute.
              </dd>
              <dt>
                <code><dfn>loopStart</dfn></code> of type <span class=
                "idlAttrType"><code>double</code></span>, defaulting to 0
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "AudioBufferSourceNode"><code>loopStart</code></a> attribute.
              </dd>
              <dt>
                <code><dfn>playbackRate</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 1
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "AudioBufferSourceNode"><code>playbackRate</code></a>
                AudioParam.
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h3 id="looping-AudioBufferSourceNode">
            Looping
          </h3>
          <p class="norm">
            <em>This section is non-normative. Please see <a href=
            "#playback-AudioBufferSourceNode">the playback algorithm</a> for
            normative requirements.</em>
          </p>
          <p>
            Setting the <a data-link-for="AudioBufferSourceNode">loop</a>
            attribute to true causes playback of the region of the buffer
            defined by the endpoints <a data-link-for=
            "AudioBufferSourceNode">loopStart</a> and <a data-link-for=
            "AudioBufferSourceNode">loopEnd</a> to continue indefinitely, once
            any part of the looped region has been played. While
            <a data-link-for="AudioBufferSourceNode">loop</a> remains true,
            looped playback will continue until one of the following occurs:
          </p>
          <ul>
            <li>
              <a data-link-for="AudioBufferSourceNode">stop</a><code>()</code>
              is called,
            </li>
            <li>the scheduled stop time has been reached,
            </li>
            <li>the <code>duration</code> has been exceeded, if
            <a data-link-for="AudioBufferSourceNode">start</a><code>()</code>
            was called with a <code>duration</code> value.
            </li>
          </ul>
          <p>
            The body of the loop is considered to occupy a region from
            <a data-link-for="AudioBufferSourceNode">loopStart</a> up to, but
            not including, <a data-link-for=
            "AudioBufferSourceNode">loopEnd</a>. The direction of playback of
            the looped region respects the sign of the node's playback rate.
            For positive playback rates, looping occurs from <a data-link-for=
            "AudioBufferSourceNode">loopStart</a> to <a data-link-for=
            "AudioBufferSourceNode">loopEnd</a>; for negative rates, looping
            occurs from <a data-link-for="AudioBufferSourceNode">loopEnd</a> to
            <a data-link-for="AudioBufferSourceNode">loopStart</a>.
          </p>
          <p>
            Looping does not affect the interpretation of the
            <code>offset</code> argument of <a data-link-for=
            "AudioBufferSourceNode">start</a><code>()</code>. Playback always
            starts at the requested offset, and looping only begins once the
            body of the loop is encountered during playback.
          </p>
          <p>
            The effective loop start and end points are required to lie within
            the range of zero and the buffer duration, as specified in the
            algorithm below. <a data-link-for=
            "AudioBufferSourceNode">loopEnd</a> is further constrained to be at
            or after <a data-link-for="AudioBufferSourceNode">loopStart</a>. If
            any of these constraints are violated, the loop is considered to
            include the entire buffer contents.
          </p>
          <p>
            Loop endpoints have subsample accuracy. When endpoints do not fall
            on exact sample frame offsets, or when the playback rate is not
            equal to 1, playback of the loop is interpolated to splice the
            beginning and end of the loop together just as if the looped audio
            occurred in sequential, non-looped regions of the buffer.
          </p>
          <p>
            Loop-related properties may be varied during playback of the
            buffer, and in general take effect on the next rendering quantum.
            The exact results are defined by the normative playback algorithm
            which follows.
          </p>
          <p>
            The default values of the <a data-link-for=
            "AudioBufferSourceNode">loopStart</a> and <a data-link-for=
            "AudioBufferSourceNode">loopEnd</a> attributes are both 0. Since a
            <a data-link-for="AudioBufferSourceNode">loopEnd</a> value of zero
            is equivalent to the length of the buffer, the default endpoints
            cause the entire buffer to be included in the loop.
          </p>
          <p>
            Note that the values of the loop endpoints are expressed as time
            offsets in terms of the sample rate of the buffer, meaning that
            these values are independent of the node's <a data-link-for=
            "AudioBufferSourceNode">playbackRate</a> parameter which can vary
            dynamically during the course of playback.
          </p>
        </section>
        <section>
          <h3 id="playback-AudioBufferSourceNode">
            Playback of AudioBuffer Contents
          </h3>
          <p>
            This normative section specifies the playback of the contents of
            the buffer, accounting for the fact that playback is influenced by
            the following factors working in combination, which can vary
            dynamically during playback:
          </p>
          <ul>
            <li>A starting offset, which can expressed with sub-sample
            precision.
            </li>
            <li>Loop points, which can expressed with sub-sample precision.
            </li>
            <li>Playback rate and detuning parameters, which combine to yield a
            single computed playback rate that can assume non-infinite values
            which may be positive or negative.
            </li>
          </ul>
          <p>
            The algorithm to be followed internally to generate output from an
            <a>AudioBufferSourceNode</a> conforms to the following principles:
          </p>
          <ul>
            <li>Resampling of the buffer may be performed arbitrarily by the UA
            at any desired point to increase the efficiency or quality of the
            output.
            </li>
            <li>Sub-sample start offsets or loop points may require additional
            interpolation between sample frames.
            </li>
            <li>The playback of a looped buffer should behave identically to an
            unlooped buffer containing consecutive occurrences of the looped
            audio content, excluding any effects from interpolation.
            </li>
          </ul>
          <p>
            The description of the algorithm is as follows:
          </p>
          <pre>
let buffer;  // AudioBuffer employed by this node
let context; // AudioContext employed by this node

// The following variables capture attribute and AudioParam values for the node.
// They are updated on a k-rate basis, prior to each invocation of process().
let loop;
let detune;
let loopStart;
let loopEnd;
let playbackRate;

// Variables for the node's playback parameters
let start = 0, offset = 0; // Set by start()
let stop = Infinity;  // Set by stop(), or by start() with a supplied duration

// Variables for tracking node's playback state
let bufferTime = 0, started = false, enteredLoop = false;
let dt = 1 / context.sampleRate;

// Handle invocation of start method call
function handleStart(when, pos, duration) {
  if (arguments.length &gt;= 1) {
    start = when;
  }
  offset = pos;
  if (arguments.length &gt;= 3) {
    stop = when + duration;
  }
}

// Handle invocation of stop method call
function handleStop(when) {
  if (arguments.length &gt;= 1) {
    stop = when;
  } else {
    stop = context.currentTime;
  }
}

// Interpolate a multi-channel signal value for some sample frame.
// Returns an array of signal values.
function playbackSignal(position) {
  /*
    This function provides the playback signal function for buffer, which is a
    function that maps from a playhead position to a set of output signal
    values, one for each output channel. If |position| corresponds to the
    location of an exact sample frame in the buffer, this function returns
    that frame. Otherwise, its return value is determined by a UA-supplied
    algorithm that interpolates between sample frames in the neighborhood of
    position.

    If position is greater than or equal to loopEnd and there is no subsequent
    sample frame in buffer, then interpolation should be based on the sequence
    of subsequent frames beginning at loopStart.
   */
   ...
}

// Generate a single render quantum of audio to be placed
// in the channel arrays defined by output. Returns an array
// of |numberOfFrames| sample frames to be output.
function process(numberOfFrames) {
  let currentTime = context.currentTime; // context time of next rendered frame
  let output = [];  // accumulates rendered sample frames

  // Combine the two k-rate parameters affecting playback rate
  let computedPlaybackRate = playbackRate * Math.pow(2, detune / 1200);

  // Determine loop endpoints as applicable
  let actualLoopStart, actualLoopEnd;
  if (loop &amp;& buffer != null) {
    if (loopStart &gt;= 0 &amp;& loopEnd &gt; 0 &amp;& loopStart &lt; loopEnd) {
      actualLoopStart = loopStart;
      actualLoopEnd = Math.min(loopEnd, buffer.duration);
    } else {
      actualLoopStart = 0;
      actualLoopEnd = buffer.duration;
    }
  } else {
    // If the loop flag is false, remove any record of the loop having been entered
    enteredLoop = false;
  }

  // Handle null buffer case
  if (buffer == null) {
    stop = currentTime; // force zero output for all time
  }
}
  // Render each sample frame in the quantum
  for (let index = 0; index &lt; numberOfFrames; index++) {
    // Check that currentTime is within allowable range for playback
    if (currentTime &lt; start || currentTime &gt;= stop) {
      output.push(0); // this sample frame is silent
      currentTime += dt;
      continue;
    }

    if (!started) {
      // Take note that buffer has started playing and get initial playhead position.
      bufferTime = offset + ((currentTime - start) * computedPlaybackRate);
      started = true;
    }

    // Handle loop-related calculations
    if (loop) {
      // Determine if looped portion has been entered for the first time
      if (!enteredLoop) {
        if (offset &lt; actualLoopEnd &amp;& bufferTime &gt;= actualLoopStart) {
          // playback began before or within loop, and playhead is now past loop start
          enteredLoop = true;
        }
        if (offset &gt;= actualLoopEnd &amp;& bufferTime &lt; actualLoopEnd) {
          // playback began after loop, and playhead is now prior to the loop end
          enteredLoop = true;
        }
      }

      // Wrap loop iterations as needed. Note that enteredLoop
      // may become true inside the preceding conditional.
      if (enteredLoop) {
        while (bufferTime &gt;= actualLoopEnd) {
          bufferTime -= actualLoopEnd - actualLoopStart;
        }
        while (bufferTime &lt; actualLoopStart) {
          bufferTime += actualLoopEnd - actualLoopStart;
        }
      }
    }

    if (bufferTime &gt;= 0 &amp;& bufferTime &lt; buffer.duration) {
      output.push(playbackSignal(bufferTime));
    } else {
      output.push(0); // past end of buffer, so output silent frame
    }

    bufferTime += dt * computedPlaybackRate;
    currentTime += dt;
  } // End of render quantum loop

  if (currentTime &gt;= stop) {
    // end playback state of this node.
    // no further invocations of process() will occur.
  }

  return output;
}
</pre>
          <p>
            The following non-normative figures illustrate the behavior of the
            algorithm in assorted key scenarios. Dynamic resampling of the
            buffer is not considered, but as long as the times of loop
            positions are not changed this does not materially affect the
            resulting playback. In all figures, the following conventions
            apply:
          </p>
          <ul>
            <li>context sample rate is 1000 Hz
            </li>
            <li>
              <a>AudioBuffer</a> content is shown with the first sample frame
              at the <em>x</em> origin.
            </li>
            <li>output signals are shown with the sample frame located at time
            <code>start</code> at the <em>x</em> origin.
            </li>
            <li>linear interpolation is depicted throughout, although a UA
            could employ other interpolation techniques.
            </li>
          </ul>
          <p>
            This figure illustrates basic playback of a buffer, with a simple
            loop that ends after the last sample frame in the buffer:
          </p>
          <figure>
            <img alt="AudioBufferSourceNode basic playback" src=
            "images/absn-basic.png" width="556" height="485">
            <figcaption>
              <a>AudioBufferSourceNode</a> basic playback
            </figcaption>
          </figure>
          <p>
            This figure illustrates <code>playbackRate</code> interpolation,
            showing half-speed playback of buffer contents in which every other
            output sample frame is interpolated. Of particular note is the last
            sample frame in the looped output, which is interpolated using the
            loop start point:
          </p>
          <figure>
            <img alt="AudioBufferSourceNode playbackRate interpolation" src=
            "images/absn-slow-loop.png" width="543" height="472">
            <figcaption>
              <a>AudioBufferSourceNode</a> playbackRate interpolation
            </figcaption>
          </figure>
          <p>
            This figure illustrates sample rate interpolation, showing playback
            of a buffer whose sample rate is 50% of the context sample rate,
            resulting in a computed playback rate of 0.5 that corrects for the
            difference in sample rate between the buffer and the context. The
            resulting output is the same as the preceding example, but for
            different reasons.
          </p>
          <figure>
            <img alt="AudioBufferSourceNode sample rate interpolation" src=
            "images/absn-half-sample-rate.png" width="543" height="459">
            <figcaption>
              <a>AudioBufferSourceNode</a> sample rate interpolation.
            </figcaption>
          </figure>
          <p>
            This figure illustrates subsample offset playback, in which the
            offset within the buffer begins at exactly half a sample frame.
            Consequently, every output frame is interpolated:
          </p>
          <figure>
            <img alt="AudioBufferSourceNode subsample offset playback" src=
            "images/absn-offset.png" width="543" height="448">
            <figcaption>
              <a>AudioBufferSourceNode</a> subsample offset playback
            </figcaption>
          </figure>
          <p>
            This figure illustrates subsample loop playback, showing how
            fractional frame offsets in the loop endpoints map to interpolated
            data points in the buffer that respect these offsets as if they
            were references to exact sample frames:
          </p>
          <figure>
            <img alt="AudioBufferSourceNode subsample loop playback" src=
            "images/absn-subsample-loop.png" width="543" height="480">
            <figcaption>
              <a>AudioBufferSourceNode</a> subsample loop playback
            </figcaption>
          </figure>
        </section>
      </section>
      <section>
        <h2 id="ConstantSourceNode">
          The ConstantSourceNode Interface
        </h2>
        <p>
          This interface represents a constant audio source whose output is
          nominally a constant value. It is useful as a constant source node in
          general and can be used as if it were a constructible
          <a><code>AudioParam</code></a> by automating its
          <a><code>offset</code></a> or connecting another node to it.
        </p>
        <p>
          The single output of this node consists of one channel (mono).
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                0
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional ConstantSourceOptions options)]
interface ConstantSourceNode : AudioScheduledSourceNode {
    readonly        attribute AudioParam offset;
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="ConstantSourceNode" data-link-for=
          "ConstantSourceNode">
            <dt>
              <code><dfn>ConstantSourceNode</dfn></code>
            </dt>
            <dd>
              Let <var>node</var> be a new <a>ConstantSourceNode</a> object.
              <a href="#audionode-constructor-init">Initialize</a>
              <var>node</var>, and return <var>node</var>.
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new
                    <a>ConstantSourceNode</a> will be <a href=
                    "#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>ConstantSourceOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>ConstantSourceNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="ConstantSourceNode"
          data-link-for="ConstantSourceNode">
            <dt>
              <code><dfn>offset</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                The constant value of the source.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>a-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>ConstantSourceOptions</dfn>
          </h2>
          <p>
            This specifies options for constructing a
            <a><code>ConstantSourceNode</code></a>. All members are optional;
            if not specified, the normal defaults are used for constructing the
            node.
          </p>
          <pre class="idl">
dictionary ConstantSourceOptions {
             float offset = 1;
};
          </pre>
          <section>
            <h3>
              Dictionary <a>ConstantSourceOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="ConstantSourceOptions"
            data-link-for="ConstantSourceOptions">
              <dt>
                <code><dfn>offset</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 1
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "ConstantSourceNode"><code>offset</code></a> AudioParam of this
                node.
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2 id="MediaElementAudioSourceNode">
          The MediaElementAudioSourceNode Interface
        </h2>
        <p>
          This interface represents an audio source from an <code>audio</code>
          or <code>video</code> element.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                0
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <p>
          The number of channels of the output corresponds to the number of
          channels of the media referenced by the
          <code>HTMLMediaElement</code>. Thus, changes to the media element's
          <code>src</code> attribute can change the number of channels output
          by this node.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, MediaElementAudioSourceOptions options)]
interface MediaElementAudioSourceNode : AudioNode {
    [SameObject]
    readonly        attribute HTMLMediaElement mediaElement;
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="MediaElementAudioSourceNode"
          data-link-for="MediaElementAudioSourceNode">
            <dt>
              <code><dfn>MediaElementAudioSourceNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>MediaElementAudioSourceNode</a>
                object. <a href="#audionode-constructor-init">Initialize</a>
                <var>node</var>, and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new
                    <a>MediaElementAudioSourceNode</a> will be <a href=
                    "#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>MediaElementAudioSourceOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    Parameter value for this
                    <a>MediaElementAudioSourceNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="MediaElementAudioSourceNode"
          data-link-for="MediaElementAudioSourceNode">
            <dt>
              <code><dfn>mediaElement</dfn></code> of type <span class=
              "idlAttrType"><a><code>HTMLMediaElement</code></a></span>,
              readonly
            </dt>
            <dd>
              the <code>HTMLMediaElement</code> used when constructing this
              <a>MediaElementAudioSourceNode</a>.
            </dd>
          </dl>
        </section>
        <p>
          A <a>MediaElementAudioSourceNode</a> is created given an
          <code>HTMLMediaElement</code> using the <a>AudioContext</a>
          <code>createMediaElementSource()</code> method.
        </p>
        <p>
          The number of channels of the single output equals the number of
          channels of the audio referenced by the <code>HTMLMediaElement</code>
          passed in as the argument to <code>createMediaElementSource()</code>,
          or is 1 if the <code>HTMLMediaElement</code> has no audio.
        </p>
        <p>
          The <code>HTMLMediaElement</code> MUST behave in an identical fashion
          after the <a>MediaElementAudioSourceNode</a> has been created,
          <em>except</em> that the rendered audio will no longer be heard
          directly, but instead will be heard as a consequence of the
          <a>MediaElementAudioSourceNode</a> being connected through the
          routing graph. Thus pausing, seeking, volume, <code>src</code>
          attribute changes, and other aspects of the
          <code>HTMLMediaElement</code> MUST behave as they normally would if
          <em>not</em> used with a <a>MediaElementAudioSourceNode</a>.
        </p>
        <pre class="example">
  var mediaElement = document.getElementById('mediaElementID');
  var sourceNode = context.createMediaElementSource(mediaElement);
  sourceNode.connect(filterNode);
</pre>
        <section>
          <h2>
            <dfn>MediaElementAudioSourceOptions</dfn>
          </h2>
          <p>
            This specifies the options to use in constructing a
            <a><code>MediaElementAudioSourceNode</code></a>.
          </p>
          <pre class="idl">
dictionary MediaElementAudioSourceOptions {
    required HTMLMediaElement mediaElement;
};
          </pre>
          <section>
            <h3>
              Dictionary <a>MediaElementAudioSourceOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for=
            "MediaElementAudioSourceOptions" data-link-for=
            "MediaElementAudioSourceOptions">
              <dt>
                <code><dfn>mediaElement</dfn></code> of type <span class=
                "idlAttrType"><code>HTMLMediaElement</code></span>, required
              </dt>
              <dd>
                The media element that will be re-routed. This MUST be
                specified.
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h2>
            Security with MediaElementAudioSourceNode and cross-origin
            resources
          </h2>
          <p>
            <code>HTMLMediaElement</code> allows the playback of cross-origin
            resources. Because Web Audio allows inspection of the content of
            the resource (e.g. using a <a>MediaElementAudioSourceNode</a>, and
            a <a>ScriptProcessorNode</a> to read the samples), information
            leakage can occur if scripts from one <a href=
            "http://www.w3.org/html/wg/drafts/html/master/browsers.html#origin">
            origin</a> inspect the content of a resource from another <a href=
            "http://www.w3.org/html/wg/drafts/html/master/browsers.html#origin">
            origin</a>.
          </p>
          <p>
            To prevent this, a <a>MediaElementAudioSourceNode</a> MUST output
            <em>silence</em> instead of the normal output of the
            <code>HTMLMediaElement</code> if it has been created using an
            <code>HTMLMediaElement</code> for which the execution of the
            <a href="https://fetch.spec.whatwg.org/#fetching">fetch
            algorithm</a> labeled the resource as <a href=
            "http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#cors-cross-origin">
            CORS-cross-origin</a>.
          </p>
        </section>
      </section>
      <section>
        <h2 id="AudioWorklet">
          The <dfn>AudioWorklet</dfn> Interface
        </h2>
        <section>
          <h2 id="AudioWorklet-concepts">
            Concepts
          </h2>
          <p>
            The <a>AudioWorklet</a> object allows developers to supply scripts
            (such as JavaScript or WebAssembly code) to process audio on the
            <a>rendering thread</a>, supporting custom <a>AudioNode</a>s. This
            processing mechanism ensures the synchronous execution of the
            script code with other built-in <a>AudioNode</a>s in the audio
            graph.
          </p>
          <p>
            An associated pair of objects MUST be defined in order to realize
            this mechanism: <a>AudioWorkletNode</a> and
            <a>AudioWorkletProcessor</a>. The former represents the interface
            for the main global scope similar to other <a>AudioNode</a>
            objects, and the latter implements the internal audio processing
            within a special scope named <a>AudioWorkletGlobalScope</a>.
          </p>
          <figure>
            <img alt="AudioWorklet concept" src=
            "images/audioworklet-concept.png" width="756" height="144">
            <figcaption>
              <a><code>AudioWorkletNode</code></a> and
              <a><code>AudioWorkletProcessor</code></a>
            </figcaption>
          </figure>
          <p>
            Importing a script via the <a href=
            "https://drafts.css-houdini.org/worklets/#dom-worklet-import">import(moduleUrl)</a>
            method registers class definitions of <a>AudioWorkletProcessor</a>
            under the <a>AudioWorkletGlobalScope</a>. There are two internal
            storage areas for the imported class definitions and the active
            instances created from the definition.
          </p>
          <dl>
            <dt>
              <dfn>node name to processor definition map</dfn>
            </dt>
            <dd>
              Belongs to <a>AudioWorkletGlobalScope</a>. This map associates a
              string key to the corresponding <a>AudioWorkletProcessor</a>
              definition. Initially this map is empty and becomes populated
              when <a data-link-for=
              "AudioWorkletGlobalScope">registerProcessor</a> method is called.
            </dd>
            <dt>
              <dfn>node name to parameter descriptor map</dfn>
            </dt>
            <dd>
              Belongs to <a>BaseAudioContext</a>. This map contains an
              identical set of string keys from <a>node name to processor
              definition map</a> that are associated with the matching
              <a>parameterDescriptors</a> values. This internal storage is
              populated when a promise from <a href=
              "https://drafts.css-houdini.org/worklets/#dom-worklet-addmodule">addModule()</a>
              on <a data-link-for="Window">audioWorklet</a> gets resolved.
            </dd>
          </dl>
          <pre class="example" title=
          "Registering an AudioWorkletProcessor class definition">
// bypass.js script file, AudioWorkletGlobalScope
registerProcessor("Bypass", class extends AudioWorkletProcessor {
  process (inputs, outputs) {
    // Single input, single channel.
    var input = inputs[0], output = outputs[0];
    output[0].set(input[0]);
  }
});
</pre>
          <pre class="example" title=
          "Importing a script and creating AudioWorkletNode">
// The main global scope
window.audioWorklet.addModule("bypass.js").then(function () {
  var context = new AudioContext();
  var bypass = new AudioWorkletNode(context, "Bypass");
});
</pre>
          <p>
            At the instantiation of <a>AudioWorkletNode</a> in the main global
            scope, the counterpart <a>AudioWorkletProcessor</a> will also be
            created in <a>AudioWorkletGlobalScope</a>. These two objects
            communicate via the asynchronous message passing described in the
            <a href="#processing-model">processing model</a> section.
          </p>
        </section>
        <pre class="idl">
partial interface Window {
    [SameObject]
    readonly        attribute Worklet audioWorklet;
};
        </pre>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="Window" data-link-for="Window">
            <dt>
              <code><dfn>audioWorklet</dfn></code> of type <span class=
              "idlAttrType"><a><code>Worklet</code></a></span> readonly
            </dt>
            <dd>
              The <code>audioWorklet</code> attributes allows access to the
              <code>Worklet</code> object that can import a script containing
              <a><code>AudioWorkletProcessor</code></a> class definitions via
              the algorithm defined by [[!worklets-1]].
            </dd>
          </dl>
        </section>
        <section>
          <h2 id="AudioWorkletGlobalScope">
            The <dfn>AudioWorkletGlobalScope</dfn> Interface
          </h2>
          <p>
            This special execution context is designed to enable the
            generation, processing, and analysis of audio data directly using a
            script in the audio <a>rendering thread</a>. The user-supplied
            script code is evaluated in this scope to define one or more
            <a>AudioWorkletProcessor</a> subclasses, which in turn are used to
            instantiate <a>AudioWorkletProcessor</a>s, in a 1:1 association
            with <a>AudioWorkletNode</a>s in the main scope.
          </p>
          <p>
            At least one <a>AudioWorkletGlobalScope</a> exists for each
            <a>AudioContext</a> that contains one or more
            <a>AudioWorkletNode</a>s. The running of imported scripts is
            performed by the UA as defined in [[!worklets-1]], in such a way
            that all scripts are applied consistently to every global scope,
            and all scopes thus exhibit identical behavior. Beyond these
            guarantees, the creation of global scopes is transparent to the
            author and cannot be observed from the main window scope.
          </p>
          <p>
            <a>AudioWorkletGlobalScope</a> has a <a>node name to processor
            definition map</a>. This map stores definitions of
            <a>AudioWorkletProcessor</a> with the associated string key.
            Initially it is empty and populated when
            <code>registerProcessor</code> method is called, but this storage
            is internal and is not directly exposed to the user.
          </p>
          <div class="note">
            The <a>AudioWorkletGlobalScope</a> may also contain any other data
            and code to be shared by these instances. As an example, multiple
            processors might share an ArrayBuffer defining a wavetable or an
            impulse response.
          </div>
          <div class="note">
            Every <a>AudioWorkletGlobalScope</a> is associated with a single
            <a>BaseAudioContext</a>, and with a single audio rendering thread
            for that context. This prevents data races from occurring in global
            scope code running within concurrent threads.
          </div>
          <pre class="idl">
[Global=(Worklet, AudioWorklet), Exposed=AudioWorklet]
interface AudioWorkletGlobalScope : WorkletGlobalScope {
    void registerProcessor (DOMString name, VoidFunction processorCtor);
    readonly attribute double currentTime;
    readonly attribute float  sampleRate;
};
          </pre>
          <section>
            <h3>
              Attributes
            </h3>
            <dl class="attributes" data-dfn-for="AudioWorkletGlobalScope"
            data-link-for="AudioWorkletGlobalScope">
              <dt>
                <code><dfn>currentTime</dfn></code> of type <span class=
                "idlAttrType"><code>double</code></span>, readonly
              </dt>
              <dd>
                The context time of the block of audio being processed. By
                definition this will be equal to the value of
                <a>BaseAudioContext</a>'s <a data-link-for=
                "BaseAudioContext">currentTime</a> attribute that was most
                recently observable in the <a>control thread</a>.
              </dd>
              <dt>
                <code><dfn>sampleRate</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, readonly
              </dt>
              <dd>
                The sample rate of the associated <a>BaseAudioContext</a>.
              </dd>
            </dl>
          </section>
          <section>
            <h3>
              Methods
            </h3>
            <dl class="methods" data-dfn-for="AudioWorkletGlobalScope"
            data-link-for="AudioWorkletGlobalScope">
              <dt>
                <code><dfn>registerProcessor</dfn></code>
              </dt>
              <dd>
                <p>
                  Registers a class definition derived from
                  <a>AudioWorkletProcessor</a>.
                </p>
                <p>
                  When the <a><code>registerProcessor(<em>name</em>,
                  <em>processorConstructor</em>)</code></a> method is called,
                  the user agent MUST run the following steps:
                </p>
                <ol>
                  <li>If the <code><em>name</em></code> is the empty string,
                  <span class="synchronous">throw a
                  <code>NotSupportedError</code> exception and abort these
                  steps because the empty string is not a valid key</span>.
                  </li>
                  <li>If the <code><em>name</em></code> exists as a key in the
                  <a>node name to processor definition map</a>, <span class=
                  "synchronous">throw a <code>NotSupportedError</code>
                  exception and abort these steps</span> because registering a
                  definition with a duplicated key is not allowed.
                  </li>
                  <li>If the result of <code><a href=
                  "http://www.ecma-international.org/ecma-262/6.0/#sec-isconstructor">
                    IsConstructor</a>(argument=<em>processorConstructor</em>)</code>
                    is false, <span class="synchronous">throw a
                    <code>TypeError</code> and abort these steps</span>.
                  </li>
                  <li>Let <code><em>prototype</em></code> be the result of
                  <code><a href=
                  "http://www.ecma-international.org/ecma-262/6.0/#sec-get-o-p">
                    Get</a>(O=<em>processorConstructor</em>,
                    P="prototype")</code>.
                  </li>
                  <li>If the result of <code><a href=
                  "http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values">
                    Type</a>(argument=<em>prototype</em>)</code> is not
                    <code>Object</code>, <span class="synchronous">throw a
                    <code>TypeError</code> and abort all these steps</span>.
                  </li>
                  <li>If the result of <code><a href=
                  "http://www.ecma-international.org/ecma-262/6.0/#sec-iscallable">
                    IsCallable</a>(argument=Get(O=<em>prototype</em>,
                    P="process"))</code> is false, <span class=
                    "synchronous">throw a <code>TypeError</code> and abort
                    these steps</span>.
                  </li>
                  <li>If the result of <code><a href=
                  "http://www.ecma-international.org/ecma-262/6.0/#sec-get-o-p">
                    Get</a>(O=<em>processorConstructor</em>,
                    P="parameterDescriptors")</code> is not an array or
                    <code>undefined</code>, <span class="synchronous">throw a
                    <code>TypeError</code> and abort these steps</span>.
                  </li>
                  <li>Let <em>definition</em> be a new
                  <a>AudioWorkletProcessor</a> definition with:
                    <ul>
                      <li>node name being <em>name</em>
                      </li>
                      <li>processor class constructor being
                      <em>processorConstructor</em>
                      </li>
                    </ul>
                  </li>
                  <li>d the key-value pair (<em>name</em> -
                  <em>definition</em>) to the <a>node name to processor
                  definition map</a> of the associated
                  <a>AudioWorkletGlobalScope</a>.
                  </li>
                </ol>
                <p class="note">
                  The class constructor should only be looked up once, thus it
                  does not have the opportunity to dynamically change its
                  definition.
                </p>
                <table class="parameters">
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Type
                    </th>
                    <th>
                      Nullable
                    </th>
                    <th>
                      Optional
                    </th>
                    <th>
                      Description
                    </th>
                  </tr>
                  <tr>
                    <td class="prmName">
                      name
                    </td>
                    <td class="prmType">
                      <a><code>DOMString</code></a>
                    </td>
                    <td class="prmNullFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmOptFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmDesc">
                      A string key that represents a class definition to be
                      registered. This key is used to look up the constructor
                      of <a>AudioWorkletProcessor</a> during construction of an
                      <a>AudioWorkletNode</a>.
                    </td>
                  </tr>
                  <tr>
                    <td class="prmName">
                      processorCtr
                    </td>
                    <td class="prmType">
                      <a><code>VoidFunction</code></a>
                    </td>
                    <td class="prmNullFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmOptFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmDesc">
                      A class definition extended from
                      <a>AudioWorkletProcessor</a>.
                    </td>
                  </tr>
                </table>
                <div>
                  <em>Return type:</em> <code>void</code>
                </div>
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h2 id="AudioWorkletNode-section">
            The AudioWorkletNode Interface
          </h2>
          <p>
            This interface represents a user-defined <a>AudioNode</a> which
            lives on the <a>control thread</a>. The user can create an
            <a>AudioWorkletNode</a> from an <a>BaseAudioContext</a>, and such a
            node can be connected with other built-in <a>AudioNode</a>s to form
            an audio graph.
          </p>
          <p>
            Every <a>AudioWorkletNode</a> has an associated <dfn>processor
            reference</dfn>, initially null, which refers to the
            <a>AudioWorkletProcessor</a> handling the processing for this node.
          </p>
          <p>
            Every <a>AudioWorkletProcessor</a> has an associated <dfn>active
            source</dfn> flag, initially <code>true</code>. This flag causes
            the node to be retained in memory and perform audio processing in
            the absence of any connected inputs.
          </p>
          <pre class="idl">
[Exposed=Window]
interface AudioParamMap {
    readonly maplike&lt;DOMString, AudioParam&gt;;
};
          </pre>
          <p>
            This interface has "entries", "forEach", "get", "has", "keys",
            "values", @@iterator methods and a "size" getter brought by
            <code>readonly maplike</code>.
          </p>
          <pre class="idl">
enum AudioWorkletProcessorState {
    "pending",
    "running",
    "stopped",
    "error"
};
          </pre>
          <table class="simple" data-dfn-for="AudioWorkletProcessorState"
          data-link-for="AudioWorkletProcessorState">
            <tr>
              <th colspan="2">
                Enumeration description
              </th>
            </tr>
            <tr>
              <td>
                <dfn>pending</dfn>
              </td>
              <td>
                The construction of associated processor has not been
                completed. In this state, no audio processing can happen and
                all messages to the processor will be queued.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>running</dfn>
              </td>
              <td>
                Indicates that the <a>active source</a> flag on the
                corresponding processor is <code>true</code>.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>stopped</dfn>
              </td>
              <td>
                Indicates that the <a>active source</a> flag on the
                corresponding processor is <code>false</code>.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>error</dfn>
              </td>
              <td>
                When an exception is thrown from the processor's
                <code>constructor</code>, <code>process</code> method, or any
                user-defined class method throws an exception. Note that once
                an <a>AudioWorkletNode</a> reaches to this state, the processor
                will output silence throughout its lifetime.
              </td>
            </tr>
          </table>
          <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional AudioWorkletOptions options)]
interface AudioWorkletNode : AudioNode {
    readonly        attribute AudioParamMap              parameters;
    readonly        attribute MessagePort                port;
    readonly        attribute AudioWorkletProcessorState processorState;
                    attribute EventHandler               onprocessorstatechange;
};
          </pre>
          <section>
            <h3>
              Constructors
            </h3>
            <dl class="methods" data-dfn-for="AudioWorkletNode" data-link-for=
            "AudioWorkletNode">
              <dt>
                <code><dfn>AudioWorkletNode</dfn></code>
              </dt>
              <dd>
                <p>
                  Let <var>node</var> be a new <a>AudioWorkletNode</a> object.
                  <a href="#audionode-constructor-init">Initialize</a>
                  <var>node</var>. Perform the <a href=
                  "#instantiation-of-AudioWorkletNode-and-AudioWorkletProcessor">
                  construction procedure</a> of an
                  <a><code>AudioWorkletNode</code></a> and the corresponding
                  <a><code>AudioWorkletProcessor</code></a> object. Return
                  <var>node</var>.
                </p>
                <table class="parameters">
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Type
                    </th>
                    <th>
                      Nullable
                    </th>
                    <th>
                      Optional
                    </th>
                    <th>
                      Description
                    </th>
                  </tr>
                  <tr>
                    <td class="prmName">
                      context
                    </td>
                    <td class="prmType">
                      <a><code>BaseAudioContext</code></a>
                    </td>
                    <td class="prmNullFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmOptFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmDesc">
                      The <a>BaseAudioContext</a> this new
                      <a>AudioWorkletNode</a> will be <a href=
                      "#associated">associated</a> with.
                    </td>
                  </tr>
                  <tr>
                    <td class="prmName">
                      options
                    </td>
                    <td class="prmType">
                      <a><code>AudioWorkletOptions</code></a>
                    </td>
                    <td class="prmNullFalse">
                      <span role="img" aria-label="False">âœ˜</span>
                    </td>
                    <td class="prmOptTrue">
                      <span role="img" aria-label="True">âœ”</span>
                    </td>
                    <td class="prmDesc">
                      Optional initial parameters value for this
                      <a>AudioWorkletNode</a>.
                    </td>
                  </tr>
                </table>
              </dd>
            </dl>
          </section>
          <section>
            <h3>
              Attributes
            </h3>
            <dl class="attributes" data-dfn-for="AudioWorkletNode"
            data-link-for="AudioWorkletNode">
              <dt>
                <code><dfn>onprocessorstatechange</dfn></code> of type
                <span class=
                "idlAttrType"><a><code>EventHandler</code></a></span>
              </dt>
              <dd>
                Any state change on the processor will queue a task on the
                control thread to fire <a>onprocessorstatechange</a> event to
                the node.
              </dd>
              <dt>
                <code><dfn>parameters</dfn></code> of type <span class=
                "idlAttrType"><a><code>AudioParamMap</code></a></span>,
                readonly
              </dt>
              <dd>
                The <code>parameters</code> attribute is a collection of
                <a>AudioParam</a> objects with associated names. This maplike
                object is populated from a list of <a>AudioParamDescriptor</a>s
                in the <a>AudioWorkletProcessor</a> class definition at the
                instantiation.
              </dd>
              <dt>
                <code><dfn>port</dfn></code> of type <span class=
                "idlAttrType"><a><code>MessagePort</code></a></span>, readonly
              </dt>
              <dd>
                Every <a>AudioWorkletNode</a> has an associated
                <code>port</code> which is a <a href=
                "https://html.spec.whatwg.org/multipage/comms.html#message-ports">
                MessagePort</a>. It is connected to the port on the
                corresponding <a>AudioWorkletProcessor</a> object allowing
                bidirectional communication between a pair of
                <a>AudioWorkletNode</a> and <a>AudioWorkletProcessor</a>.
              </dd>
              <dt>
                <code><dfn>processorState</dfn></code> of type <span class=
                "idlAttrType"><a><code>AudioWorkletProcessorState</code></a></span>,
                readonly
              </dt>
              <dd>
                Indicates the state of the associated processor. The
                propagation from the actual processor's <a>active source</a>
                flag to this property is done by queueing a task.
              </dd>
            </dl>
          </section>
          <section>
            <h2 id="AudioWorkletNodeOptions">
              <dfn>AudioWorkletNodeOptions</dfn>
            </h2>
            <p>
              The <code>AudioWorkletNodeOptions</code> dictionary can be used
              for the custom initialization of <a><code>AudioNode</code></a>
              attributes in the <a><code>AudioWorkletNode</code></a>
              constructor. Entries in this dictionary whose names correspond to
              <a><code>AudioParam</code></a>s in the class definition of an
              <a><code>AudioWorkletProcessor</code></a> are used to initialize
              the parameter values upon the creation of a node.
            </p>
            <pre class="idl">
dictionary AudioWorkletNodeOptions : AudioNodeOptions {
             unsigned long             numberOfInputs = 1;
             unsigned long             numberOfOutputs = 1;
             record&lt;DOMString, double&gt;  parameterData;
};
            </pre>
            <section>
              <h3>
                Dictionary <a>AudioWorkletNodeOptions</a> Members
              </h3>
              <dl class="attributes" data-dfn-for="AudioWorkletNodeOptions"
              data-link-for="AudioWorkletNodeOptions">
                <dt>
                  <code><dfn>numberOfInputs</dfn></code> of type <span class=
                  "idlAttrType"><code>unsigned long</code></span>, defaulting
                  to 1
                </dt>
                <dd>
                  This is used to initialize the value of <a>AudioNode</a>
                  <a data-link-for="AudioNode">numberOfInputs</a> attribute.
                </dd>
                <dt>
                  <code><dfn>numberOfOutputs</dfn></code> of type <span class=
                  "idlAttrType"><code>unsigned long</code></span>, defaulting
                  to 1
                </dt>
                <dd>
                  This is used to initialize the value of <a>AudioNode</a>
                  <a data-link-for="AudioNode">numberOfOutputs</a> attribute.
                </dd>
                <dt>
                  <code><dfn>parameterData</dfn></code> of type <span class=
                  "idlAttrType"><code>record&lt;DOMString,
                  double&gt;</code></span>
                </dt>
                <dd>
                  This is a list of user-defined key-value pairs that are used
                  to initialize <a>AudioParam</a> values in
                  <a>AudioWorkletNode</a>. If the string key of an entry in the
                  list does not match any name of <a>AudioParam</a> objects in
                  the node, it is ignored.
                </dd>
              </dl>
            </section>
          </section>
        </section>
        <section>
          <h2 id="AudioWorkletProcessor">
            The <dfn>AudioWorkletProcessor</dfn> Interface
          </h2>
          <p>
            This interface represents an audio processing code that runs on the
            audio <a>rendering thread</a>. It lives in an
            <a><code>AudioWorkletGlobalScope</code></a> and the definition of
            the class manifests the actual audio processing mechanism of a
            custom audio node. <a><code>AudioWorkletProcessor</code></a> can
            only be instantiated by the construction of an
            <a><code>AudioWorkletNode</code></a> instance. Every
            <a>AudioWorkletProcessor</a> has an associated <dfn>node
            reference</dfn>, initially null.
          </p>
          <pre class="idl">
[Exposed=AudioWorklet]
interface AudioWorkletProcessor {
    readonly        attribute MessagePort port;
};
          </pre>
          <section>
            <h3>
              Attributes
            </h3>
            <dl class="attributes" data-dfn-for="AudioWorkletProcessor"
            data-link-for="AudioWorkletProcessor">
              <dt>
                <code><dfn>port</dfn></code> of type <span class=
                "idlAttrType"><a><code>MessagePort</code></a></span>, readonly
              </dt>
              <dd>
                Every <a>AudioWorkletProcessor</a> has an associated
                <code>port</code> which is a <a href=
                "https://html.spec.whatwg.org/multipage/comms.html#message-ports">
                MessagePort</a>. It is connected to the port on the
                corresponding <a>AudioWorkletProcessor</a> object allowing
                bidirectional communication between a pair of
                <a>AudioWorkletNode</a> and <a>AudioWorkletProcessor</a>.
              </dd>
            </dl>
          </section>
          <section>
            <h2 id="defining-a-valid-audioworkletprocessor">
              Defining A Valid AudioWorkletProcessor
            </h2>
            <p>
              User can define a custom audio processor by extending
              <a>AudioWorkletProcessor</a>. The subclass MUST define a method
              named <code>process()</code> that implements the audio processing
              algorithm and have a valid static property named
              <code><dfn>parameterDescriptors</dfn></code> which is an iterable
              of <a>AudioParamDescriptor</a> that is looked up by the
              <a>AudioWorkletProcessor</a> constructor to create instances of
              <a>AudioParam</a> in the <code>parameters</code> maplike storage
              in the node. The step 5 and 6 of <a data-link-for=
              "AudioWorkletGlobalScope">registerProcessor()</a> ensure the
              validity of a given <a>AudioWorkletProcessor</a> subclass.
            </p>
            <p>
              An example of a valid subclass is as follows:
            </p>
            <pre class="example" title="Subclassing AudioWorkletProcessor">
class MyProcessor extends AudioWorkletProcessor {
  static get parameterDescriptors() {
    return [{
      name: 'myParam',
      defaultValue: 0.5,
      minValue: 0,
      maxValue: 1
    }];
  }

  process(inputs, outputs, parameters) {
    // Get the first input and output.
    var input = inputs[0];
    var output = outputs[0];
    var myParam = parameters.myParam;

    // A simple amplifier for single input and output.
    for (var channel = 0; channel &lt; output.length; ++channel) {
      for (var i = 0; i &lt; output[channel].length; ++i) {
        output[channel][i] = input[channel][i] * myParam[i];
      }
    }
  }
}
</pre>
            <p>
              The <code>process()</code> method is called synchronously by the
              audio <a>rendering thread</a> at every <a>render quantum</a>, if
              ANY of the following <dfn>active processing conditions</dfn> are
              true:
            </p>
            <ol>
              <li>The associated <a>AudioWorkletProcessor</a>'s <a>active
              source</a> flag is equal to <code>true</code>.
              </li>
              <li>There are one or more connected inputs to the
              <a>AudioWorkletNode</a>.
              </li>
            </ol>
            <p>
              The method is invoked with the following arguments:
            </p>
            <ol>
              <li>
                <p>
                  <code>inputs</code> of type
                  <code>sequence&lt;sequence&lt;Float32Array&gt;&gt;</code><br>
                  The input audio buffer from the incoming connections provided
                  by the user agent. <code>inputs[n][m]</code> is a
                  <code>Float32Array</code> of audio samples for the
                  <code>m</code>th channel of <code>n</code>th input. While the
                  number of inputs is fixed at the construction, the number of
                  channels can be changed dynamically.
                </p>
                <p>
                  If no connections exist to the <code>n</code>th input of the
                  node during the current render quantum, then the content of
                  <code>inputs[n]</code> is an empty array, indicating that
                  zero channels of input are available. This is the only
                  circumstance under which the number of elements of
                  <code>inputs[n]</code> can be zero.
                </p>
              </li>
              <li>
                <code>outputs</code> of type
                <code>sequence&lt;sequence&lt;Float32Array&gt;&gt;</code><br>
                The output audio buffer that is to be consumed by the user
                agent. <code>outputs[n][m]</code> is a
                <code>Float32Array</code> object containing the audio samples
                for <code>m</code>th channel of <code>n</code>th output. While
                the number of outputs is fixed at the construction, the number
                of channels can be changed dynamically.
              </li>
              <li>
                <code>parameters</code> of type <code>Object</code><br>
                A map of string keys and associated <code>Float32Array</code>s.
                <code>parameters["name"]</code> corresponds to the automation
                values of the <a><code>AudioParam</code></a> named
                <code>"name"</code>.
              </li>
            </ol>
            <p>
              The return value of this method controls the lifetime of the
              <a>AudioWorkletProcessor</a>'s associated
              <a>AudioWorkletNode</a>. At the conclusion of each call to the
              <code>process()</code> method, if the result of applying <a href=
              "https://tc39.github.io/ecma262/#sec-toboolean"><code>ToBoolean</code></a>
              (described in [[!ECMASCRIPT]]) to the return value is assigned to
              the associated <a>AudioWorkletProcessor</a>'s <a>active
              source</a> flag. This in turn can affects whether subsequent
              invocations of <code>process()</code> occur and also the flag
              change is propagated by <a href="#queue">queueing a task</a> on
              the control thread to update the corresponding
              <a>AudioWorkletNode</a>'s <code>state</code> property
              accordingly.
            </p>
            <div class="note">
              This lifetime policy can support a variety of approaches found in
              built-in nodes, including the following:
              <ul>
                <li>Nodes that transform their inputs, and are active only
                while connected inputs and/or script references exist. Such
                nodes SHOULD return <code>false</code> from
                <code>process()</code> which allows the presence or absence of
                connected inputs to determine whether active processing occurs.
                </li>
                <li>Nodes that transform their inputs, but which remain active
                for a <a>tail-time</a> after their inputs are disconnected. In
                this case, <code>process()</code> SHOULD return
                <code>true</code> for some period of time after
                <code>inputs</code> is found to contain zero channels. The
                current time may be obtained from the global scope's
                <a data-link-for="AudioWorkletGlobalScope">currentTime</a> to
                measure the start and end of this tail-time interval, or the
                interval could be calculated dynamically depending on the
                processor's internal state.
                </li>
                <li>Nodes that act as sources of output, typically with a
                lifetime. Such nodes SHOULD return <code>true</code> from
                <code>process()</code> until the point at which they are no
                longer producing an output.
                </li>
              </ul>Note that the preceding definition implies that when no
              return value is provided from an implementation of
              <code>process()</code>, the effect is identical to returning
              <code>false</code> (since the effective return value is the falsy
              value <code>undefined</code>). This is a reasonable behavior for
              any <a>AudioWorkletProcessor</a> that is active only when it has
              active inputs.
            </div>
            <p>
              If <code>process()</code> is not called during some rendering
              quantum due to the lack of any applicable <a>active processing
              conditions</a>, the result is is as if the processor emitted
              silence for this period.
            </p>
          </section>
          <section>
            <h2 id="AudioParamDescriptor">
              <dfn>AudioParamDescriptor</dfn>
            </h2>
            <p>
              The <code>AudioParamDescriptor</code> dictionary is used to
              specify properties for an <a><code>AudioParam</code></a> object
              that is used in an <a><code>AudioWorkletNode</code></a>.
            </p>
            <pre class="idl">
dictionary AudioParamDescriptor {
    required DOMString name;
             float     defaultValue = 0;
             float     minValue = -3.4028235e38;
             float     maxValue = 3.4028235e38;
};
            </pre>
            <section>
              <h3>
                Dictionary <a>AudioParamDescriptor</a> Members
              </h3>
              <dl class="attributes" data-dfn-for="AudioParamDescriptor"
              data-link-for="AudioParamDescriptor">
                <dt>
                  <code><dfn>defaultValue</dfn></code> of type <span class=
                  "idlAttrType"><code>float</code></span>, defaulting to 0
                </dt>
                <dd>
                  Represents the default value of the parameter. If this value
                  is out of the range of float data type or the range defined
                  by <code>minValue</code> and <code>maxValue</code>, an
                  <code>NotSupportedError</code> exception MUST be thrown.
                </dd>
                <dt>
                  <code><dfn>maxValue</dfn></code> of type <span class=
                  "idlAttrType"><code>float</code></span>, defaulting to
                  3.4028235e38
                </dt>
                <dd>
                  Represents the maximum value. An
                  <code>NotSupportedError</code> exception MUST be thrown if
                  this value is out of range of float data type or it is
                  smaller than <code>minValue</code>. This value is the most
                  positive finite single precision floating-point number.
                </dd>
                <dt>
                  <code><dfn>minValue</dfn></code> of type <span class=
                  "idlAttrType"><code>float</code></span>, defaulting to
                  -3.4028235e38
                </dt>
                <dd>
                  Represents the minimum value. An
                  <code>NotSupportedError</code> exception MUST be thrown if
                  this value is out of range of float data type or it is
                  greater than <code>maxValue</code>. This value is the most
                  negative finite single precision floating-point number.
                </dd>
                <dt>
                  <code><dfn>name</dfn></code> of type <span class=
                  "idlAttrType"><code>DOMString</code></span>, required
                </dt>
                <dd>
                  Represents the name of a parameter. An
                  <code>NotSupportedError</code> exception MUST be thrown when
                  a duplicated name is found when registering the class
                  definition.
                </dd>
              </dl>
            </section>
          </section>
        </section>
        <section>
          <h2 id="instantiation-of-AudioWorkletNode-and-AudioWorkletProcessor">
            The instantiation of <a>AudioWorkletNode</a> and
            <a>AudioWorkletProcessor</a>
          </h2>
          <p>
            When the constructor of <a>AudioWorkletNode</a> is invoked in the
            main global scope, the corresponding <a>AudioWorkletProcessor</a>
            instance is automatically created in
            <a>AudioWorkletGlobalScope</a>. After the construction, they
            maintain the internal reference to each other until the
            <a>AudioWorkletNode</a> instance is destroyed.
          </p>
          <p>
            Note that the instantiation of these two objects spans the control
            thread and the rendering thread.
          </p>
          <p>
            When <a>AudioWorkletNode</a>(<var>context</var>,
            <var>nodeName</var>, <var>options</var>) constructor is invoked,
            the user agent MUST perform the following steps on the control
            thread, where the constructor was called.
          </p>
          <ol>
            <li>Let <var>this</var> be the instance being created by
            constructor of <a>AudioWorkletNode</a> or its subclass.
            </li>
            <li>If <var>nodeName</var> does not exists as a key in the
            <a>BaseAudioContext</a>â€™s <a>node name to parameter descriptor
            map</a>, throw a <code>NotSupportedError</code> exception and abort
            these steps.
            </li>
            <li>Let <var>node</var> be a new <a>AudioWorkletNode</a> object.
            </li>
            <li>Let <var>messageChannel</var> be a new <a href=
            "https://html.spec.whatwg.org/multipage/#message-channels">MessageChannel</a>.
            </li>
            <li>Let <var>nodePort</var> be the value of
            <var>messageChannel</var>'s <code>port1</code> attribute.
            </li>
            <li>Let <var>processorPortOnThisSide</var> be the value of
            <var>messageChannel</var>'s <code>port2</code> attribute.
            </li>
            <li>Let <var>processorPortSerialization</var> be <a href=
            "https://html.spec.whatwg.org/multipage/infrastructure.html#structuredserializewithtransfer">
              StructuredSerializeWithTransfer</a>(<var>processorPortOnThisSide</var>,
              Â« <var>processorPortOnThisSide</var> Â»).
            </li>
            <li>Set <var>node</var>'s <a data-link-for=
            "AudioWorkletNode">port</a> to <var>nodePort</var>.
            </li>
            <li>Let <var>parameterDescriptors</var> be the result of retrieval
            of <var>nodeName</var> from <a>node name to parameter descriptor
            map</a>:
              <ol>
                <li>Let <var>audioParamMap</var> be a new <a>AudioParamMap</a>
                object.
                </li>
                <li>For each <var>descriptor</var> of
                <var>parameterDescriptors</var>:
                  <ol>
                    <li>Let <var>paramName</var> be the value of
                    <var>descriptor</var>'s <a data-link-for=
                    "AudioParamDescriptor">name</a>.
                    </li>
                    <li>Let <var>audioParam</var> be a new <a>AudioParam</a>
                    instance.
                    </li>
                    <li>Append (<var>paramName</var>, <var>audioParam</var>) to
                    <var>audioParamMap</var>'s entries.
                    </li>
                  </ol>
                </li>
                <li>For each <var>paramNameInOption</var> â†’ <var>value</var> of
                <var>options</var>:
                  <ol>
                    <li>If there exists an entry with name member equal to
                    <var>paramNameInOption</var> inside
                    <var>audioParamMap</var>, set that <a>AudioParam</a>'s
                    value to <var>value</var>.
                    </li>
                    <li>
                      <var>paramNameInOption</var> will be ignored when:
                      <ul>
                        <li>
                          <var>audioParamMap</var> does not have any entry with
                          the same name member.
                        </li>
                        <li>
                          <var>value</var> is not a type of <code>Number</code>
                          or out of the range specified in
                          <a>AudioParamDescriptor</a>.
                        </li>
                      </ul>
                    </li>
                  </ol>
                </li>
                <li>Set <var>node</var>'s <a data-link-for="AudioWorkletNode">
                  parameters</a> to <var>audioParamMap</var>.
                </li>
              </ol>
            </li>
            <li>
              <a href="#queuing">Queue a control message</a> to create an
              <a>AudioWorkletProcessor</a>, given <var>nodeName</var>,
              <var>processorPortSerialization</var>, and <var>node</var>.
            </li>
            <li>Return <var>node</var>.
            </li>
          </ol>
          <p>
            In order to process a control message for the construction of an
            <a>AudioWorkletProcessor</a>, given a string <var>nodeName</var>, a
            serialization record <var>processorPortSerialization</var>, and an
            <a>AudioWorkletNode</a> <var>node</var>, perform the following
            steps on the <a>rendering thread</a>. If any of these steps throws
            an exception (either explicitly or implicitly), abort the rest of
            steps and queue a task on the <a>control thread</a> to fire
            <a data-link-for=
            "AudioWorkletNode"><code>onprocessorstatechange</code></a> event to
            <var>node</var> with <code>error</code> state.
          </p>
          <ol>
            <li>Let <var>processorPort</var> be <a href=
            "https://html.spec.whatwg.org/multipage/infrastructure.html#structureddeserializewithtransfer">
              StructuredDeserializeWithTransfer</a>(<var>processorPortSerialization</var>,
              the current Realm).
            </li>
            <li>Let <var>processorConstructor</var> be the result of looking up
            <var>nodeName</var> on the <a>AudioWorkletGlobalScope</a>'s <a>node
            name to processor definition map</a>.
            </li>
            <li>If <var>processorConstructor</var> is <code>undefined</code>,
            throw a <code>NotSupportedError</code> DOMException.
            </li>
            <li>Let <var>processor</var> be the result of
            Construct(<var>processorConstructor</var>).
            </li>
            <li>If <var>processor</var> does not implement the
            <a>AudioWorkletProcessor</a> interface, throw an
            <code>"InvalidStateError"</code> DOMException.
            </li>
            <li>Set <var>processor</var>'s <a data-link-for=
            "AudioWorkletProcessor">port</a> to <var>processorPort</var>.
            </li>
            <li>Set <var>processor</var>'s <a>node reference</a> to
            <var>node</var>.
            </li>
            <li>Set <var>node</var>'s <a>processor reference</a> to
            <var>processor</var>.
            </li>
            <li>Queue a task the <a>control thread</a> to set the associated
            <a>AudioWorkletNode</a>'s state to <code>running</code>, then fire
            a <code>statechange</code> event.
            </li>
          </ol>
        </section>
        <section class="informative">
          <h2 id="AudioWorklet-Sequence">
            AudioWorklet Sequence of Events
          </h2>
          <p>
            The following figure illustrates an idealized sequence of events
            occurring relative to an <a>AudioWorklet</a>:
          </p>
          <figure>
            <img alt="AudioWorklet sequence" src=
            "images/audioworklet-instantiation-sequence.png" width="784"
            height="427">
            <figcaption>
              <a>AudioWorklet</a> sequence
            </figcaption>
          </figure>
          <p>
            The steps depicted in the diagram are one possible sequence of
            events involving the creation of an <a>AudioContext</a> and an
            associated <a>AudioWorkletGlobalScope</a>, followed by the creation
            of an <a>AudioWorkletNode</a> and its associated
            <a>AudioWorkletProcessor</a>.
          </p>
          <ol>
            <li>In the main scope, <code>window.audioWorklet</code> is
            requested to import a script. No <a>AudioWorkletGlobalScope</a>s
            exist yet, so the script is fetched and added to the Worklet module
            responses map.
            </li>
            <li>An <a>AudioContext</a> is created.
            </li>
            <li>An <a>AudioWorkletGlobalScope</a> is created in association
            with the context's audio rendering thread. This is the global scope
            in which <a>AudioWorkletProcessor</a> class definitions will be
            evaluated.
            </li>
            <li>As part of the global scope's initialization, the set of
            imported scripts is run, including the one that was previously
            imported.
            </li>
            <li>As part of running the imported script, an
            <a>AudioWorkletProcessor</a> is registered under the key
            <code>"Custom1"</code> within the <a>AudioWorkletGlobalScope</a>.
            </li>
            <li>In the main scope, an <a>AudioWorkletNode</a> is created using
            the key <code>"Custom1"</code> along with an <code>opts</code>
            dictionary of options.
            </li>
            <li>As part of the node's creation, this key is used to look up the
            correct <a>AudioWorkletProcessor</a> subclass for instantiation.
            </li>
            <li>An instance of the <a>AudioWorkletProcessor</a> subclass is
            instantiated with a structured clone of the same <code>opts</code>
            dictionary. This instance is paired with the previously created <a>
              AudioWorkletNode</a>.
            </li>
          </ol>
        </section>
        <section class="informative">
          <h2 id="AudioWorklet-Examples">
            AudioWorklet Examples
          </h2>
          <section>
            <h3>
              The BitCrusher Node
            </h3>
            <p>
              Bitcrushing is a mechanism by which the quality of an audio
              stream is reduced both by quantizing the sample value (simulating
              a lower bit-depth), and by quantizing in time resolution
              (simulating a lower sample rate). This example shows how to use
              <a><code>AudioParam</code></a>s (in this case, treated as
              <a>a-rate</a>) inside an
              <a><code>AudioWorkletProcessor</code></a>.
            </p>
            <pre class="example" title="BitCrusher - Global Scope">
window.audioWorklet.addModule('bitcrusher.js').then(function () {
  let context = new AudioContext();
  let osc = new OscillatorNode(context);
  let amp = new GainNode(context);

  // Create a worklet node. 'BitCrusher' identifies the
  // AudioWorkletProcessor previously registered when
  // bitcrusher.js was imported. The options automatically
  // initialize the correspondingly named AudioParams.
  let bitcrusher = new AudioWorkletNode(context, 'BitCrusher', {
    bitDepth: 8,
    frequencyReduction: 0.5
  });

  osc.connect(bitcrusher).connect(amp).connect(context.destination);
  osc.start();
});
</pre>
            <pre class="example" title=
            "BitCrusher - AudioWorkletGlobalScope (bitcrusher.js)">
registerProcessor('BitCrusher', class extends AudioWorkletProcessor {

  static get parameterDescriptors () {
    return [{
      name: 'bitDepth',
      defaultValue: 12,
      minValue: 1,
      maxValue: 16
    }, {
      name: 'frequencyReduction',
      defaultValue: 0.5,
      minValue: 0,
      maxValue: 1
    }];
  }

  constructor (options) {
    // We don't need to look at options: only AudioParams are initialized,
    // which were taken care of by the node.
    super(options);
    this._phase = 0;
    this._lastSampleValue = 0;
  }

  process (inputs, outputs, parameters) {
    let input = inputs[0];
    let output = outputs[0];
    let bitDepth = parameters.bitDepth;
    let frequencyReduction = parameters.frequencyReduction;

    for (let channel = 0; channel &lt; output.length; ++channel) {
      for (let i = 0; i &lt; output[channel].length; ++i) {
        let step = Math.pow(0.5, bitDepth[i]);
        this._phase += frequencyReduction[i];
        if (this._phase &gt;= 1.0) {
          this._phase -= 1.0;
          this._lastSampleValue =
            step * Math.floor(input[channel][i] / step + 0.5);
        }
        output[channel][i] = this._lastSampleValue;
      }
    }

    // No need to return a value; this node's lifetime is dependent only on its
    // input connections.
  }

});
</pre>
            <div class="note">
              <p>
                In the definition of <a>AudioWorkletProcessor</a> class, an
                <code>InvalidStateError</code> will be thrown if the
                author-supplied constructor uses JavaScript's return-override
                feature, or does not properly call <code>super()</code>.
              </p>
            </div>
          </section>
          <section>
            <h3>
              VU Meter Node
            </h3>
            <p>
              This example of a simple sound level meter further illustrates
              how to create an <a><code>AudioWorkletNode</code></a> subclass
              that acts like a native <a><code>AudioNode</code></a>, accepting
              constructor options and encapsulating the inter-thread
              communication (asynchronous) between
              <a><code>AudioWorkletNode</code></a> and
              <a><code>AudioWorkletProcessor</code></a> in clean method calls
              and attribute accesses. This node does not use any output.
            </p>
            <pre class="example" title=
            "VUMeterNode - Global Scope (vumeternode.js)">
class VUMeterNode extends AudioWorkletNode {

  constructor (context, options) {
    // Setting default values for the input, the output and the channel count.
    options.numberOfInputs = 1;
    options.numberOfOutputs = 0;
    options.channelCount = 1;
    options.updatingInterval = options.hasOwnProperty('updatingInterval')
      ? options.updatingInterval
      : 100;

    super(context, 'VUMeter', options);

    // States in AudioWorkletNode
    this._updatingInterval = options.updatingInterval;
    this._volume = 0;

    // Handles updated values from AudioWorkletProcessor
    this.port.onmessage = event =&gt; {
      if (event.data.volume)
        this._volume = event.data.volume;
    }
    this.port.start();
  }

  get updatingInterval() {
    return this._updatingInterval;
  }

  set updatingInterval (intervalValue) {
    this._updatingInterval = intervalValue;
    this.port.postMessage({ updatingInterval: intervalValue });
  }

  draw () {
    /* Draw the meter based on the volume value. */
  }

}

// The application can use the node when this promise resolves.
let importAudioWorkletNode = window.audioWorklet.addModule('vumeterprocessor.js');
</pre>
            <pre class="example" title=
            "VUMeterNode - AudioWorkletGlobalScope (vumeterprocessor.js)">
registerProcessor('VUMeter', class extends AudioWorkletProcessor {

  static meterSmoothingFactor = 0.9;
  static meterMinimum = 0.00001;

  constructor (options) {
    super(options);
    this._volume = 0;
    this._updatingInterval = options.updatingInterval;
    this._nextUpdateFrames = this.interval;

    this.port.onmessage = event =&gt; {
      if (event.data.updatingInterval)
        this._updatingInterval = event.data.updatingInterval;
    }
    this.port.start();
  }

  get interval () {
    return this._updatingInterval / 1000 * sampleRate;
  }

  process (inputs, outputs, parameters) {
    // Note that the input will be down-mixed to mono; however, if no inputs are
    // connected then zero channels will be passed in.
    if (inputs[0].length &gt; 0) {
      let buffer = inputs[0][0];
      let bufferLength = buffer.length;
      let sum = 0, x = 0, rms = 0;

      // Calculated the squared-sum.
      for (let i = 0; i &lt; bufferLength; ++i) {
        x = buffer[i];
        sum += x * x;
      }

      // Calculate the RMS level and update the volume.
      rms =  Math.sqrt(sum / bufferLength);
      this.volume = Math.max(rms, this._volume * meterSmoothingFactor);

      // Update and sync the volume property with the main thread.
      this._nextUpdateFrame -= bufferLength;
      if (this._nextUpdateFrame &lt; 0) {
        this._nextUpdateFrame += this.interval;
        this.port.postMessage({ volume: this._volume });
      }
    }

    // Keep on processing if the volume is above a threshold, so that
    // disconnecting inputs does not immediately cause the meter to stop
    // computing its smoothed value.
    return this._volume &gt;= meterMinimum;
  }

});
</pre>
            <pre class="example" title=
            "VUMeterNode - Global Scope (main HTML file)">
&lt;script src="vumeternode.js"&gt;&lt;/script&gt;
&lt;script&gt;
  importAudioWorkletNode.then(function () {
    let context = new AudioContext();
    let oscillator = new Oscillator(context);
    let vuMeterNode = new VUMeterNode(context, { updatingInterval: 50 });

    oscillator.connect(vuMeterNode);

    function drawMeter () {
      vuMeterNode.draw();
      requestAnimationFrame(drawMeter);
    }

    drawMeter();
  });
&lt;/script&gt;
</pre>
          </section>
        </section>
      </section>
      <section class="informative">
        <h2>
          The <dfn>ScriptProcessorNode</dfn> Interface - DEPRECATED
        </h2>
        <p>
          This interface is an <a><code>AudioNode</code></a> which can
          generate, process, or analyse audio directly using a script. This
          node type is deprecated, to be replaced by the
          <a>AudioWorkletNode</a>; this text is only here for informative
          purposes until implementations remove this node type.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                <a data-link-for="BaseAudioContext">numberOfInputChannels</a>
              </td>
              <td>
                This is the number of channels specified when constructing this
                node. There are <a>channelCount constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">explicit</a>"
              </td>
              <td>
                Has <a>channelCountMode constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <p>
          The <a><code>ScriptProcessorNode</code></a> is constructed with a
          <dfn>bufferSize</dfn> which MUST be one of the following values: 256,
          512, 1024, 2048, 4096, 8192, 16384. This value controls how
          frequently the <a data-link-for=
          "ScriptProcessorNode">onaudioprocess</a> event is dispatched and how
          many sample-frames need to be processed each call. <a data-link-for=
          "ScriptProcessorNode"><code>onaudioprocess</code></a> events are only
          dispatched if the <a><code>ScriptProcessorNode</code></a> has at
          least one input or one output connected. Lower numbers for
          <a data-link-for="ScriptProcessorNode">bufferSize</a> will result in
          a lower (better) <a href="#latency">latency</a>. Higher numbers will
          be necessary to avoid audio breakup and <a href=
          "#audio-glitching">glitches</a>. This value will be picked by the
          implementation if the bufferSize argument to
          <code>createScriptProcessor</code> is not passed in, or is set to 0.
        </p>
        <p>
          <a>numberOfInputChannels</a> and <a>numberOfOutputChannels</a>
          determine the number of input and output channels. It is invalid for
          both <a>numberOfInputChannels</a> and <a>numberOfOutputChannels</a>
          to be zero.
        </p>
        <pre class="idl">
[Exposed=Window]
interface ScriptProcessorNode : AudioNode {
                    attribute EventHandler onaudioprocess;
    readonly        attribute long         bufferSize;
};
        </pre>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="ScriptProcessorNode"
          data-link-for="ScriptProcessorNode">
            <dt>
              <code><dfn>bufferSize</dfn></code> of type <span class=
              "idlAttrType"><a><code>long</code></a></span>, readonly
            </dt>
            <dd>
              The size of the buffer (in sample-frames) which needs to be
              processed each time <a data-link-for=
              "ScriptProcessorNode"><code>onaudioprocess</code></a> is called.
              Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384).
            </dd>
            <dt>
              <code><dfn>onaudioprocess</dfn></code> of type <span class=
              "idlAttrType"><code>EventHandler</code></span>
            </dt>
            <dd>
              A property used to set the <code>EventHandler</code> (described
              in <cite><a href=
              "https://html.spec.whatwg.org/multipage/webappapis.html#eventhandler">
              HTML</a></cite>[[!HTML]]) for the <a data-link-for=
              "ScriptProcessorNode"><code>onaudioprocess</code></a> event that
              is dispatched to <a><code>ScriptProcessorNode</code></a> node
              types. An event of type <a><code>AudioProcessingEvent</code></a>
              will be dispatched to the event handler.
            </dd>
          </dl>
        </section>
        <section class="informative">
          <h2>
            The <dfn>AudioProcessingEvent</dfn> Interface - DEPRECATED
          </h2>
          <p>
            This is an <code>Event</code> object which is dispatched to
            <a><code>ScriptProcessorNode</code></a> nodes. It will be removed
            when the ScriptProcessorNode is removed, as the replacement
            <a>AudioWorkletNode</a> uses a different approach.
          </p>
          <p>
            The event handler processes audio from the input (if any) by
            accessing the audio data from the <code>inputBuffer</code>
            attribute. The audio data which is the result of the processing (or
            the synthesized data if there are no inputs) is then placed into
            the <code>outputBuffer</code>.
          </p>
          <pre class="idl">
[Exposed=Window,
 Constructor (DOMString type, AudioProcessingEventInit eventInitDict)]
interface AudioProcessingEvent : Event {
    readonly        attribute double      playbackTime;
    readonly        attribute AudioBuffer inputBuffer;
    readonly        attribute AudioBuffer outputBuffer;
};
          </pre>
          <section>
            <h3>
              Attributes
            </h3>
            <dl class="attributes" data-dfn-for="AudioProcessingEvent"
            data-link-for="AudioProcessingEvent">
              <dt>
                <code><dfn>inputBuffer</dfn></code> of type <span class=
                "idlAttrType"><a><code>AudioBuffer</code></a></span>, readonly
              </dt>
              <dd>
                An AudioBuffer containing the input audio data. It will have a
                number of channels equal to the
                <code>numberOfInputChannels</code> parameter of the
                createScriptProcessor() method. This AudioBuffer is only valid
                while in the scope of the <a data-link-for=
                "ScriptProcessorNode"><code>onaudioprocess</code></a> function.
                Its values will be meaningless outside of this scope.
              </dd>
              <dt>
                <code><dfn>outputBuffer</dfn></code> of type <span class=
                "idlAttrType"><code>AudioBuffer</code></span>, readonly
              </dt>
              <dd>
                An AudioBuffer where the output audio data MUST be written. It
                will have a number of channels equal to the
                <code>numberOfOutputChannels</code> parameter of the
                createScriptProcessor() method. Script code within the scope of
                the <a data-link-for=
                "ScriptProcessorNode"><code>onaudioprocess</code></a> function
                is expected to modify the <code>Float32Array</code> arrays
                representing channel data in this AudioBuffer. Any script
                modifications to this AudioBuffer outside of this scope will
                not produce any audible effects.
              </dd>
              <dt>
                <code><dfn>playbackTime</dfn></code> of type <span class=
                "idlAttrType"><code>double</code></span>, defaulting to 0
              </dt>
              <dd>
                The time when the audio will be played in the same time
                coordinate system as the <a><code>AudioContext</code></a>'s
                <a data-link-for="BaseAudioContext">currentTime</a>.
              </dd>
            </dl>
          </section>
          <section>
            <h3>
              <dfn>AudioProcessingEventInit</dfn>
            </h3>
            <pre class="idl">
dictionary AudioProcessingEventInit : EventInit {
    required double      playbackTime;
    required AudioBuffer inputBuffer;
    required AudioBuffer outputBuffer;
};
            </pre>
            <section>
              <h3>
                Dictionary <a>AudioProcessingEventInit</a> Members
              </h3>
              <dl class="attributes" data-dfn-for="AudioProcessingEventInit"
              data-link-for="AudioProcessingEventInit">
                <dt>
                  <code><dfn>inputBuffer</dfn></code> of type <span class=
                  "idlAttrType"><code>AudioBuffer</code></span>, required
                </dt>
                <dd>
                  Value to be assigned to the <a data-link-for=
                  "AudioProcessingEvent"><code>inputBuffer</code></a> attribute
                  of the event.
                </dd>
                <dt>
                  <code><dfn>outputBuffer</dfn></code> of type <span class=
                  "idlAttrType"><code>float</code></span>, required
                </dt>
                <dd>
                  Value to be assigned to the <a data-link-for=
                  "AudioProcessingEvent"><code>outputBuffer</code></a>
                  attribute of the event.
                </dd>
                <dt>
                  <code><dfn>playbackTime</dfn></code> of type <span class=
                  "idlAttrType"><code>double</code></span>, required
                </dt>
                <dd>
                  Value to be assigned to the <a data-link-for=
                  "AudioProcessingEvent"><code>playbackTime</code></a>
                  attribute of the event.
                </dd>
              </dl>
            </section>
          </section>
        </section>
      </section>
      <section>
        <h2>
          The PannerNode Interface
        </h2>
        <p>
          This interface represents a processing node which <a href=
          "#Spatialization">positions / spatializes</a> an incoming audio
          stream in three-dimensional space. The spatialization is in relation
          to the <a>AudioContext</a>'s <a><code>AudioListener</code></a>
          (<code>listener</code> attribute).
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                2
              </td>
              <td>
                Has <a>channelCount constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">clamped-max</a>"
              </td>
              <td>
                Has <a>channelCountMode constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                Maybe
              </td>
              <td>
                If the <a data-link-for="PannerNode">panningModel</a> is set to
                "<a data-link-for="PanningModelType">HRTF</a>", the node will
                produce non-silent output for silent input due to the inherent
                processing for head responses. Otherwise there are no tail-time
                references.
              </td>
            </tr>
          </table>
        </div>
        <p>
          The input of this node is either mono (1 channel) or stereo (2
          channels) and cannot be increased. Connections from nodes with fewer
          or more channels will be <a href=
          "#channel-up-mixing-and-down-mixing">up-mixed or down-mixed
          appropriately</a>.
        </p>
        <p>
          The output of this node is hard-coded to stereo (2 channels) and
          cannot be configured.
        </p>
        <p>
          The <a><code>PanningModelType</code></a> enum determines which
          spatialization algorithm will be used to position the audio in 3D
          space. The default is <code>"equalpower"</code>.
        </p>
        <pre class="idl">
enum PanningModelType {
    "equalpower",
    "HRTF"
};
        </pre>
        <table class="simple" data-dfn-for="PanningModelType" data-link-for=
        "PanningModelType">
          <tr>
            <th colspan="2">
              Enumeration description
            </th>
          </tr>
          <tr>
            <td>
              <dfn>equalpower</dfn>
            </td>
            <td>
              A simple and efficient spatialization algorithm using equal-power
              panning.
              <div class="note">
                When this panning model is used, all the <a>AudioParam</a>s
                used to compute the output of this node are <a>a-rate</a>.
              </div>
            </td>
          </tr>
          <tr>
            <td>
              <dfn>HRTF</dfn>
            </td>
            <td>
              A higher quality spatialization algorithm using a convolution
              with measured impulse responses from human subjects. This panning
              method renders stereo output.
              <div class="note">
                When this panning model is used, all the <a>AudioParam</a>s
                used to compute the output of this node are <a>k-rate</a>.
              </div>
            </td>
          </tr>
        </table>
        <p>
          The <a><code>DistanceModelType</code></a> enum determines which
          algorithm will be used to reduce the volume of an audio source as it
          moves away from the listener. The default is "inverse".
        </p>
        <p>
          In the description of each distance model below, let \(d\) be the
          distance between the listener and the panner; \(d_{ref}\) be the
          value of the <code>refDistance</code> attribute; \(d_{max}\) be the
          value of the <code>maxDistance</code> attribute; and \(f\) be the
          value of the <code>rolloffFactor</code> attribute.
        </p>
        <pre class="idl">
enum DistanceModelType {
    "linear",
    "inverse",
    "exponential"
};
        </pre>
        <table class="simple" data-dfn-for="DistanceModelType" data-link-for=
        "DistanceModelType">
          <tr>
            <th colspan="2">
              Enumeration description
            </th>
          </tr>
          <tr>
            <td>
              <dfn>linear</dfn>
            </td>
            <td>
              <p>
                A linear distance model which calculates <em>distanceGain</em>
                according to:
              </p>
              <pre class="nohighlight">
            $$
              1 - f\frac{\max(\min(d, d'_{max}), d'_{ref}) - d'_{ref}}{d'_{max} - d'_{ref}}
            $$

</pre>
              <p>
                where \(d'_{ref} = \min(d_{ref}, d_{max})\) and \(d'_{max} =
                \max(d_{ref}, d_{max})\). In the case where \(d'_{ref} =
                d'_{max}\), the value of the linear model is taken to be
                \(1-f\).
              </p>
              <p>
                Note that \(d\) is clamped to the interval \([d'_{ref},\,
                d'_{max}]\).
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <dfn>inverse</dfn>
            </td>
            <td>
              <p>
                An inverse distance model which calculates
                <em>distanceGain</em> according to:
              </p>
              <pre class="nohighlight">
              $$
                \frac{d_{ref}}{d_{ref} + f (\max(d, d_{ref}) - d_{ref})}
              $$

</pre>
              <p>
                That is, \(d\) is clamped to the interval \([d_{ref},\,
                \infty)\). If \(d_{ref} = 0\), the value of the inverse model
                is taken to be 0, independent of the value of \(d\) and \(f\).
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <dfn>exponential</dfn>
            </td>
            <td>
              <p>
                An exponential distance model which calculates
                <em>distanceGain</em> according to:
              </p>
              <pre class="nohighlight">
              $$
                \left(\frac{\max(d, d_{ref})}{d_{ref}}\right)^{-f}
              $$

</pre>
              <p>
                That is, \(d\) is clamped to the interval \([d_{ref},\,
                \infty)\). If \(d_{ref} = 0\), the value of the exponential
                model is taken to be 0, independent of \(d\) and \(f\).
              </p>
            </td>
          </tr>
        </table>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional PannerOptions options)]
interface PannerNode : AudioNode {
                    attribute PanningModelType  panningModel;
    readonly        attribute AudioParam        positionX;
    readonly        attribute AudioParam        positionY;
    readonly        attribute AudioParam        positionZ;
    readonly        attribute AudioParam        orientationX;
    readonly        attribute AudioParam        orientationY;
    readonly        attribute AudioParam        orientationZ;
                    attribute DistanceModelType distanceModel;
                    attribute double            refDistance;
                    attribute double            maxDistance;
                    attribute double            rolloffFactor;
                    attribute double            coneInnerAngle;
                    attribute double            coneOuterAngle;
                    attribute double            coneOuterGain;
    void setPosition (float x, float y, float z);
    void setOrientation (float x, float y, float z);
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="PannerNode" data-link-for=
          "PannerNode">
            <dt>
              <code><dfn>PannerNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>PannerNode</a> object. <a href=
                "#audionode-constructor-init">Initialize</a> <var>node</var>,
                and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new <a>PannerNode</a> will
                    be <a href="#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>PannerOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>PannerNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="PannerNode" data-link-for=
          "PannerNode">
            <dt>
              <code><dfn>coneInnerAngle</dfn></code> of type <span class=
              "idlAttrType"><a><code>double</code></a></span>
            </dt>
            <dd>
              A parameter for directional audio sources, this is an angle, in
              degrees, inside of which there will be no volume reduction. The
              default value is 360. The behavior is undefined if the angle is
              outside the interval [0, 360].
            </dd>
            <dt>
              <code><dfn>coneOuterAngle</dfn></code> of type <span class=
              "idlAttrType"><a><code>double</code></a></span>
            </dt>
            <dd>
              A parameter for directional audio sources, this is an angle, in
              degrees, outside of which the volume will be reduced to a
              constant value of <a><code>coneOuterGain</code></a>. The default
              value is 360. The behavior is undefined if the angle is outside
              the interval [0, 360].
            </dd>
            <dt>
              <code><dfn>coneOuterGain</dfn></code> of type <span class=
              "idlAttrType"><a><code>double</code></a></span>
            </dt>
            <dd>
              A parameter for directional audio sources, this is the gain
              outside of the <a><code>coneOuterAngle</code></a>. The default
              value is 0. It is a linear value (not dB) in the range [0, 1]. An
              <code>InvalidStateError</code> MUST be thrown if the parameter is
              outside this range.
            </dd>
            <dt>
              <code><dfn>distanceModel</dfn></code> of type <span class=
              "idlAttrType"><a><code>DistanceModelType</code></a></span>
            </dt>
            <dd>
              Specifies the distance model used by this
              <a><code>PannerNode</code></a>. Defaults to
              <a><code>"inverse"</code></a>.
            </dd>
            <dt>
              <code><dfn>maxDistance</dfn></code> of type <span class=
              "idlAttrType"><a><code>double</code></a></span>
            </dt>
            <dd>
              The maximum distance between source and listener, after which the
              volume will not be reduced any further. The default value is
              10000. A <code>RangeError</code> exception MUST be thrown if this
              is set to a non-positive value.
            </dd>
            <dt>
              <code><dfn>orientationX</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Describes the x component of the vector of the direction the
                audio source is pointing in 3D Cartesian coordinate space.
                Depending on how directional the sound is (controlled by the
                <b>cone</b> attributes), a sound pointing away from the
                listener can be very quiet or completely silent.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a>panningModel</a> is
                      "<a data-link-for="PanningModelType">equalpower</a>" and
                      <a>k-rate</a> otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>orientationY</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Describes the y component of the vector of the direction the
                audio source is pointing in 3D cartesian coordinate space.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a>panningModel</a> is
                      "<a data-link-for="PanningModelType">equalpower</a>" and
                      <a>k-rate</a> otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>orientationZ</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Describes the Z component of the vector of the direction the
                audio source is pointing in 3D cartesian coordinate space.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a>panningModel</a> is
                      "<a data-link-for="PanningModelType">equalpower</a>" and
                      <a>k-rate</a> otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>panningModel</dfn></code> of type <span class=
              "idlAttrType"><a><code>PanningModelType</code></a></span>
            </dt>
            <dd>
              Specifies the panning model used by this
              <a><code>PannerNode</code></a>. Defaults to
              <a><code>"equalpower"</code></a>.
            </dd>
            <dt>
              <code><dfn>positionX</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>
            </dt>
            <dd>
              <p>
                Sets the x coordinate position of the audio source in a 3D
                Cartesian system. \infty)\).
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a>panningModel</a> is
                      "<a data-link-for="PanningModelType">equalpower</a>" and
                      <a>k-rate</a> otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <dfn><code>positionY</code></dfn> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>
            </dt>
            <dd>
              <p>
                Sets the y coordinate position of the audio source in a 3D
                Cartesian system.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a>panningModel</a> is
                      "<a data-link-for="PanningModelType">equalpower</a>" and
                      <a>k-rate</a> otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>positionZ</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>
            </dt>
            <dd>
              <p>
                Sets the z coordinate position of the audio source in a 3D
                Cartesian system.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a>panningModel</a> is
                      "<a data-link-for="PanningModelType">equalpower</a>" and
                      <a>k-rate</a> otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>refDistance</dfn></code> of type <span class=
              "idlAttrType"><a><code>double</code></a></span>
            </dt>
            <dd>
              A reference distance for reducing volume as source moves further
              from the listener. The default value is 1. A
              <code>RangeError</code> exception MUST be thrown if this is set
              to a non-negative value.
            </dd>
            <dt>
              <code><dfn>rolloffFactor</dfn></code> of type <span class=
              "idlAttrType"><a><code>double</code></a></span>
            </dt>
            <dd>
              <p>
                Describes how quickly the volume is reduced as source moves
                away from listener. The default value is 1.
              </p>
              <p>
                The nominal range for the <code>rolloffFactor</code> specifies
                the minimum and maximum values the <code>rolloffFactor</code>
                can have. Values outside the range are clamped to lie within
                this range. The nominal range depends on the <a data-link-for=
                "PannerNode"><code>distanceModel</code></a> as follows:
              </p>
              <dl>
                <dt>
                  <code>linear</code>
                </dt>
                <dd>
                  The nominal range is \([0, 1]\).
                </dd>
                <dt>
                  <code>inverse</code>
                </dt>
                <dd>
                  The nominal range is \([0, \infty)\).
                </dd>
                <dt>
                  <code>exponential</code>
                </dt>
                <dd>
                  The nominal range is \([0, \infty)\).
                </dd>
              </dl>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Methods
          </h3>
          <dl class="methods" data-dfn-for="PannerNode" data-link-for=
          "PannerNode">
            <dt>
              <code><dfn>setOrientation</dfn></code>
            </dt>
            <dd>
              <p>
                This method is DEPRECATED. It is equivalent to setting
                <code>orientationX</code>, <code>orientationY</code>, and
                <code>orientationZ</code> AudioParams directly.
              </p>
              <p>
                Describes which direction the audio source is pointing in the
                3D cartesian coordinate space. Depending on how directional the
                sound is (controlled by the <b>cone</b> attributes), a sound
                pointing away from the listener can be very quiet or completely
                silent.
              </p>
              <p>
                The <code>x, y, z</code> parameters represent a direction
                vector in 3D space.
              </p>
              <p>
                The default value is (1,0,0)
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    x
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
                <tr>
                  <td class="prmName">
                    y
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
                <tr>
                  <td class="prmName">
                    z
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              <code><dfn>setPosition</dfn></code>
            </dt>
            <dd>
              <p>
                This method is DEPRECATED. It is equivalent to setting
                <code>positionX</code>, <code>positionY</code>, and
                <code>positionZ</code> AudioParams directly.
              </p>
              <p>
                Sets the position of the audio source relative to the
                <a><code>listener</code></a> attribute. A 3D cartesian
                coordinate system is used.
              </p>
              <p>
                The <code>x, y, z</code> parameters represent the coordinates
                in 3D space.
              </p>
              <p>
                The default value is (0,0,0)
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    x
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
                <tr>
                  <td class="prmName">
                    y
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
                <tr>
                  <td class="prmName">
                    z
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>PannerOptions</dfn>
          </h2>
          <p>
            This specifies options for constructing a
            <a><code>PannerNode</code></a>. All members are optional; if not
            specified, the normal default is used in constructing the node.
          </p>
          <pre class="idl">
dictionary PannerOptions : AudioNodeOptions {
             PanningModelType  panningModel = "equalpower";
             DistanceModelType distanceModel = "inverse";
             float             positionX = 0;
             float             positionY = 0;
             float             positionZ = 0;
             float             orientationX = 1;
             float             orientationY = 0;
             float             orientationZ = 0;
             double            refDistance = 1;
             double            maxDistance = 10000;
             double            rolloffFactor = 1;
             double            coneInnerAngle = 360;
             double            coneOuterAngle = 360;
             double            coneOuterGain = 0;
};
          </pre>
          <section>
            <h3>
              Dictionary <a>PannerOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="PannerOptions" data-link-for=
            "PannerOptions">
              <dt>
                <code><dfn>coneInnerAngle</dfn></code> of type <span class=
                "idlAttrType"><code>double</code></span>, defaulting to 360
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "PannerNode"><code>coneInnerAngle</code></a> attribute of the
                node.
              </dd>
              <dt>
                <code><dfn>coneOuterAngle</dfn></code> of type <span class=
                "idlAttrType"><code>double</code></span>, defaulting to 360
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "PannerNode"><code>coneOuterAngle</code></a> attribute of the
                node.
              </dd>
              <dt>
                <code><dfn>coneOuterGain</dfn></code> of type <span class=
                "idlAttrType"><code>double</code></span>, defaulting to 0
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "PannerNode"><code>coneOuterGain</code></a> attribute of the
                node.
              </dd>
              <dt>
                <code><dfn>distanceModel</dfn></code> of type <span class=
                "idlAttrType"><code>DistanceModel</code></span>, defaulting to
                "inverse"
              </dt>
              <dd>
                The distance model to use for the node.
              </dd>
              <dt>
                <code><dfn>maxDistance</dfn></code> of type <span class=
                "idlAttrType"><code>double</code></span>, defaulting to 10000
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "PannerNode"><code>maxDistance</code></a> attribute of the
                node.
              </dd>
              <dt>
                <code><dfn>orientationX</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 1
              </dt>
              <dd>
                The initial X value for the <a data-link-for=
                "PannerNode"><code>orientationX</code></a> AudioParam.
              </dd>
              <dt>
                <code><dfn>orientationY</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 0
              </dt>
              <dd>
                The initial Y value for the <a data-link-for=
                "PannerNode"><code>orientationY</code></a> AudioParam.
              </dd>
              <dt>
                <code><dfn>orientationZ</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 0
              </dt>
              <dd>
                The initial Z value for the <a data-link-for=
                "PannerNode"><code>orientationZ</code></a> AudioParam.
              </dd>
              <dt>
                <code><dfn>panningModel</dfn></code> of type <span class=
                "idlAttrType"><code>PanningModelType</code></span>, defaulting
                to "equalpower"
              </dt>
              <dd>
                The panning model to use for the node.
              </dd>
              <dt>
                <code><dfn>positionX</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 0
              </dt>
              <dd>
                The initial X value for the <a data-link-for=
                "PannerNode"><code>positionX</code></a> AudioParam.
              </dd>
              <dt>
                <code><dfn>positionY</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 0
              </dt>
              <dd>
                The initial Y value for the <a data-link-for=
                "PannerNode"><code>positionY</code></a> AudioParam.
              </dd>
              <dt>
                <code><dfn>positionZ</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 0
              </dt>
              <dd>
                The initial Z value for the <a data-link-for=
                "PannerNode"><code>positionZ</code></a> AudioParam.
              </dd>
              <dt>
                <code><dfn>refDistance</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 1
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "PannerNode"><code>refDistance</code></a> attribute of the
                node.
              </dd>
              <dt>
                <code><dfn>rolloffFactor</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 1
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "PannerNode"><code>rolloffFactor</code></a> attribute of the
                node.
              </dd>
            </dl>
          </section>
        </section>
        <section class="informative">
          <h3 id="panner-channel-limitations">
            Channel Limitations
          </h3>
          <p>
            The set of <a href="#panner-channel-limitations">channel
            limitations</a> for <a><code>StereoPannerNode</code></a> also apply
            to <a><code>PannerNode</code></a>.
          </p>
        </section>
      </section>
      <section>
        <h2 id="AudioListener">
          The <dfn>AudioListener</dfn> Interface
        </h2>
        <p>
          This interface represents the position and orientation of the person
          listening to the audio scene. All <a><code>PannerNode</code></a>
          objects spatialize in relation to the
          <a><code>BaseAudioContext</code></a>'s <a data-link-for=
          "BaseAudioContext">listener</a>. See <a>Spatialization/Panning</a>
          for more details about spatialization.
        </p>
        <p>
          The <code>positionX, positionY, positionZ</code> parameters represent
          the location of the listener in 3D Cartesian coordinate space.
          <a><code>PannerNode</code></a> objects use this position relative to
          individual audio sources for spatialization.
        </p>
        <p>
          The <code>forwardX, forwardY, forwardZ</code> parameters represent a
          direction vector in 3D space. Both a <code>forward</code> vector and
          an <code>up</code> vector are used to determine the orientation of
          the listener. In simple human terms, the <code>forward</code> vector
          represents which direction the person's nose is pointing. The
          <code>up</code> vector represents the direction the top of a person's
          head is pointing. These values are expected to be linearly
          independent (at right angles to each other), and unpredictable
          behavior may result if they are not. For normative requirements of
          how these values are to be interpreted, see the
          <a>Spatialization/Panning</a> section.
        </p>
        <pre class="idl">
[Exposed=Window]
interface AudioListener {
    readonly        attribute AudioParam positionX;
    readonly        attribute AudioParam positionY;
    readonly        attribute AudioParam positionZ;
    readonly        attribute AudioParam forwardX;
    readonly        attribute AudioParam forwardY;
    readonly        attribute AudioParam forwardZ;
    readonly        attribute AudioParam upX;
    readonly        attribute AudioParam upY;
    readonly        attribute AudioParam upZ;
    void setPosition (float x, float y, float z);
    void setOrientation (float x, float y, float z, float xUp, float yUp, float zUp);
};
        </pre>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="AudioListener" data-link-for=
          "AudioListener">
            <dt>
              <code><dfn>forwardX</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Sets the x coordinate component of the forward direction the
                listener is pointing in 3D Cartesian coordinate space.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a data-link-for=
                      "PannerNode">panningModel</a> is "<a data-link-for=
                      "PanningModelType">equalpower</a>" and <a>k-rate</a>
                      otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>forwardY</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Sets the y coordinate component of the forward direction the
                listener is pointing in 3D Cartesian coordinate space.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a data-link-for=
                      "PannerNode">panningModel</a> is "<a data-link-for=
                      "PanningModelType">equalpower</a>" and <a>k-rate</a>
                      otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>forwardZ</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Sets the z coordinate component of the forward direction the
                listener is pointing in 3D Cartesian coordinate space.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      -1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a data-link-for=
                      "PannerNode">panningModel</a> is "<a data-link-for=
                      "PanningModelType">equalpower</a>" and <a>k-rate</a>
                      otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>positionX</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Sets the x coordinate position of the audio listener in a 3D
                Cartesian coordinate space.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a data-link-for=
                      "PannerNode">panningModel</a> is "<a data-link-for=
                      "PanningModelType">equalpower</a>" and <a>k-rate</a>
                      otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>positionY</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Sets the y coordinate position of the audio listener in a 3D
                Cartesian coordinate space.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a data-link-for=
                      "PannerNode">panningModel</a> is "<a data-link-for=
                      "PanningModelType">equalpower</a>" and <a>k-rate</a>
                      otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>positionZ</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Sets the z coordinate position of the audio listener in a 3D
                Cartesian coordinate space.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a data-link-for=
                      "PannerNode">panningModel</a> is "<a data-link-for=
                      "PanningModelType">equalpower</a>" and <a>k-rate</a>
                      otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>upX</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Sets the x coordinate component of the up direction the
                listener is pointing in 3D Cartesian coordinate space.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a data-link-for=
                      "PannerNode">panningModel</a> is "<a data-link-for=
                      "PanningModelType">equalpower</a>" and <a>k-rate</a>
                      otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>upY</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Sets the y coordinate component of the up direction the
                listener is pointing in 3D Cartesian coordinate space.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a data-link-for=
                      "PannerNode">panningModel</a> is "<a data-link-for=
                      "PanningModelType">equalpower</a>" and <a>k-rate</a>
                      otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>upZ</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                Sets the z coordinate component of the up direction the
                listener is pointing in 3D Cartesian coordinate space.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td></td>
                    <td>
                      <a>a-rate</a> when <a data-link-for=
                      "PannerNode">panningModel</a> is "<a data-link-for=
                      "PanningModelType">equalpower</a>" and <a>k-rate</a>
                      otherwise.
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Methods
          </h3>
          <dl class="methods" data-dfn-for="AudioListener" data-link-for=
          "AudioListener">
            <dt>
              <code><dfn>setOrientation</dfn></code>
            </dt>
            <dd>
              <p>
                This method is DEPRECATED. It is equivalent to setting
                <code>orientationX.value</code>,
                <code>orientationY.value</code>,
                <code>orientationZ.value</code>, <code>upX.value</code>,
                <code>upY.value</code>, and <code>upZ.value</code> directly
                with the given <code>x</code>, <code>y</code>, <code>z</code>,
                <code>xUp</code>, <code>yUp</code>, and <code>zUp</code>
                values, respectively.
              </p>
              <p>
                Describes which direction the listener is pointing in the 3D
                cartesian coordinate space. Both a <b>front</b> vector and an
                <b>up</b> vector are provided. In simple human terms, the
                <b>front</b> vector represents which direction the person's
                nose is pointing. The <b>up</b> vector represents the direction
                the top of a person's head is pointing. These values are
                expected to be linearly independent (at right angles to each
                other). For normative requirements of how these values are to
                be interpreted, see the <a href=
                "#Spatialization">spatialization section</a>.
              </p>
              <p>
                The <code>x, y, z</code> parameters represent a <b>front</b>
                direction vector in 3D space, with the default value being
                (0,0,-1).
              </p>
              <p>
                The <code>xUp, yUp, zUp</code> parameters represent an
                <b>up</b> direction vector in 3D space, with the default value
                being (0,1,0).
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    x
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
                <tr>
                  <td class="prmName">
                    y
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
                <tr>
                  <td class="prmName">
                    z
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
                <tr>
                  <td class="prmName">
                    xUp
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
                <tr>
                  <td class="prmName">
                    yUp
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
                <tr>
                  <td class="prmName">
                    zUp
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              <code><dfn>setPosition</dfn></code>
            </dt>
            <dd>
              <p>
                This method is DEPRECATED. It is equivalent to setting
                <code>positionX.value</code>, <code>positionY.value</code>, and
                <code>positionZ.value</code> directly with the given
                <code>x</code>, <code>y</code>, and <code>z</code> values,
                respectively.
              </p>
              <p>
                Sets the position of the listener in a 3D cartesian coordinate
                space. <a><code>PannerNode</code></a> objects use this position
                relative to individual audio sources for spatialization.
              </p>
              <p>
                The <code>x, y, z</code> parameters represent the coordinates
                in 3D space.
              </p>
              <p>
                The default value is (0,0,0)
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    x
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
                <tr>
                  <td class="prmName">
                    y
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
                <tr>
                  <td class="prmName">
                    z
                  </td>
                  <td class="prmType">
                    <a><code>float</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h2>
          The StereoPannerNode Interface
        </h2>
        <p>
          This interface represents a processing node which positions an
          incoming audio stream in a stereo image using a low-cost <a href=
          "#Spatialzation-equal-power-panning">equal-power panning
          algorithm</a>. This panning effect is common in positioning audio
          components in a stereo stream.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                2
              </td>
              <td>
                Has <a>channelCount constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">clamped-max</a>"
              </td>
              <td>
                Has <a>channelCountMode constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <p>
          The input of this node is stereo (2 channels) and cannot be
          increased. Connections from nodes with fewer or more channels will be
          <a href="#channel-up-mixing-and-down-mixing">up-mixed or down-mixed
          appropriately</a>.
        </p>
        <p>
          The output of this node is hard-coded to stereo (2 channels) and
          cannot be configured.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional StereoPannerOptions options)]
interface StereoPannerNode : AudioNode {
    readonly        attribute AudioParam pan;
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="StereoPannerNode" data-link-for=
          "StereoPannerNode">
            <dt>
              <code><dfn>StereoPannerNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>StereoStereoPannerNode</a>
                object. <a href="#audionode-constructor-init">Initialize</a>
                <var>node</var>, and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new
                    <a>StereoPannerNode</a> will be <a href=
                    "#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>StereoPannerOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>StereoPannerNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="StereoPannerNode" data-link-for=
          "StereoPannerNode">
            <dt>
              <code><dfn>pan</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                The position of the input in the output's stereo image. -1
                represents full left, +1 represents full right.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      -1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>a-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>StereoPannerOptions</dfn>
          </h2>
          <p>
            This specifies the options to use in constructing a
            <a><code>StereoPannerNode</code></a>. All members are optional; if
            not specified, the normal default is used in constructing the node.
          </p>
          <pre class="idl">
dictionary StereoPannerOptions : AudioNodeOptions {
             float pan = 0;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>StereoPannerOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="StereoPannerOptions"
            data-link-for="StereoPannerOptions">
              <dt>
                <code><dfn>pan</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 0
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "StereoPannerNode"><code>pan</code></a> AudioParam.
              </dd>
            </dl>
          </section>
        </section>
        <section class="informative">
          <h3>
            Channel Limitations
          </h3>
          <p>
            Because its processing is constrained by the above definitions,
            <a><code>StereoPannerNode</code></a> is limited to mixing no more
            than 2 channels of audio, and producing exactly 2 channels. It is
            possible to use a <a><code>ChannelSplitterNode</code></a>,
            intermediate processing by a subgraph of
            <a><code>GainNode</code></a>s and/or other nodes, and recombination
            via a <a><code>ChannelMergerNode</code></a> to realize arbitrary
            approaches to panning and mixing.
          </p>
        </section>
      </section>
      <section>
        <h2 id="ConvolverNode">
          The ConvolverNode Interface
        </h2>
        <p>
          This interface represents a processing node which applies a linear
          convolution effect given an impulse response.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                2
              </td>
              <td>
                Has <a>channelCount constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">clamped-max</a>"
              </td>
              <td>
                Has <a>channelCountMode constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                Yes
              </td>
              <td>
                Continues to output non-silent audio with zero input for the
                length of the <a data-link-for="ConvolverNode">buffer</a>.
              </td>
            </tr>
          </table>
        </div>
        <p>
          The input of this node is either mono (1 channel) or stereo (2
          channels) and cannot be increased. Connections from nodes with more
          channels will be <a href=
          "#channel-up-mixing-and-down-mixing">down-mixed appropriately</a>.
        </p>
        <p>
          There are <a>channelCount constraints</a> and <a>channelCountMode
          constraints</a> for this node. These constraints ensure that the
          input to the node is either mono or stereo.
        </p>
        <p>
          <a>ConvolverNode</a>s are created with an internal flag <code>buffer
          set</code>, initially set to false.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional ConvolverOptions options)]
interface ConvolverNode : AudioNode {
                    attribute AudioBuffer? buffer;
                    attribute boolean      normalize;
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="ConvolverNode" data-link-for=
          "ConvolverNode">
            <dt>
              <code><dfn>ConvolverNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>ConvolverNode</a> object.
                <a href="#audionode-constructor-init">Initialize</a>
                <var>node</var>. Set an internal boolean slot <var>[[buffer
                set]]</var>, and initialize it to <code>false</code>. Return
                <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new <a>ConvolverNode</a>
                    will be <a href="#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>ConvolverOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>ConvolverNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="ConvolverNode" data-link-for=
          "ConvolverNode">
            <dt>
              <code><dfn>buffer</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioBuffer</code></a></span>, nullable
            </dt>
            <dd>
              <p>
                A mono, stereo, or 4-channel <a><code>AudioBuffer</code></a>
                containing the (possibly multi-channel) impulse response used
                by the <a><code>ConvolverNode</code></a>. <span class=
                "synchronous">The <code>AudioBuffer</code> MUST have 1, 2, or 4
                channels or a <code>NotSupportedError</code> exception MUST be
                thrown</span>. <span class="synchronous">This
                <a><code>AudioBuffer</code></a> MUST be of the same sample-rate
                as the <a><code>AudioContext</code></a> or a
                <code>NotSupportedError</code> exception MUST be thrown</span>.
                At the time when this attribute is set, the <em>buffer</em> and
                the state of the <em>normalize</em> attribute will be used to
                configure the <a><code>ConvolverNode</code></a> with this
                impulse response having the given normalization. The initial
                value of this attribute is null.
              </p>
              <p>
                To set the <code>buffer</code> attribute, execute these steps:
              </p>
              <ol>
                <li>Let <code>new buffer</code> be the <a>AudioBuffer</a> to be
                assigned to <code>buffer</code>.
                </li>
                <li>If <code>new buffer</code> is not <code>null</code> and
                <var>[[buffer set]]</var> is true, <span class=
                "synchronous">throw an <code>InvalidStateError</code> and abort
                these steps</span>.
                </li>
                <li>If <code>new buffer</code> is not <code>null</code>, set
                <var>[[buffer set]]</var> to true.
                </li>
                <li>Assign <code>new buffer</code> to the <code>buffer</code>
                attribute.
                </li>
              </ol>
              <p class="norm">
                <em>The following text is non-normative. For normative
                information please see the <a href=
                "#Convolution-channel-configurations">channel configuration
                diagrams</a>.</em>
              </p>
              <p>
                The <a>ConvolverNode</a> only produces a mono output in the
                single case where there is a single input channel and a
                single-channel <code>buffer</code>. In all other cases, the
                output is stereo. In particular, when the <code>buffer</code>
                has four channels and there are two input channels, the
                <a>ConvolverNode</a> performs matrix "true" stereo convolution.
              </p>
            </dd>
            <dt>
              <code><dfn>normalize</dfn></code> of type <span class=
              "idlAttrType"><a><code>boolean</code></a></span>
            </dt>
            <dd>
              <p>
                Controls whether the impulse response from the buffer will be
                scaled by an equal-power normalization when the
                <code>buffer</code> atttribute is set. Its default value is
                <code>true</code> in order to achieve a more uniform output
                level from the convolver when loaded with diverse impulse
                responses. If <code>normalize</code> is set to
                <code>false</code>, then the convolution will be rendered with
                no pre-processing/scaling of the impulse response. Changes to
                this value do not take effect until the next time the
                <em>buffer</em> attribute is set.
              </p>
              <p>
                If the <em>normalize</em> attribute is false when the
                <em>buffer</em> attribute is set then the
                <a><code>ConvolverNode</code></a> will perform a linear
                convolution given the exact impulse response contained within
                the <em>buffer</em>.
              </p>
              <p>
                Otherwise, if the <em>normalize</em> attribute is true when the
                <em>buffer</em> attribute is set then the
                <a><code>ConvolverNode</code></a> will first perform a scaled
                RMS-power analysis of the audio data contained within
                <em>buffer</em> to calculate a <em>normalizationScale</em>
                given this algorithm:
              </p>
              <pre>

function calculateNormalizationScale(buffer)
{
    var GainCalibration = 0.00125;
    var GainCalibrationSampleRate = 44100;
    var MinPower = 0.000125;

    // Normalize by RMS power.
    var numberOfChannels = buffer.numberOfChannels;
    var length = buffer.length;

    var power = 0;

    for (var i = 0; i &lt; numberOfChannels; i++) {
        var channelPower = 0;
        var channelData = buffer.getChannelData(i);

        for (var j = 0; j &lt; length; j++) {
            var sample = channelData[j];
            channelPower += sample * sample;
        }

        power += channelPower;
    }

    power = Math.sqrt(power / (numberOfChannels * length));

    // Protect against accidental overload.
    if (!isFinite(power) || isNaN(power) || power &lt; MinPower)
        power = MinPower;

    var scale = 1 / power;

    // Calibrate to make perceived volume same as unprocessed.
    scale *= GainCalibration;

    // Scale depends on sample-rate.
    if (buffer.sampleRate)
        scale *= GainCalibrationSampleRate / buffer.sampleRate;

    // True-stereo compensation.
    if (numberOfChannels == 4)
        scale *= 0.5;

    return scale;
}

</pre>
              <p>
                During processing, the ConvolverNode will then take this
                calculated <em>normalizationScale</em> value and multiply it by
                the result of the linear convolution resulting from processing
                the input with the impulse response (represented by the
                <em>buffer</em>) to produce the final output. Or any
                mathematically equivalent operation may be used, such as
                pre-multiplying the input by <em>normalizationScale</em>, or
                pre-multiplying a version of the impulse-response by
                <em>normalizationScale</em>.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>ConvolverOptions</dfn>
          </h2>
          <p>
            The specifies options for constructing a
            <a><code>ConvolverNode</code></a>. All members are optional; if not
            specified, the node is contructing using the normal defaults.
          </p>
          <pre class="idl">
dictionary ConvolverOptions : AudioNodeOptions {
             AudioBuffer? buffer;
             boolean      disableNormalization = false;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>ConvolverOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="ConvolverOptions"
            data-link-for="ConvolverOptions">
              <dt>
                <code><dfn>buffer</dfn></code> of type <span class=
                "idlAttrType"><code>AudioBuffer</code></span>, nullable
              </dt>
              <dd>
                The desired buffer for the <a><code>ConvolverNode</code></a>.
                This buffer will be normalized according to the value of
                <code>disableNormalization</code>.
              </dd>
              <dt>
                <code><dfn>disableNormalization</dfn></code> of type
                <span class="idlAttrType"><code>boolean</code></span>,
                defaulting to false
              </dt>
              <dd>
                The opposite of the desired initial value for the
                <a data-link-for="ConvolverNode"><code>normalize</code></a>
                attribute of the <a><code>ConvolverNode</code></a>.
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h3 id="Convolution-channel-configurations">
            Channel Configurations for Input, Impulse Response and Output
          </h3>
          <p>
            Implementations MUST support the following allowable configurations
            of impulse response channels in a <a><code>ConvolverNode</code></a>
            to achieve various reverb effects with 1 or 2 channels of input.
          </p>
          <p>
            The first image in the diagram illustrates the general case, where
            the source has N input channels, the impulse response has K
            channels, and the playback system has M output channels. Because
            <a><code>ConvolverNode</code></a> is limited to 1 or 2 channels of
            input, not every case can be handled.
          </p>
          <p>
            Single channel convolution operates on a mono audio input, using a
            mono impulse response, and generating a mono output. The remaining
            images in the diagram illustrate the supported cases for mono and
            stereo playback where N and M are 1 or 2 and K is 1, 2, or 4.
            Developers desiring more complex and arbitrary matrixing can use a
            <a><code>ChannelSplitterNode</code></a>, multiple single-channel
            <a><code>ConvolverNode</code></a>s and a
            <a><code>ChannelMergerNode</code></a>.
          </p>
          <figure id="convolver-diagram">
            <img alt="reverb matrixing" src="images/convolver-diagram.png">
            <figcaption>
              A graphical representation of supported input and output channel
              count possibilities when using a
              <a><code>ConvolverNode</code></a>.
            </figcaption>
          </figure>
        </section>
      </section>
      <section>
        <h2>
          The AnalyserNode Interface
        </h2>
        <p>
          This interface represents a node which is able to provide real-time
          frequency and time-domain analysis information. The audio stream will
          be passed un-processed from input to output.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td>
                This output may be left unconnected.
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                2
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">max</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional AnalyserOptions options)]
interface AnalyserNode : AudioNode {
    void getFloatFrequencyData (Float32Array array);
    void getByteFrequencyData (Uint8Array array);
    void getFloatTimeDomainData (Float32Array array);
    void getByteTimeDomainData (Uint8Array array);
                    attribute unsigned long fftSize;
    readonly        attribute unsigned long frequencyBinCount;
                    attribute double        minDecibels;
                    attribute double        maxDecibels;
                    attribute double        smoothingTimeConstant;
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="AnalyserNode" data-link-for=
          "AnalyserNode">
            <dt>
              <code><dfn>AnalyserNode</dfn></code>
            </dt>
            <dd>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new <a>AnalyserNode</a>
                    will be <a href="#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>AnalyserOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>AnalyserNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="AnalyserNode" data-link-for=
          "AnalyserNode">
            <dt>
              <code><dfn>fftSize</dfn></code> of type <span class=
              "idlAttrType"><a><code>unsigned long</code></a></span>
            </dt>
            <dd>
              <p>
                The size of the FFT used for frequency-domain analysis.
                <span class="synchronous">This MUST be a power of two in the
                range 32 to 32768, otherwise an <code>IndexSizeError</code>
                exception MUST be thrown</span>. The default value is 2048.
                Note that large FFT sizes can be costly to compute.
              </p>
              <p>
                If the <code>fftSize</code> is changed to a different value,
                then all state associated with smoothing of the frequency data
                (for <a data-link-for=
                "AnalyserNode"><code>getByteFrequencyData</code></a> and
                <a data-link-for=
                "AnalyserNode"><code>getFloatFrequencyData</code></a>) is
                reset. That is the <a>previous block</a>, \(\hat{X}_{-1}[k]\),
                used for <a href="#smoothing-over-time">smoothing over time</a>
                is set to 0 for all \(k\).
              </p>
            </dd>
            <dt>
              <code><dfn>frequencyBinCount</dfn></code> of type <span class=
              "idlAttrType"><a><code>unsigned long</code></a></span>, readonly
            </dt>
            <dd>
              Half the FFT size.
            </dd>
            <dt>
              <code><dfn>maxDecibels</dfn></code> of type <span class=
              "idlAttrType"><a><code>double</code></a></span>
            </dt>
            <dd>
              <a>maxDecibels</a> is the maximum power value in the scaling
              range for the FFT analysis data for conversion to unsigned byte
              values. The default value is -30. <span class="synchronous">If
              the value of this attribute is set to a value less than or equal
              to <code><a>minDecibels</a></code>, an
              <code>IndexSizeError</code> exception MUST be thrown.</span>
            </dd>
            <dt>
              <code><dfn>minDecibels</dfn></code> of type <span class=
              "idlAttrType"><a><code>double</code></a></span>
            </dt>
            <dd>
              <a>minDecibels</a> is the minimum power value in the scaling
              range for the FFT analysis data for conversion to unsigned byte
              values. The default value is -100. <span class="synchronous">If
              the value of this attribute is set to a value more than or equal
              to <code><a>maxDecibels</a></code>, an
              <code>IndexSizeError</code> exception MUST be thrown.</span>
            </dd>
            <dt>
              <code><dfn>smoothingTimeConstant</dfn></code> of type
              <span class="idlAttrType"><a><code>double</code></a></span>
            </dt>
            <dd>
              A value from 0 -&gt; 1 where 0 represents no time averaging with
              the last analysis frame. The default value is 0.8. <span class=
              "synchronous">If the value of this attribute is set to a value
              less than 0 or more than 1, an <code>IndexSizeError</code>
              exception MUST be thrown.</span>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Methods
          </h3>
          <dl class="methods" data-dfn-for="AnalyserNode" data-link-for=
          "AnalyserNode">
            <dt>
              <code><dfn>getByteFrequencyData</dfn></code>
            </dt>
            <dd>
              <p>
                Copies the <a>current frequency data</a> into the passed
                unsigned byte array. If the array has fewer elements than the
                <a><code>frequencyBinCount</code></a>, the excess elements will
                be dropped. If the array has more elements than the
                <a><code>frequencyBinCount</code></a>, the excess elements will
                be ignored. The most recent <a data-link-for=
                "AnalyserNode"><code>fftSize</code></a> frames are used in
                computing the frequency data.
              </p>
              <p>
                If another call to <code>getByteFreqencyData</code> or
                <code>getFloatFrequencyData</code> occurs within the same
                <a>render quantum</a> as a previous call, the <a>current
                frequency data</a> is not updated with the same data. Instead,
                the previously computed data is returned.
              </p>
              <p>
                The values stored in the unsigned byte array are computed in
                the following way. Let \(Y[k]\) be the <a>current frequency
                data</a> as described in <a href=
                "#fft-windowing-and-smoothing-over-time">FFT windowing and
                smoothing</a>. Then the byte value, \(b[k]\), is
              </p>
              <pre class="nohighlight">
                  $$
                    b[k] = \left\lfloor
                        \frac{255}{\mbox{dB}_{max} - \mbox{dB}_{min}}
                        \left(Y[k] - \mbox{dB}_{min}\right)
                      \right\rfloor
                  $$
</pre>
              <p>
                where \(\mbox{dB}_{min}\) is <code><a>minDecibels</a></code>
                and \(\mbox{dB}_{max}\) is <code><a>maxDecibels</a></code>. If
                \(b[k]\) lies outside the range of 0 to 255, \(b[k]\) is
                clipped to lie in that range.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    array
                  </td>
                  <td class="prmType">
                    <a><code>Uint8Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    This parameter is where the frequency-domain analysis data
                    will be copied.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              <code><dfn>getByteTimeDomainData</dfn></code>
            </dt>
            <dd>
              <p>
                Copies the current down-mixed time-domain (waveform) data into
                the passed unsigned byte array. If the array has fewer elements
                than the value of <a data-link-for=
                "AnalyserNode"><code>fftSize</code></a>, the excess elements
                will be dropped. If the array has more elements than
                <a data-link-for="AnalyserNode"><code>fftSize</code></a>, the
                excess elements will be ignored. The most recent
                <a data-link-for="AnalyserNode"><code>fftSize</code></a> frames
                are used in computing the byte data.
              </p>
              <p>
                The values stored in the unsigned byte array are computed in
                the following way. Let \(x[k]\) be the time-domain data. Then
                the byte value, \(b[k]\), is
              </p>
              <pre class="nohighlight">
              $$
                b[k] = \left\lfloor 128(1 + x[k]) \right\rfloor.
              $$
</pre>
              <p>
                If \(b[k]\) lies outside the range 0 to 255, \(b[k]\) is
                clipped to lie in that range.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    array
                  </td>
                  <td class="prmType">
                    <a><code>Uint8Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    This parameter is where the time-domain sample data will be
                    copied.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              <code><dfn>getFloatFrequencyData</dfn></code>
            </dt>
            <dd>
              <p>
                Copies the <a>current frequency data</a> into the passed
                floating-point array. If the array has fewer elements than the
                <a><code>frequencyBinCount</code></a>, the excess elements will
                be dropped. If the array has more elements than the
                <a><code>frequencyBinCount</code></a>, the excess elements will
                be ignored. The most recent <a data-link-for=
                "AnalyserNode"><code>fftSize</code></a> frames are used in
                computing the frequency data.
              </p>
              <p>
                If another call to <code>getFloatFrequencyData</code> or
                <code>getByteFrequencyData</code> occurs within the same
                <a>render quantum</a> as a previous call, the <a>current
                frequency data</a> is not updated with the same data. Instead,
                the previously computed data is returned.
              </p>
              <p>
                The frequency data are in dB units.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    array
                  </td>
                  <td class="prmType">
                    <a><code>Float32Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    This parameter is where the frequency-domain analysis data
                    will be copied.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt>
              <code><dfn>getFloatTimeDomainData</dfn></code>
            </dt>
            <dd>
              <p>
                Copies the current down-mixed time-domain (waveform) data into
                the passed floating-point array. If the array has fewer
                elements than the value of <a data-link-for=
                "AnalyserNode"><code>fftSize</code></a>, the excess elements
                will be dropped. If the array has more elements than
                <a data-link-for="AnalyserNode"><code>fftSize</code></a>, the
                excess elements will be ignored. The most recent
                <a data-link-for="AnalyserNode"><code>fftSize</code></a> frames
                are returned (after downmixing).
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    array
                  </td>
                  <td class="prmType">
                    <a><code>Float32Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    This parameter is where the time-domain sample data will be
                    copied.
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>AnalyserOptions</dfn>
          </h2>
          <p>
            This specifies the options to be used when constructing an
            <a><code>AnalyserNode</code></a>. All members are optional; if not
            specified, the normal default values are used to construct the
            node.
          </p>
          <pre class="idl">
dictionary AnalyserOptions : AudioNodeOptions {
             unsigned long fftSize = 2048;
             double        maxDecibels = -30;
             double        minDecibels = -100;
             double        smoothingTimeConstant = 0.8;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>AnalyserOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="AnalyserOptions"
            data-link-for="AnalyserOptions">
              <dt>
                <code><dfn>fftSize</dfn></code> of type <span class=
                "idlAttrType"><code>unsigned long</code></span>, defaulting to
                2048
              </dt>
              <dd>
                The desired initial size of the FFT for frequency-domain
                analysis.
              </dd>
              <dt>
                <code><dfn>maxDecibels</dfn></code> of type <span class=
                "idlAttrType"><code>double</code></span>, defaulting to -30
              </dt>
              <dd>
                The desired initial maximum power in dB for FFT analysis.
              </dd>
              <dt>
                <code><dfn>minDecibels</dfn></code> of type <span class=
                "idlAttrType"><code>double</code></span>, defaulting to -100
              </dt>
              <dd>
                The desired initial minimum power in dB for FFT analysis.
              </dd>
              <dt>
                <code><dfn>smoothingTimeConstant</dfn></code> of type
                <span class="idlAttrType"><code>unsigned long</code></span>,
                defaulting to 0.8
              </dt>
              <dd>
                The desired initial smoothing constant for the FFT analysis.
              </dd>
            </dl>
          </section>
        </section>
        <section data-link-for="AnalyserNode">
          <h3>
            FFT Windowing and smoothing over time
          </h3>When the <dfn id="current-frequency-data">current frequency
          data</dfn> are computed, the following operations are to be
          performed:
          <ol>
            <li>
              <a href="#channel-up-mixing-and-down-mixing">Down-mix</a> all
              channels of the time domain input data to mono assuming a
              <a data-link-for="AudioNode">channelCount</a> of 1,
              <a data-link-for="AudioNode">channelCountMode</a> of
              "<a data-link-for="ChannelCountMode">max</a>" and
              <a data-link-for="AudioNode">channelInterpretation</a> of
              "<a data-link-for="ChannelInterpretation">speakers</a>". This is
              independent of the settings for the <a>AnalyserNode</a> itself.
              The most recent <a data-link-for="AnalyserNode">fftSize</a>
              frames are used for the down-mixing operation.
            </li>
            <li>
              <a href="#blackman-window">Apply a Blackman window</a> to the
              time domain input data.
            </li>
            <li>
              <a href="#fourier-transform">Apply a Fourier transform</a> to the
              windowed time domain input data to get imaginary and real
              frequency data.
            </li>
            <li>
              <a href="#smoothing-over-time">Smooth over time</a> the frequency
              domain data.
            </li>
            <li>
              <a href="#conversion-to-db">Conversion to dB</a>.
            </li>
          </ol>
          <p>
            In the following, let \(N\) be the value of the
            <code>.fftSize</code> attribute of this <code>AnalyserNode</code>.
          </p>
          <p>
            <dfn id="blackman-window">Applying a Blackman window</dfn> consists
            in the following operation on the input time domain data. Let
            \(x[n]\) for \(n = 0, \ldots, N - 1\) be the time domain data. The
            Blackman window is defined by
          </p>
          <pre class="nohighlight">
          $$
          \begin{align*}
            \alpha &amp;= \mbox{0.16} \\ a_0 &amp;= \frac{1-\alpha}{2} \\
             a_1   &amp;= \frac{1}{2} \\
             a_2   &amp;= \frac{\alpha}{2} \\
             w[n] &amp;= a_0 - a_1 \cos\frac{2\pi n}{N} + a_2 \cos\frac{4\pi n}{N}, \mbox{ for } n = 0, \ldots, N - 1
           \end{align*}
           $$

</pre>
          <p>
            The windowed signal \(\hat{x}[n]\) is
          </p>
          <pre class="nohighlight">
            $$
              \hat{x}[n] = x[n] w[n], \mbox{ for } n = 0, \ldots, N - 1
            $$

</pre>
          <p>
            <dfn id="fourier-transform">Applying a Fourier transform</dfn>
            consists of computing the Fourier transform in the following way.
            Let \(X[k]\) be the complex frequency domain data and
            \(\hat{x}[n]\) be the windowed time domain data computed above.
            Then
          </p>
          <pre class="nohighlight">
            $$
              X[k] = \frac{1}{N} \sum_{n = 0}^{N - 1} \hat{x}[n]\, e^{\frac{-2\pi i k n}{N}}
            $$
</pre>
          <p>
            for \(k = 0, \dots, N/2-1\).
          </p>
          <p>
            <dfn id="smoothing-over-time">Smoothing over time</dfn> frequency
            data consists in the following operation:
          </p>
          <ul>
            <li>Let \(\hat{X}_{-1}[k]\) be the result of this operation on the
            <a>previous block</a>. The <dfn>previous block</dfn> is defined as
            being the buffer computed by the previous <a href=
            "#smoothing-over-time">smoothing over time</a> operation, or an
            array of \(N\) zeros if this is the first time we are <a href=
            "#smoothing-over-time">smoothing over time</a>.
            </li>
            <li>Let \(\tau\) be the value of the <a data-link-for=
            "AnalyserNode"><code>smoothingTimeConstant</code></a> attribute for
            this <a><code>AnalyserNode</code></a>.
            </li>
            <li>Let \(X[k]\) be the result of <a href=
            "#fourier-transform">applying a Fourier transform</a> of the
            current block.
            </li>
          </ul>
          <p>
            Then the smoothed value, \(\hat{X}[k]\), is computed by
          </p>
          <pre class="nohighlight">
            $$
              \hat{X}[k] = \tau\, \hat{X}_{-1}[k] + (1 - \tau)\, |X[k]|
            $$

</pre>
          <p>
            for \(k = 0, \ldots, N - 1\).
          </p>
          <p>
            <dfn id="conversion-to-db">Conversion to dB</dfn> consists of the
            following operation, where \(\hat{X}[k]\) is computed in <a href=
            "#smoothing-over-time">smoothing over time</a>:
          </p>
          <pre class="nohighlight">
          $$
            Y[k] = 20\log_{10}\hat{X}[k]
          $$

</pre>
          <p>
            for \(k = 0, \ldots, N-1\).
          </p>
          <p>
            This array, \(Y[k]\), is copied to the output array for
            <code>getFloatFrequencyData</code>. For
            <code>getByteFrequencyData</code>, the \(Y[k]\) is clipped to lie
            between <code><a>minDecibels</a></code> and
            <code><a>maxDecibels</a></code> and then scaled to fit in an
            unsigned byte such that <code><a>minDecibels</a></code> is
            represented by the value 0 and <code><a>maxDecibels</a></code> is
            represented by the value 255.
          </p>
        </section>
      </section>
      <section>
        <h2>
          The ChannelSplitterNode Interface
        </h2>
        <p>
          The <code>ChannelSplitterNode</code> is for use in more advanced
          applications and would often be used in conjunction with
          <a><code>ChannelMergerNode</code></a>.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td></td>
              <td>
                This defaults to 6, but is otherwise determined from
                <a>ChannelSplitterOptions</a>.<a data-link-for=
                "ChannelSplitterOptions">numberOfOutputs</a> or the value
                specified by <a data-link-for=
                "BaseAudioContext">createChannelSplitter</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                Has <a>channelCount constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">explicit</a>"
              </td>
              <td>
                Has <a>channelCountMode constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">discrete</a>"
              </td>
              <td>
                Has <a>channelInterpretation constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <p>
          This interface represents an <a><code>AudioNode</code></a> for
          accessing the individual channels of an audio stream in the routing
          graph. It has a single input, and a number of "active" outputs which
          equals the number of channels in the input audio stream. For example,
          if a stereo input is connected to an
          <a><code>ChannelSplitterNode</code></a> then the number of active
          outputs will be two (one from the left channel and one from the
          right). There are always a total number of N outputs (determined by
          the <code>numberOfOutputs</code> parameter to the
          <a><code>AudioContext</code></a> method <a data-link-for=
          "BaseAudioContext"><code>createChannelSplitter()</code></a>), The
          default number is 6 if this value is not provided. Any outputs which
          are not "active" will output silence and would typically not be
          connected to anything.
        </p>
        <h3>
          Example:
        </h3>
        <figure>
          <img alt="channel splitter" src="images/channel-splitter.png" width=
          "601" height="398">
          <figcaption>
            A diagram of a ChannelSplitter
          </figcaption>
        </figure>
        <p>
          Please note that in this example, the splitter does <b>not</b>
          interpret the channel identities (such as left, right, etc.), but
          simply splits out channels in the order that they are input.
        </p>
        <p>
          One application for <code>ChannelSplitterNode</code> is for doing
          "matrix mixing" where individual gain control of each channel is
          desired.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional ChannelSplitterNode options)]
interface ChannelSplitterNode : AudioNode {
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="ChannelSplitterNode" data-link-for=
          "ChannelSplitterNode">
            <dt>
              <code><dfn>ChannelSplitterNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>ChannelSplitterNode</a> object.
                <a href="#audionode-constructor-init">Initialize</a>
                <var>node</var>, and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new <a>ChannelSplitter</a>
                    will be <a href="#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>ChannelSplitterOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>ChannelSplitterNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>ChannelSplitterOptions</dfn>
          </h2>
          <pre class="idl">
dictionary ChannelSplitterOptions : AudioNodeOptions {
             unsigned long numberOfOutputs = 6;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>ChannelSplitterOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="ChannelSplitterOptions"
            data-link-for="ChannelSplitterOptions">
              <dt>
                <code><dfn>numberOfOutputs</dfn></code> of type <span class=
                "idlAttrType"><code>unsigned long</code></span>, defaulting to
                6
              </dt>
              <dd>
                The number outputs for the
                <a><code>ChannelSplitterNode</code></a>.
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2>
          The ChannelMergerNode Interface
        </h2>
        <p>
          The <a><code>ChannelMergerNode</code></a> is for use in more advanced
          applications and would often be used in conjunction with
          <a><code>ChannelSplitterNode</code></a>.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td></td>
              <td>
                Defaults to 6, but is determined by
                <a>ChannelMergerOptions</a>,<a data-link-for=
                "ChannelMergerOptions">numberOfInputs</a> or the value
                specified by <a data-link-for=
                "BaseAudioContext">createChannelMerger</a>.
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                1
              </td>
              <td>
                Has <a>channelCount constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">max</a>"
              </td>
              <td>
                Has <a>channelCountMode constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <p>
          This interface represents an <a><code>AudioNode</code></a> for
          combining channels from multiple audio streams into a single audio
          stream. It has a variable number of inputs (defaulting to 6), but not
          all of them need be connected. There is a single output whose audio
          stream has a number of channels equal to the number of inputs.
        </p>
        <p>
          To merge multiple inputs into one stream, each input gets downmixed
          into one channel (mono) based on the specified mixing rule. An
          unconnected input still counts as <b>one silent channel</b> in the
          output. Changing input streams does <b>not</b> affect the order of
          output channels.
        </p>
        <h3 id="example-2">
          Example:
        </h3>
        <p>
          For example, if a default <a><code>ChannelMergerNode</code></a> has
          two connected stereo inputs, the first and second input will be
          downmixed to mono respectively before merging. The output will be a
          6-channel stream whose first two channels are be filled with the
          first two (downmixed) inputs and the rest of channels will be silent.
        </p>
        <p>
          Also the <a><code>ChannelMergerNode</code></a> can be used to arrange
          multiple audio streams in a certain order for the multi-channel
          speaker array such as 5.1 surround set up. The merger does not
          interpret the channel identities (such as left, right, etc.), but
          simply combines channels in the order that they are input.
        </p>
        <figure>
          <img alt="channel merger" src="images/channel-merger.svg">
          <figcaption>
            A diagram of ChannelMerger
          </figcaption>
        </figure>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional ChannelMergerOptions options)]
interface ChannelMergerNode : AudioNode {
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="ChannelMergerNode" data-link-for=
          "ChannelMergerNode">
            <dt>
              <code><dfn>ChannelMergerNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>ChannelMergerNode</a> object.
                <a href="#audionode-constructor-init">Initialize</a>
                <var>node</var>, and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new
                    <a>ChannelMergerNode</a> will be <a href=
                    "#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>ChannelMergerOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>ChannelMergerNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>ChannelMergerOptions</dfn>
          </h2>
          <pre class="idl">
dictionary ChannelMergerOptions : AudioNodeOptions {
             unsigned long numberOfInputs = 6;
};
          </pre>
          <section>
            <h3>
              Dictionary <a>ChannelMergerOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="ChannelMergerOptions"
            data-link-for="ChannelMergerOptions">
              <dt>
                <code><dfn>numberOfInputs</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 6
              </dt>
              <dd>
                The number inputs for the
                <a><code>ChannelSplitterNode</code></a>.
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2>
          The DynamicsCompressorNode Interface
        </h2>
        <p>
          <a><code>DynamicsCompressorNode</code></a> is an
          <a><code>AudioNode</code></a> processor implementing a dynamics
          compression effect.
        </p>
        <p>
          Dynamics compression is very commonly used in musical production and
          game audio. It lowers the volume of the loudest parts of the signal
          and raises the volume of the softest parts. Overall, a louder,
          richer, and fuller sound can be achieved. It is especially important
          in games and musical applications where large numbers of individual
          sounds are played simultaneous to control the overall signal level
          and help avoid clipping (distorting) the audio output to the
          speakers.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                2
              </td>
              <td>
                Has <a>channelCount constraints</a>
              </td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">clamped-max</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                Yes
              </td>
              <td>
                This node has a <a>tail-time</a> reference such that this node
                continues to output non-silent audio with zero input due to the
                look-ahead delay.
              </td>
            </tr>
          </table>
        </div>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional DynamicsCompressorOptions options)]
interface DynamicsCompressorNode : AudioNode {
    readonly        attribute AudioParam threshold;
    readonly        attribute AudioParam knee;
    readonly        attribute AudioParam ratio;
    readonly        attribute float      reduction;
    readonly        attribute AudioParam attack;
    readonly        attribute AudioParam release;
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="DynamicsCompressorNode"
          data-link-for="DynamicsCompressorNode">
            <dt>
              <code><dfn>DynamicsCompressorNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>DynamicsCompressorNode</a>
                object. <a href="#audionode-constructor-init">Initialize</a>
                <var>node</var>. Let [[internal reduction]] be a private slot
                on this <a>DynamicsCompressorNode</a>, that holds a floating
                point number, in decibels. Set [[internal reduction]] to 0.0.
                Return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new
                    <a>DynamicsCompressorNode</a> will be <a href=
                    "#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>DynamicsCompressorOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>DynamicsCompressorNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="DynamicsCompressorNode"
          data-link-for="DynamicsCompressorNode">
            <dt>
              <code><dfn>attack</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                The amount of time (in seconds) to reduce the gain by 10dB.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0.003
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>k-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>knee</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                A decibel value representing the range above the threshold
                where the curve smoothly transitions to the "ratio" portion.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      30
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      40
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>k-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>ratio</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                The amount of dB change in input for a 1 dB change in output.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      12
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      20
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>k-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>reduction</dfn></code> of type <span class=
              "idlAttrType"><a><code>float</code></a></span>, readonly
            </dt>
            <dd>
              A read-only decibel value for metering purposes, representing the
              current amount of gain reduction that the compressor is applying
              to the signal. If fed no signal the value will be 0 (no gain
              reduction). When this attribute is read, return the value of the
              private slot [[internal reduction]].
            </dd>
            <dt>
              <code><dfn>release</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                The amount of time (in seconds) to increase the gain by 10dB.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0.25
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>k-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>threshold</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                The decibel value above which the compression will start taking
                effect.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      -24
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      -100
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>k-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>DynamicsCompressorOptions</dfn>
          </h2>
          <p>
            This specifies the options to use in constructing a
            <a><code>DynamicsCompressorNode</code></a>. All members are
            optional; if not specified the normal defaults are used in
            constructing the node.
          </p>
          <pre class="idl">
dictionary DynamicsCompressorOptions : AudioNodeOptions {
             float attack = 0.003;
             float knee = 30;
             float ratio = 12;
             float release = 0.25;
             float threshold = -24;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>DynamicsCompressorOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="DynamicsCompressorOptions"
            data-link-for="DynamicsCompressorOptions">
              <dt>
                <code><dfn>attack</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 0.003
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "DynamicsCompressorNode"><code>attack</code></a> AudioParam.
              </dd>
              <dt>
                <code><dfn>knee</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 30
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "DynamicsCompressorNode"><code>knee</code></a> AudioParam.
              </dd>
              <dt>
                <code><dfn>ratio</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 12
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "DynamicsCompressorNode"><code>ratio</code></a> AudioParam.
              </dd>
              <dt>
                <code><dfn>release</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 0.25
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "DynamicsCompressorNode"><code>release</code></a> AudioParam.
              </dd>
              <dt>
                <code><dfn>threshold</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to -24
              </dt>
              <dd>
                The initial value for the <a data-link-for=
                "DynamicsCompressorNode"><code>threshold</code></a> AudioParam.
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h2>
            Processing
          </h2>
          <p>
            Dynamics compression can be implemented in a variety of ways. The
            <a>DynamicsCompressorNode</a> implements a dynamics processor that
            has the following characteristics:
          </p>
          <ul>
            <li>Fixed look-ahead (this means that an
            <a>DynamicsCompressorNode</a> adds a fixed latency to the signal
            chain).
            </li>
            <li>Configurable attack speed, release speed, threshold, knee
            hardness and ratio.
            </li>
            <li>Side-chaining is not supported.
            </li>
            <li>The gain reduction is reported <em>via</em> the
            <code>reduction</code> property on the
            <a>DynamicsCompressorNode</a>.
            </li>
            <li>The compression curve has three parts:
              <ul>
                <li>The first part is the identity: \(f(x) = x\).
                </li>
                <li>The second part is the soft-knee portion, which MUST be a
                monotonically increasing function.
                </li>
                <li>The third part is a linear function: \(f(x) =
                \frac{1}{ratio} \cdot x \).
                </li>
              </ul>This curve MUST be continuous and piece-wise differentiable,
              and corresponds to a target output level, based on the input
              level.
            </li>
          </ul>
          <p>
            Graphically, such a curve would look something like this:
          </p>
          <figure>
            <img alt="Graphical representation of a compression curve" src=
            "images/compression-curve.svg" style="width: 50%">
            <figcaption>
              A typical compression curve, showing the knee portion (soft or
              hard) as well as the threshold.
            </figcaption>
          </figure>
          <p>
            Internally, the <a>DynamicsCompressorNode</a> is described with a
            combination of other <a>AudioNode</a>s, as well as a special
            algorithm, to compute the gain reduction value.
          </p>
          <p>
            The following <a>AudioNode</a> graph is used internally,
            <code>input</code> and <code>output</code> respectively being the
            input and output <a>AudioNode</a>, <code>context</code> the
            <a>BaseAudioContext</a> for this <a>DynamicsCompressorNode</a>, and
            new class, <code>EnvelopeFollower</code>, that instantiate a
            special object that behaves like an <a>AudioNode</a>, described
            below:
          </p>
          <pre>
              var delay = new DelayNode(context, {delayTime: 0.006});
              var gain = new GainNode(context);
              var compression = new EnvelopeFollower();

              input.connect(delay).connect(gain).connect(output);
              input.connect(compression).connect(gain.gain);</pre>
          <figure>
            <img src="images/dynamicscompressor-internal-graph.svg" alt=
            "Schema of
            the internal graph used by the DynamicCompressorNode">
            <figcaption>
              The graph of internal <a>AudioNode</a>s used as part of the
              <a>DynamicsCompressorNode</a> processing algorithm.
            </figcaption>
          </figure>
          <div class="note">
            This implements the pre-delay and the application of the reduction
            gain.
          </div>
          <p>
            The following algorithm describes the processing performed by an
            <code>EnvelopeFollower</code> object, to be applied to the input
            signal to produce the gain reduction value. An
            <code>EnvelopeFollower</code> has two slots holding floating point
            values. Those values persist accros invocation of this algorithm.
          </p>
          <ul>
            <li>Let <code>[[detector average]]</code> be a floating point
            number, initialized to 0.0.
            </li>
            <li>Let <code>[[compression gain]]</code> be a floating point
            number, initialized to 1.0.
            </li>
          </ul>
          <p>
            The following algorithm allow determining a value for
            <var>reduction gain</var>, for each sample of input, for a render
            quantum of audio.
          </p>
          <ol>
            <li>Let <var>threshold</var>, <var>knee</var> have the value of the
            <a>AudioParam</a> of the same name, <a href=
            "#db-to-linear">converted to linear unit</a> sampled at the time of
            processing of this block (as <a>k-rate</a> parameters).
            </li>
            <li>Let <var>ratio</var> have the value of the <code>ratio</code>
            <a>AudioParam</a>, sampled at the time of processing of this block
            (as a <a>k-rate</a> parameter).
            </li>
            <li>Let <var>attack</var> and <var>release</var> have the value of
            the <a>AudioParam</a> of the same name, sampled at the time of
            processing (those are <a>k-rate</a> parameters), mutiplied by the
            sample-rate of the <a>BaseAudioContext</a> this
            <a>DynamicsCompressorNode</a> is <a href=
            "#associated">associated</a> with.
            </li>
            <li>Let <var>detector average</var> be the value of the slot <code>
              [[detector average]]</code>.
            </li>
            <li>Let <var>compressor gain</var> be the value of the slot <code>
              [[compressor gain]]</code>.
            </li>
            <li>For each sample <var>input</var> of the render quantum to be
            processed, execute the following steps:
              <ol>
                <li>Let <var>releasing</var> be <code>true</code> if
                <var>target gain</var> is greater than <var>compressor
                gain</var>, <code>false</code> otherwise.
                </li>
                <li>If the absolute value of <var>input</var> is less than
                0.0001, let <var>attenuation</var> be 1.0. Else, let
                <var>shaped input</var> be the value of applying the <a href=
                "#compression-curve">compression curve</a> to the absolute
                value of <var>input</var>. Let <var>attenuation</var> be <var>
                  shaped input</var> divided by the absolute value of
                  <var>input</var>.
                </li>
                <li>Let <var>detector rate</var> be the result of applying the
                <a href="#detector-curve">detector curve</a> to
                <var>attenuation</var>.
                </li>
                <li>Substract <var>detector average</var> to
                <var>attenuation</var>, and multiply the result by
                <var>detector rate</var>. Add this new result to <var>detector
                average</var>.
                </li>
                <li>Clamp <var>detector average</var> to a maximum of 1.0.
                </li>
                <li>Let <var>envelope rate</var> be the result of <a href=
                "#envelope-rate">computing the envelope rate</a>.
                </li>
                <li>If <var>releasing</var> is <code>true</code>, set
                <var>compressor gain</var> to the multiplication of
                <var>compressor gain</var> by <var>envelope rate</var>, clamped
                to a maximum of 1.0.
                </li>
                <li>Else, if <var>releasing</var> is <code>false</code>, let
                <var>gain increment</var> to be <var>detector average</var>
                minus <var>compressor gain</var>. Multiply <var>gain
                increment</var> by <var>envelope rate</var>, and add the result
                to <var>compressor gain</var>.
                </li>
                <li>Compute <var>reduction gain</var> to be <var>compressor
                gain</var> multiplied by the return value of <a>computing the
                makeup gain</a>.
                </li>
                <li>Compute <var>metering gain</var> to be <var>final
                gain</var>, <a href="#linear-to-decibel">converted to
                decibel</a>.
                </li>
              </ol>
            </li>
            <li>Set <code>[[compressor gain]]</code> to <var>compressor
            gain</var>.
            </li>
            <li>Set <code>[[detector average]]</code> to <var>detector
            average</var>.
            </li>
            <li>
              <a href="#atomic">Atomically</a> set the internal slot [[internal
              reduction]] to the value of <var>metering gain</var>.
              <div class="note">
                This step makes the metering gain update once per block, at the
                end of the block processing.
              </div>
            </li>
          </ol>
          <p>
            The makeup gain is a fixed gain stage that only depends on ratio,
            knee and threshold parameter of the compressor, and not on the
            input signal. The intent here is to increase the output level of
            the compressor so it is comparable to the input level.
          </p>
          <p>
            <dfn>Computing the makeup gain</dfn> means executing the following
            steps:
          </p>
          <ol>
            <li>Let <var>full range gain</var> be the value returned by
            applying the <a>compression curve</a> to the value 1.0.
            </li>
            <li>Let <var>full range makeup gain</var> the inverse of <var>full
            range gain</var>.
            </li>
            <li>Return the result of taking 0.6 power of <var>full range makeup
            gain</var>.
            </li>
          </ol>
          <p>
            <dfn id="#envelope-rate">Computing the envelope rate</dfn> is done
            by applying a function to the ratio of the <var>compressor
            gain</var> and the <var>detector average</var>. User-agents are
            allowed to choose the shape the envelope function. However, this
            function MUST respect the following constraints:
          </p>
          <ul>
            <li>The envelope rate MUST be the calculated from the ratio of the
            <var>compressor gain</var> and the <var>detector average</var>.
              <div class="note">
                When attacking, this number less than or equal to 1, when
                releasing, this number is strictly greater than 1.
              </div>
            </li>
            <li>The attack curve MUST be a continuous, monotonically increasing
            function in the range \([0, 1]\).
            </li>
            <li>The release curve MUST be a continuous, monotonically
            decreasing function that is always greater than 1.
            </li>
          </ul>
          <p>
            This operation returns the value computed by applying this function
            to the ratio of <var>compressor gain</var> and <var>detector
            average</var>.
          </p>
          <p>
            Applying the <dfn id="detector-curve">detector curve</dfn> to the
            change rate when attacking or releasing allow implementing
            <em>adaptive release</em>. It is a function that MUST respect the
            following constraints:
          </p>
          <ul>
            <li>The output of the function MUST be in \([0,1]\).
            </li>
            <li>The function MUST be monotonically increasing, continuous.
            </li>
          </ul>
          <div class="note">
            It is allowed, for example, to have a compressor that performs an
            <em>adaptive release</em>, that is, releasing faster the harder the
            compression, or to have curves for attack and release that are not
            of the same shape.
          </div>
          <p>
            Applying a <dfn>compression curve</dfn> to a value means computing
            the value of this sample when passed to a function, and returning
            the computed value. This function MUST respect the following
            characteristics:
          </p>
          <ol>
            <li>This function is the identity up to the value of the linear
            <code>threshold</code> (i.e., \(f(x) = x\)).
            </li>
            <li>From the <code>threshold</code> up to the <code>threshold +
            knee</code>, User-Agents can choose the curve shape. The whole
            function MUST be monotonically increasing and continuous.
              <div class="note">
                If the <code>knee</code> is 0, the
                <a>DynamicsCompressorNode</a> is called a hard-knee compressor.
              </div>
            </li>
            <li>This function is linear, based on the ratio, after the
            <code>threshold</code> and the soft knee (i.e., \(f(x) =
            \frac{1}{ratio} \cdot x \)).
            </li>
          </ol>
          <p>
            Converting a value \(v\) in <dfn id="linear-to-decibel">linear gain
            unit to decibel means</dfn> executing the following steps:
          </p>
          <ol>
            <li>If <var>v</var> is equal to zero, return -1000.
            </li>
            <li>Else, return \( 20 \, \log_{10}{v} \)
            </li>
          </ol>
          <p>
            Converting a value \(v\) in <dfn id="db-to-linear">decibels to
            linear gain unit</dfn> means returning \(10^\frac{v}{20}\)
          </p>
        </section>
      </section>
      <section>
        <h2>
          The BiquadFilterNode Interface
        </h2>
        <p>
          <a><code>BiquadFilterNode</code></a> is an
          <a><code>AudioNode</code></a> processor implementing very common
          low-order filters.
        </p>
        <p>
          Low-order filters are the building blocks of basic tone controls
          (bass, mid, treble), graphic equalizers, and more advanced filters.
          Multiple <a><code>BiquadFilterNode</code></a> filters can be combined
          to form more complex filters. The filter parameters such as
          <a data-link-for="BiquadFilterNode"><code>frequency</code></a> can be
          changed over time for filter sweeps, etc. Each
          <a><code>BiquadFilterNode</code></a> can be configured as one of a
          number of common filter types as shown in the IDL below. The default
          filter type is <code>"lowpass"</code>.
        </p>
        <p>
          Both <a data-link-for="BiquadFilterNode"><code>frequency</code></a>
          and <a data-link-for="BiquadFilterNode"><code>detune</code></a> form
          a <a>compound parameter</a> and are both <a>a-rate</a>. They are used
          together to determine a <dfn id=
          "computedFreq-biquad">computedFrequency</dfn> value:
        </p>
        <pre class="highlight">
  computedFrequency(t) = frequency(t) * pow(2, detune(t) / 1200)
</pre>
        <p>
          The <a>nominal range</a> for this <a>compound parameter</a> is [0,
          <a>Nyquist frequency</a>].
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                2
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">max</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                Yes
              </td>
              <td>
                Continues to output non-silent audio with zero input. Since
                this is an IIR filter, the filter produces non-zero input
                forever, but in practice, this can be limited after some finite
                time where the output is sufficiently close to zero. The actual
                time depends on the filter coefficients.
              </td>
            </tr>
          </table>
        </div>
        <p>
          The number of channels of the output always equals the number of
          channels of the input.
        </p>
        <pre class="idl">
enum BiquadFilterType {
    "lowpass",
    "highpass",
    "bandpass",
    "lowshelf",
    "highshelf",
    "peaking",
    "notch",
    "allpass"
};
        </pre>
        <table class="simple" data-dfn-for="BiquadFilterType" data-link-for=
        "BiquadFilterType">
          <tr>
            <th colspan="2">
              Enumeration description
            </th>
          </tr>
          <tr>
            <td>
              <dfn>lowpass</dfn>
            </td>
            <td>
              <p>
                A <a href=
                "https://en.wikipedia.org/wiki/Low-pass_filter">lowpass
                filter</a> allows frequencies below the cutoff frequency to
                pass through and attenuates frequencies above the cutoff. It
                implements a standard second-order resonant lowpass filter with
                12dB/octave rolloff.
              </p>
              <blockquote>
                <dl>
                  <dt>
                    frequency
                  </dt>
                  <dd>
                    The cutoff frequency
                  </dd>
                  <dt>
                    Q
                  </dt>
                  <dd>
                    Controls how peaked the response will be at the cutoff
                    frequency. A large value makes the response more peaked.
                    Please note that for this filter type, this value is not a
                    traditional Q, but is a resonance value in decibels.
                  </dd>
                  <dt>
                    gain
                  </dt>
                  <dd>
                    Not used in this filter type
                  </dd>
                </dl>
              </blockquote>
            </td>
          </tr>
          <tr>
            <td>
              <dfn>highpass</dfn>
            </td>
            <td>
              <p>
                A <a href=
                "https://en.wikipedia.org/wiki/High-pass_filter">highpass
                filter</a> is the opposite of a lowpass filter. Frequencies
                above the cutoff frequency are passed through, but frequencies
                below the cutoff are attenuated. It implements a standard
                second-order resonant highpass filter with 12dB/octave rolloff.
              </p>
              <blockquote>
                <dl>
                  <dt>
                    frequency
                  </dt>
                  <dd>
                    The cutoff frequency below which the frequencies are
                    attenuated
                  </dd>
                  <dt>
                    Q
                  </dt>
                  <dd>
                    Controls how peaked the response will be at the cutoff
                    frequency. A large value makes the response more peaked.
                    Please note that for this filter type, this value is not a
                    traditional Q, but is a resonance value in decibels.
                  </dd>
                  <dt>
                    gain
                  </dt>
                  <dd>
                    Not used in this filter type
                  </dd>
                </dl>
              </blockquote>
            </td>
          </tr>
          <tr>
            <td>
              <dfn>bandpass</dfn>
            </td>
            <td>
              <p>
                A <a href=
                "https://en.wikipedia.org/wiki/Band-pass_filter">bandpass
                filter</a> allows a range of frequencies to pass through and
                attenuates the frequencies below and above this frequency
                range. It implements a second-order bandpass filter.
              </p>
              <blockquote>
                <dl>
                  <dt>
                    frequency
                  </dt>
                  <dd>
                    The center of the frequency band
                  </dd>
                  <dt>
                    <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                  </dt>
                  <dd>
                    Controls the width of the band. The width becomes narrower
                    as the Q value increases.
                  </dd>
                  <dt>
                    gain
                  </dt>
                  <dd>
                    Not used in this filter type
                  </dd>
                </dl>
              </blockquote>
            </td>
          </tr>
          <tr>
            <td>
              <dfn>lowshelf</dfn>
            </td>
            <td>
              <p>
                The lowshelf filter allows all frequencies through, but adds a
                boost (or attenuation) to the lower frequencies. It implements
                a second-order lowshelf filter.
              </p>
              <blockquote>
                <dl>
                  <dt>
                    frequency
                  </dt>
                  <dd>
                    The upper limit of the frequences where the boost (or
                    attenuation) is applied.
                  </dd>
                  <dt>
                    <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                  </dt>
                  <dd>
                    Not used in this filter type.
                  </dd>
                  <dt>
                    gain
                  </dt>
                  <dd>
                    The boost, in dB, to be applied. If the value is negative,
                    the frequencies are attenuated.
                  </dd>
                </dl>
              </blockquote>
            </td>
          </tr>
          <tr>
            <td>
              <dfn>highshelf</dfn>
            </td>
            <td>
              <p>
                The highshelf filter is the opposite of the lowshelf filter and
                allows all frequencies through, but adds a boost to the higher
                frequencies. It implements a second-order highshelf filter
              </p>
              <blockquote>
                <dl>
                  <dt>
                    frequency
                  </dt>
                  <dd>
                    The lower limit of the frequences where the boost (or
                    attenuation) is applied.
                  </dd>
                  <dt>
                    <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                  </dt>
                  <dd>
                    Not used in this filter type.
                  </dd>
                  <dt>
                    gain
                  </dt>
                  <dd>
                    The boost, in dB, to be applied. If the value is negative,
                    the frequencies are attenuated.
                  </dd>
                </dl>
              </blockquote>
            </td>
          </tr>
          <tr>
            <td>
              <dfn>peaking</dfn>
            </td>
            <td>
              <p>
                The peaking filter allows all frequencies through, but adds a
                boost (or attenuation) to a range of frequencies.
              </p>
              <blockquote>
                <dl>
                  <dt>
                    frequency
                  </dt>
                  <dd>
                    The center frequency of where the boost is applied.
                  </dd>
                  <dt>
                    <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                  </dt>
                  <dd>
                    Controls the width of the band of frequencies that are
                    boosted. A large value implies a narrow width.
                  </dd>
                  <dt>
                    gain
                  </dt>
                  <dd>
                    The boost, in dB, to be applied. If the value is negative,
                    the frequencies are attenuated.
                  </dd>
                </dl>
              </blockquote>
            </td>
          </tr>
          <tr>
            <td>
              <dfn>notch</dfn>
            </td>
            <td>
              <p>
                The notch filter (also known as a <a href=
                "https://en.wikipedia.org/wiki/Band-stop_filter">band-stop or
                band-rejection filter</a>) is the opposite of a bandpass
                filter. It allows all frequencies through, except for a set of
                frequencies.
              </p>
              <blockquote>
                <dl>
                  <dt>
                    frequency
                  </dt>
                  <dd>
                    The center frequency of where the notch is applied.
                  </dd>
                  <dt>
                    <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                  </dt>
                  <dd>
                    Controls the width of the band of frequencies that are
                    attenuated. A large value implies a narrow width.
                  </dd>
                  <dt>
                    gain
                  </dt>
                  <dd>
                    Not used in this filter type.
                  </dd>
                </dl>
              </blockquote>
            </td>
          </tr>
          <tr>
            <td>
              <dfn>allpass</dfn>
            </td>
            <td>
              <p>
                An <a href=
                "https://en.wikipedia.org/wiki/All-pass_filter#Digital_Implementation">
                allpass filter</a> allows all frequencies through, but changes
                the phase relationship between the various frequencies. It
                implements a second-order allpass filter
              </p>
              <blockquote>
                <dl>
                  <dt>
                    frequency
                  </dt>
                  <dd>
                    The frequency where the center of the phase transition
                    occurs. Viewed another way, this is the frequency with
                    maximal <a href=
                    "https://en.wikipedia.org/wiki/Group_delay">group
                    delay</a>.
                  </dd>
                  <dt>
                    <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                  </dt>
                  <dd>
                    Controls how sharp the phase transition is at the center
                    frequency. A larger value implies a sharper transition and
                    a larger group delay.
                  </dd>
                  <dt>
                    gain
                  </dt>
                  <dd>
                    Not used in this filter type.
                  </dd>
                </dl>
              </blockquote>
            </td>
          </tr>
        </table>
        <p>
          All attributes of the <a><code>BiquadFilterNode</code></a> are
          <a>a-rate</a> <a><code>AudioParam</code></a>.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional BiquadFilterOptions options)]
interface BiquadFilterNode : AudioNode {
                    attribute BiquadFilterType type;
    readonly        attribute AudioParam       frequency;
    readonly        attribute AudioParam       detune;
    readonly        attribute AudioParam       Q;
    readonly        attribute AudioParam       gain;
    void getFrequencyResponse (Float32Array frequencyHz, Float32Array magResponse, Float32Array phaseResponse);
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="BiquadFilterNode" data-link-for=
          "BiquadFilterNode">
            <dt>
              <code><dfn>BiquadFilterNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>BiquadFilterNode</a> object.
                <a href="#audionode-constructor-init">Initialize</a>
                <var>node</var>, and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new
                    <a>BiquadFilterNode</a> will be <a href=
                    "#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>BiquadFilterOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>BiquadFilterNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="BiquadFilterNode" data-link-for=
          "BiquadFilterNode">
            <dt>
              <code><dfn>Q</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                The <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                factor of the filter. This is not used for <a data-link-for=
                "BiquadFilterType">lowshelf</a> or <a data-link-for=
                "BiquadFilterType">highshelf</a> filters.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      1
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>a-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>detune</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                A detune value, in cents, for the frequency. It forms a
                <a>compound parameter</a> with <code>frequency</code>.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>a-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>frequency</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                The frequency at which the <a><code>BiquadFilterNode</code></a>
                will operate, in Hz. It forms a <a>compound parameter</a> with
                <code>detune</code>.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      350
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>a-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>gain</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                The gain of the filter. Its value is in dB units. The gain is
                only used for <a data-link-for="BiquadFilterType">lowshelf</a>,
                <a data-link-for="BiquadFilterType">highshelf</a>, and
                <a data-link-for="BiquadFilterType">peaking</a> filters.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>a-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>type</dfn></code> of type <span class=
              "idlAttrType"><a><code>BiquadFilterType</code></a></span>
            </dt>
            <dd>
              The type of this <a><code>BiquadFilterNode</code></a>. Its
              default value is "lowpass". The exact meaning of the other
              parameters depend on the value of the <a><code>type</code></a>
              attribute.
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Methods
          </h3>
          <dl class="methods" data-dfn-for="BiquadFilterNode" data-link-for=
          "BiquadFilterNode">
            <dt>
              <code><dfn>getFrequencyResponse</dfn></code>
            </dt>
            <dd>
              <p>
                <span class="sychronous">Given the current filter parameter
                settings, synchronously calculates the frequency response for
                the specified frequencies.</span> The three parameters MUST be
                <code>Float32Array</code>s of the same length, or an
                <code>InvalidAccessError</code> MUST be thrown.
              </p>
              <p>
                The frequency response returned MUST be computed with the
                <a><code>AudioParam</code></a> sampled for the current
                processing block.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    frequencyHz
                  </td>
                  <td class="prmType">
                    <a><code>Float32Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    This parameter specifies an array of frequencies at which
                    the response values will be calculated.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    magResponse
                  </td>
                  <td class="prmType">
                    <a><code>Float32Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    <p>
                      This parameter specifies an output array receiving the
                      linear magnitude response values.
                    </p>
                    <p>
                      If a value in the <code>frequencyHz</code> parameter is
                      not within [0; sampleRate/2], where
                      <code>sampleRate</code> is the value of the
                      <a data-link-for=
                      "BaseAudioContext"><code>sampleRate</code></a> property
                      of the <a>AudioContext</a>, the corresponding value at
                      the same index of the <code>magResponse</code> array MUST
                      be <code>NaN</code>.
                    </p>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    phaseResponse
                  </td>
                  <td class="prmType">
                    <a><code>Float32Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    <p>
                      This parameter specifies an output array receiving the
                      phase response values in radians.
                    </p>
                    <p>
                      If a value in the <code>frequencyHz</code> parameter is
                      not within [0; sampleRate/2], where
                      <code>sampleRate</code> is the value of the
                      <a data-link-for=
                      "BaseAudioContext"><code>sampleRate</code></a> property
                      of the <a>AudioContext</a>, the corresponding value at
                      the same index of the <code>phaseResponse</code> array
                      MUST be <code>NaN</code>.
                    </p>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>BiquadFilterOptions</dfn>
          </h2>
          <p>
            This specifies the options to be used when constructing a
            <a><code>BiquadFilterNode</code></a>. All members are optional; if
            not specified, the normal default values are used to construct the
            node.
          </p>
          <pre class="idl">
dictionary BiquadFilterOptions : AudioNodeOptions {
             BiquadFilterType type = "lowpass";
             float            Q = 1;
             float            detune = 0;
             float            frequency = 350;
             float            gain = 0;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>BiquadFilterOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="BiquadFilterOptions"
            data-link-for="BiquadFilterOptions">
              <dt>
                <code><dfn>Q</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 1
              </dt>
              <dd>
                The desired initial value for <a><code>Q</code></a>.
              </dd>
              <dt>
                <code><dfn>detune</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 0
              </dt>
              <dd>
                The desired initial value for <a><code>detune</code></a>.
              </dd>
              <dt>
                <code><dfn>frequency</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 350
              </dt>
              <dd>
                The desired initial value for <a><code>frequency</code></a>.
              </dd>
              <dt>
                <code><dfn>gain</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 0
              </dt>
              <dd>
                The desired initial value for <a><code>gain</code></a>.
              </dd>
              <dt>
                <code><dfn>type</dfn></code> of type <span class=
                "idlAttrType"><code>BiquadFilterType</code></span>, defaulting
                to "lowpass"
              </dt>
              <dd>
                The desired initial type of the filter.
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h3>
            Filters characteristics
          </h3>
          <p>
            There are multiple ways of implementing the type of filters
            available through the <a><code>BiquadFilterNode</code></a> each
            having very different characteristics. The formulas in this section
            describe the filters that a <a>conforming implementation</a> MUST
            implement, as they determine the characteristics of the different
            filter types. They are inspired by formulas found in the <a href=
            "http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt">Audio EQ
            Cookbook</a>.
          </p>
          <p>
            The transfer function for the filters implemented by the
            <a><code>BiquadFilterNode</code></a> is:
          </p>
          <pre class="nohighlight">
  $$
  H(z) = \frac{\frac{b_0}{a_0} + \frac{b_1}{a_0}z^{-1} + \frac{b_2}{a_0}z^{-2}}
              {1+\frac{a_1}{a_0}z^{-1}+\frac{a_2}{a_0}z^{-2}}
  $$

</pre>
          <p>
            The initial filter state is 0.
          </p>The coefficients in the transfer function above are different for
          each node type. The following intermediate variable are necessary for
          their computation, based on the <a>computedValue</a> of the
          <a><code>AudioParam</code></a>s of the
          <a><code>BiquadFilterNode</code></a>.
          <ul>
            <li>Let \(F_s\) be the value of the <a data-link-for=
            "BaseAudioContext"><code>sampleRate</code></a> attribute for this
            <a>AudioContext</a>.
            </li>
            <li>Let \(f_0\) be the value of the
            <a><code>computedFrequency</code></a>.
            </li>
            <li>Let \(G\) be the value of the <a data-link-for=
            "BiquadFilterNode"><code>gain</code></a>
            <a><code>AudioParam</code></a>.
            </li>
            <li>Let \(Q\) be the value of the <a data-link-for=
            "BiquadFilterNode"><code>Q</code></a>
            <a><code>AudioParam</code></a>.
            </li>
            <li>Finally let 
            <!-- Should \alpha_S be simplified since S is always 1?-->
              <pre class="nohighlight">
$$
\begin{align*}
  A        &amp;= 10^{\frac{G}{40}} \\
  \omega_0 &amp;= 2\pi\frac{f_0}{F_s} \\
  \alpha_Q &amp;= \frac{\sin\omega_0}{2Q} \\
  \alpha_{Q_{dB}} &amp;= \frac{\sin\omega_0}{2 \cdot 10^{Q/20}} \\
  S        &amp;= 1 \\
  \alpha_S &amp;= \frac{\sin\omega_0}{2}\sqrt{\left(A+\frac{1}{A}\right)\left(\frac{1}{S}-1\right)+2}
\end{align*}
$$

</pre>
            </li>
          </ul>The six coefficients (\(b_0, b_1, b_2, a_0, a_1, a_2\)) for each
          filter type, are:
          <dl>
            <dt>
              <code>lowpass</code>
            </dt>
            <dd>
              <pre class="nohighlight">
                $$
                  \begin{align*}
                    b_0 &amp;= \frac{1 - \cos\omega_0}{2} \\
                    b_1 &amp;= 1 - \cos\omega_0 \\
                    b_2 &amp;= \frac{1 - \cos\omega_0}{2} \\
                    a_0 &amp;= 1 + \alpha_{Q_{dB}} \\
                    a_1 &amp;= -2 \cos\omega_0 \\
                    a_2 &amp;= 1 - \alpha_{Q_{dB}}
                  \end{align*}
                $$

</pre>
            </dd>
            <dt>
              <code>highpass</code>
            </dt>
            <dd>
              <pre class="nohighlight">
                  $$
                    \begin{align*}
                      b_0 &amp;= \frac{1 + \cos\omega_0}{2} \\
                      b_1 &amp;= -(1 + \cos\omega_0) \\
                      b_2 &amp;= \frac{1 + \cos\omega_0}{2} \\
                      a_0 &amp;= 1 + \alpha_{Q_{dB}} \\
                      a_1 &amp;= -2 \cos\omega_0 \\
                      a_2 &amp;= 1 - \alpha_{Q_{dB}}
                    \end{align*}
                  $$

</pre>
            </dd>
            <dt>
              <code>bandpass</code>
            </dt>
            <dd>
              <pre class="nohighlight">
              $$
                \begin{align*}
                  b_0 &amp;= \alpha_Q \\
                  b_1 &amp;= 0 \\
                  b_2 &amp;= -\alpha_Q \\
                  a_0 &amp;= 1 + \alpha_Q \\
                  a_1 &amp;= -2 \cos\omega_0 \\
                  a_2 &amp;= 1 - \alpha_Q
                \end{align*}
              $$

</pre>
            </dd>
            <dt>
              <code>notch</code>
            </dt>
            <dd>
              <pre class="nohighlight">
                $$
                  \begin{align*}
                    b_0 &amp;= 1 \\
                    b_1 &amp;= -2\cos\omega_0 \\
                    b_2 &amp;= 1 \\
                    a_0 &amp;= 1 + \alpha_Q \\
                    a_1 &amp;= -2 \cos\omega_0 \\
                    a_2 &amp;= 1 - \alpha_Q
                  \end{align*}
                $$

</pre>
            </dd>
            <dt>
              <code>allpass</code>
            </dt>
            <dd>
              <pre class="nohighlight">
                $$
                  \begin{align*}
                    b_0 &amp;= 1 - \alpha_Q \\
                    b_1 &amp;= -2\cos\omega_0 \\
                    b_2 &amp;= 1 + \alpha_Q \\
                    a_0 &amp;= 1 + \alpha_Q \\
                    a_1 &amp;= -2 \cos\omega_0 \\
                    a_2 &amp;= 1 - \alpha_Q
                  \end{align*}
                $$

</pre>
            </dd>
            <dt>
              <code>peaking</code>
            </dt>
            <dd>
              <pre class="nohighlight">
                $$
                  \begin{align*}
                    b_0 &amp;= 1 + \alpha_Q\, A \\
                    b_1 &amp;= -2\cos\omega_0 \\
                    b_2 &amp;= 1 - \alpha_Q\,A \\
                    a_0 &amp;= 1 + \frac{\alpha_Q}{A} \\
                    a_1 &amp;= -2 \cos\omega_0 \\
                    a_2 &amp;= 1 - \frac{\alpha_Q}{A}
                  \end{align*}
                $$

</pre>
            </dd>
            <dt>
              <code>lowshelf</code>
            </dt>
            <dd>
              <pre class="nohighlight">
                $$
                  \begin{align*}
                    b_0 &amp;= A \left[ (A+1) - (A-1) \cos\omega_0 + 2 \alpha_S \sqrt{A})\right] \\
                    b_1 &amp;= 2 A \left[ (A-1) - (A+1) \cos\omega_0 )\right] \\
                    b_2 &amp;= A \left[ (A+1) - (A-1) \cos\omega_0 - 2 \alpha_S \sqrt{A}) \right] \\
                    a_0 &amp;= (A+1) + (A-1) \cos\omega_0 + 2 \alpha_S \sqrt{A} \\
                    a_1 &amp;= -2 \left[ (A-1) + (A+1) \cos\omega_0\right] \\
                    a_2 &amp;= (A+1) + (A-1) \cos\omega_0 - 2 \alpha_S \sqrt{A})
                  \end{align*}
                $$

</pre>
            </dd>
            <dt>
              <code>highshelf</code>
            </dt>
            <dd>
              <pre class="nohighlight">
                $$
                  \begin{align*}
                    b_0 &amp;= A\left[ (A+1) + (A-1)\cos\omega_0 + 2\alpha_S\sqrt{A} )\right] \\
                    b_1 &amp;= -2A\left[ (A-1) + (A+1)\cos\omega_0 )\right] \\
                    b_2 &amp;= A\left[ (A+1) + (A-1)\cos\omega_0 - 2\alpha_S\sqrt{A} )\right] \\
                    a_0 &amp;= (A+1) - (A-1)\cos\omega_0 + 2\alpha_S\sqrt{A} \\
                    a_1 &amp;= 2\left[ (A-1) - (A+1)\cos\omega_0\right] \\
                    a_2 &amp;= (A+1) - (A-1)\cos\omega_0 - 2\alpha_S\sqrt{A}
                  \end{align*}
                $$

</pre>
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h2>
          The IIRFilterNode Interface
        </h2>
        <p>
          <a><code>IIRFilterNode</code></a> is an <a><code>AudioNode</code></a>
          processor implementing a general IIR Filter. In general, it is best
          to use <a><code>BiquadFilterNode</code></a>'s to implement
          higher-order filters for the following reasons:
        </p>
        <ul>
          <li>Generally less sensitive to numeric issues
          </li>
          <li>Filter parameters can be automated
          </li>
          <li>Can be used to create all even-ordered IIR filters
          </li>
        </ul>
        <p>
          However, odd-ordered filters cannot be created, so if such filters
          are needed or automation is not needed, then IIR filters may be
          appropriate.
        </p>
        <p>
          Once created, the coefficients of the IIR filter cannot be changed.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                2
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">max</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                Yes
              </td>
              <td>
                Continues to output non-silent audio with zero input. Since
                this is an IIR filter, the filter produces non-zero input
                forever, but in practice, this can be limited after some finite
                time where the output is sufficiently close to zero. The actual
                time depends on the filter coefficients.
              </td>
            </tr>
          </table>
        </div>
        <p>
          The number of channels of the output always equals the number of
          channels of the input.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, IIRFilterOptions options)]
interface IIRFilterNode : AudioNode {
    void getFrequencyResponse (Float32Array frequencyHz, Float32Array magResponse, Float32Array phaseResponse);
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="IIRFilterNode" data-link-for=
          "IIRFilterNode">
            <dt>
              <code><dfn>IIRFilterNode</dfn></code>
            </dt>
            <dd>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new <a>IIRFilterNode</a>
                    will be <a href="#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>IIRFilterOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>IIRFilterNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Methods
          </h3>
          <dl class="methods" data-dfn-for="IIRFilterNode" data-link-for=
          "IIRFilterNode">
            <dt>
              <code><dfn>getFrequencyResponse</dfn></code>
            </dt>
            <dd>
              <span class="synchronous">Given the current filter parameter
              settings, synchronously calculates the frequency response for the
              specified frequencies.</span> The three parameters MUST be
              <code>Float32Array</code>s of the same length, or an
              <code>InvalidAccessError</code> MUST be thrown.
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    frequencyHz
                  </td>
                  <td class="prmType">
                    <a><code>Float32Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    This parameter specifies an array of frequencies at which
                    the response values will be calculated.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    magResponse
                  </td>
                  <td class="prmType">
                    <a><code>Float32Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    <p>
                      This parameter specifies an output array receiving the
                      linear magnitude response values.
                    </p>
                    <p>
                      If a value in the <code>frequencyHz</code> parameter is
                      not within [0; sampleRate/2], where
                      <code>sampleRate</code> is the value of the
                      <a data-link-for=
                      "BaseAudioContext"><code>sampleRate</code></a> property
                      of the <a>AudioContext</a>, the corresponding value at
                      the same index of the <code>magResponse</code> array MUST
                      be <code>NaN</code>.
                    </p>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    phaseResponse
                  </td>
                  <td class="prmType">
                    <a><code>Float32Array</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    <p>
                      This parameter specifies an output array receiving the
                      phase response values in radians.
                    </p>
                    <p>
                      If a value in the <code>frequencyHz</code> parameter is
                      not within [0; sampleRate/2], where
                      <code>sampleRate</code> is the value of the
                      <a data-link-for=
                      "BaseAudioContext"><code>sampleRate</code></a> property
                      of the <a>AudioContext</a>, the corresponding value at
                      the same index of the <code>phaseResponse</code> array
                      MUST be <code>NaN</code>.
                    </p>
                  </td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>IIRFilterOptions</dfn>
          </h2>
          <p>
            The <code>IIRFilterOptions</code> dictionary is used to specify the
            filter coefficients of the <a><code>IIRFilterNode</code></a>.
          </p>
          <pre class="idl">
dictionary IIRFilterOptions : AudioNodeOptions {
    required sequence&lt;double&gt; feedforward;
    required sequence&lt;double&gt; feedback;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>IIRFilterOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="IIRFilterOptions"
            data-link-for="IIRFilterOptions">
              <dt>
                <code><dfn>feedforward</dfn></code> of type <span class=
                "idlAttrType"><code>sequence&lt;double&gt;</code></span>,
                required
              </dt>
              <dd>
                The feedforward coefficients for the
                <a><code>IIRFilterNode</code></a>. This member is required. If
                not specifed, a <code>NotFoundError</code> MUST be thrown.
              </dd>
              <dt>
                <code><dfn>feedback</dfn></code> of type <span class=
                "idlAttrType"><code>sequence&lt;double&gt;</code></span>,
                required
              </dt>
              <dd>
                The feedback coefficients for the
                <a><code>IIRFilterNode</code></a>. This member is required. If
                not specifed, a <code>NotFoundError</code> MUST be thrown.
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h3>
            Filter Definition
          </h3>
          <p>
            Let \(b_m\) be the <code>feedforward</code> coefficients and
            \(a_n\) be the <code>feedback</code> coefficients specified by
            <a data-link-for="BaseAudioContext">createIIRFilter</a>. Then the
            transfer function of the general IIR filter is given by
          </p>
          <pre class="nohighlight">
            $$
              H(z) = \frac{\sum_{m=0}^{M} b_m z^{-m}}{\sum_{n=0}^{N} a_n z^{-n}}
            $$

</pre>
          <p>
            where \(M + 1\) is the length of the \(b\) array and \(N + 1\) is
            the length of the \(a\) array. The coefficient \(a_0\) cannot be 0.
            At least one of \(b_m\) MUST be non-zero.
          </p>
          <p>
            Equivalently, the time-domain equation is:
          </p>
          <pre class="nohighlight">
            $$
              \sum_{k=0}^{N} a_k y(n-k) = \sum_{k=0}^{M} b_k x(n-k)
            $$

</pre>
          <p>
            The initial filter state is the all-zeroes state.
          </p>
        </section>
      </section>
      <section>
        <h2 id="WaveShaperNode">
          The WaveShaperNode Interface
        </h2>
        <p>
          <a><code>WaveShaperNode</code></a> is an
          <a><code>AudioNode</code></a> processor implementing non-linear
          distortion effects.
        </p>
        <p>
          Non-linear waveshaping distortion is commonly used for both subtle
          non-linear warming, or more obvious distortion effects. Arbitrary
          non-linear shaping curves may be specified.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                2
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">max</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                Maybe
              </td>
              <td>
                There is a <a>tail-time</a> reference only if the
                <a data-link-for="WaveShaperNode">oversample</a> attribute is
                set to "<a data-link-for="OverSampleType">2x</a>" or
                "<a data-link-for="OverSampleType">4x</a>". The actual duration
                of this <a>tail-time</a> depends on the implementation.
              </td>
            </tr>
          </table>
        </div>
        <p>
          The number of channels of the output always equals the number of
          channels of the input.
        </p>
        <p>
          <a>WaveShaperNode</a>s are created with an internal flag <code>curve
          set</code>, initially set to false.
        </p>
        <pre class="idl">
enum OverSampleType {
    "none",
    "2x",
    "4x"
};
        </pre>
        <table class="simple" data-dfn-for="OverSampleType" data-link-for=
        "OverSampleType">
          <tr>
            <th colspan="2">
              Enumeration description
            </th>
          </tr>
          <tr>
            <td>
              <dfn>none</dfn>
            </td>
            <td>
              Don't oversample
            </td>
          </tr>
          <tr>
            <td>
              <dfn>2x</dfn>
            </td>
            <td>
              Oversample two times
            </td>
          </tr>
          <tr>
            <td>
              <dfn>4x</dfn>
            </td>
            <td>
              Oversample four times
            </td>
          </tr>
        </table>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional WaveShaperOptions options)]
interface WaveShaperNode : AudioNode {
                    attribute Float32Array?  curve;
                    attribute OverSampleType oversample;
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="WaveShaperNode" data-link-for=
          "WaveShaperNode">
            <dt>
              <code><dfn>WaveShaperNode</dfn></code>
            </dt>
            <dd>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new <a>WaveShaperNode</a>
                    will be <a href="#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>WaveShaperOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>WaveShaperNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="WaveShaperNode" data-link-for=
          "WaveShaperNode">
            <dt>
              <code><dfn>curve</dfn></code> of type <span class=
              "idlAttrType"><a><code>Float32Array</code></a></span>, nullable
            </dt>
            <dd>
              <p>
                The shaping curve used for the waveshaping effect. The input
                signal is nominally within the range [-1; 1]. Each input sample
                within this range will index into the shaping curve, with a
                signal level of zero corresponding to the center value of the
                curve array if there are an odd number of entries, or
                interpolated between the two centermost values if there are an
                even number of entries in the array. Any sample value less than
                -1 will correspond to the first value in the curve array. Any
                sample value greater than +1 will correspond to the last value
                in the curve array.
              </p>
              <p>
                The implementation MUST perform linear interpolation between
                adjacent points in the curve. Initially the curve attribute is
                null, which means that the WaveShaperNode will pass its input
                to its output without modification.
              </p>
              <p>
                Values of the curve are spread with equal spacing in the [-1;
                1] range. This means that a <a><code>curve</code></a> with a
                even number of value will not have a value for a signal at
                zero, and a <a><code>curve</code></a> with an odd number of
                value will have a value for a signal at zero.
              </p>
              <p>
                A <code>InvalidStateError</code> MUST be thrown if this
                attribute is set with a <code>Float32Array</code> that has a
                <code>length</code> less than 2.
              </p>
              <p>
                When this attribute is set, an internal copy of the curve is
                created by the <a><code>WaveShaperNode</code></a>. Subsequent
                modifications of the contents of the array used to set the
                attribute therefore have no effect: the attribute MUST be set
                again in order to change the curve.
              </p>
              <p>
                To set the <code>curve</code> attribute, execute these steps:
              </p>
              <ol>
                <li>Let <code>new curve</code> be the <code>Float32Array</code>
                to be assigned to <code>curve</code>.
                </li>
                <li>If <code>new curve</code> is not <code>null</code> and
                <code>curve set</code> is true, throw an
                <code>InvalidStateError</code> and abort these steps.
                </li>
                <li>If <code>new curve</code> is not <code>null</code>, set
                <code>curve set</code> to true.
                </li>
                <li>Assign <code>new curve</code> to the <code>curve</code>
                attribute.
                </li>
              </ol>
            </dd>
            <dt>
              <code><dfn>overSample</dfn></code> of type <span class=
              "idlAttrType"><a><code>OverSampleType</code></a></span>
            </dt>
            <dd>
              <p>
                Specifies what type of oversampling (if any) should be used
                when applying the shaping curve. The default value is "none",
                meaning the curve will be applied directly to the input
                samples. A value of "2x" or "4x" can improve the quality of the
                processing by avoiding some aliasing, with the "4x" value
                yielding the highest quality. For some applications, it's
                better to use no oversampling in order to get a very precise
                shaping curve.
              </p>
              <p>
                A value of "2x" or "4x" means that the following steps MUST be
                performed:
              </p>
              <ol>
                <li>Up-sample the input samples to 2x or 4x the sample-rate of
                the <a><code>AudioContext</code></a>. Thus for each <a>render
                quantum</a>, generate 256 (for 2x) or 512 (for 4x) samples.
                </li>
                <li>Apply the shaping curve.
                </li>
                <li>Down-sample the result back to the sample-rate of the
                <a><code>AudioContext</code></a>. Thus taking the 256 (or 512)
                processed samples, generating 128 as the final result.
                </li>
              </ol>
              <p>
                The exact up-sampling and down-sampling filters are not
                specified, and can be tuned for sound quality (low aliasing,
                etc.), low latency, and performance.
              </p>
              <p class="note">
                Use of oversampling introduces some degree of audio processing
                latency due to the up-sampling and down-sampling filters. The
                amount of this latency can vary from one implementation to
                another.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>WaveShaperOptions</dfn>
          </h2>
          <p>
            This specifies the options for constructing a
            <a><code>WaveShaperNode</code></a>. All members are optional; if
            not specified, the normal default is used in constructing the node.
          </p>
          <pre class="idl">
dictionary WaveShaperOptions : AudioNodeOptions {
             sequence&lt;float&gt; curve;
             OverSampleType  oversample = "none";
};
        </pre>
          <section>
            <h3>
              Dictionary <a>WaveShaperOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="WaveShaperOptions"
            data-link-for="WaveShaperOptions">
              <dt>
                <code><dfn>curve</dfn></code> of type <span class=
                "idlAttrType"><code>sequence&lt;float&gt;</code></span>
              </dt>
              <dd>
                The shaping curve for the waveshaping effect.
              </dd>
              <dt>
                <code><dfn>oversample</dfn></code> of type <span class=
                "idlAttrType"><a><code>OverSampleType</code></a></span>,
                defaulting to "none"
              </dt>
              <dd>
                The type of oversampling to use for the shaping curve.
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2>
          The OscillatorNode Interface
        </h2>
        <p>
          <a><code>OscillatorNode</code></a> represents an audio source
          generating a periodic waveform. It can be set to a few commonly used
          waveforms. Additionally, it can be set to an arbitrary periodic
          waveform through the use of a <a><code>PeriodicWave</code></a>
          object.
        </p>
        <p>
          Oscillators are common foundational building blocks in audio
          synthesis. An OscillatorNode will start emitting sound at the time
          specified by the <code>start()</code> method.
        </p>
        <p>
          Mathematically speaking, a <em>continuous-time</em> periodic waveform
          can have very high (or infinitely high) frequency information when
          considered in the frequency domain. When this waveform is sampled as
          a discrete-time digital audio signal at a particular sample-rate,
          then care MUST be taken to discard (filter out) the high-frequency
          information higher than the <a>Nyquist frequency</a> before
          converting the waveform to a digital form. If this is not done, then
          <em>aliasing</em> of higher frequencies (than the <a>Nyquist
          frequency</a>) will fold back as mirror images into frequencies lower
          than the <a>Nyquist frequency</a>. In many cases this will cause
          audibly objectionable artifacts. This is a basic and well understood
          principle of audio DSP.
        </p>
        <p>
          There are several practical approaches that an implementation may
          take to avoid this aliasing. Regardless of approach, the
          <em>idealized</em> discrete-time digital audio signal is well defined
          mathematically. The trade-off for the implementation is a matter of
          implementation cost (in terms of CPU usage) versus fidelity to
          achieving this ideal.
        </p>
        <p>
          It is expected that an implementation will take some care in
          achieving this ideal, but it is reasonable to consider lower-quality,
          less-costly approaches on lower-end hardware.
        </p>
        <p>
          Both <code>frequency</code> and <code>detune</code> are <a>a-rate</a>
          parameters, and form a <a>compound parameter</a>. They are used
          together to determine a <em>computedFrequency</em> value:
        </p>
        <pre>
  computedFrequency(t) = frequency(t) * pow(2, detune(t) / 1200)
</pre>
        <p>
          The OscillatorNode's instantaneous phase at each time is the definite
          time integral of <em>computedFrequency</em>, assuming a phase angle
          of zero at the node's exact start time. Its <a>nominal range</a> is
          [-<a>Nyquist frequency</a>, <a>Nyquist frequency</a>].
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                0
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <pre class="idl">
enum OscillatorType {
    "sine",
    "square",
    "sawtooth",
    "triangle",
    "custom"
};
        </pre>
        <table class="simple" data-dfn-for="OscillatorType" data-link-for=
        "OscillatorType">
          <tr>
            <th colspan="2">
              Enumeration description
            </th>
          </tr>
          <tr>
            <td>
              <dfn>sine</dfn>
            </td>
            <td>
              A sine wave
            </td>
          </tr>
          <tr>
            <td>
              <dfn>square</dfn>
            </td>
            <td>
              A square wave of duty period 0.5
            </td>
          </tr>
          <tr>
            <td>
              <dfn>sawtooth</dfn>
            </td>
            <td>
              A sawtooth wave
            </td>
          </tr>
          <tr>
            <td>
              <dfn>triangle</dfn>
            </td>
            <td>
              A triangle wave
            </td>
          </tr>
          <tr>
            <td>
              <dfn>custom</dfn>
            </td>
            <td>
              A custom periodic wave
            </td>
          </tr>
        </table>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional OscillatorOptions options)]
interface OscillatorNode : AudioScheduledSourceNode {
                    attribute OscillatorType type;
    readonly        attribute AudioParam     frequency;
    readonly        attribute AudioParam     detune;
    void setPeriodicWave (PeriodicWave periodicWave);
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="OscillatorNode" data-link-for=
          "OscillatorNode">
            <dt>
              <code><dfn>OscillatorNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>OscillatorNode</a> object.
                <a href="#audionode-constructor-init">Initialize</a>
                <var>node</var>, and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new <a>OscillatorNode</a>
                    will be <a href="#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>OscillatorOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>OscillatorNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="OscillatorNode" data-link-for=
          "OscillatorNode">
            <dt>
              <code><dfn>detune</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                A detuning value (in cents) which will offset the
                <a><code>frequency</code></a> by the given amount. It forms a
                <a>compound parameter</a> with <code>frequency</code>.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      0
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      <a>most-negative-single-float</a>
                    </td>
                    <td>
                      Approximately -3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>most-positive-single-float</a>
                    </td>
                    <td>
                      Approximately 3.4028235e38
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>a-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>frequency</dfn></code> of type <span class=
              "idlAttrType"><a><code>AudioParam</code></a></span>, readonly
            </dt>
            <dd>
              <p>
                The frequency (in Hertz) of the periodic waveform. It forms a
                <a>compound parameter</a> with <code>detune</code>.
              </p>
              <div class="audioparam-info">
                <table>
                  <tr>
                    <th>
                      Parameter
                    </th>
                    <th>
                      Value
                    </th>
                    <th>
                      Notes
                    </th>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">defaultValue</a>
                    </td>
                    <td>
                      440
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">minValue</a>
                    </td>
                    <td>
                      -<a>Nyquist frequency</a>
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a data-link-for="AudioParam">maxValue</a>
                    </td>
                    <td>
                      <a>Nyquist frequency</a>
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      Rate
                    </td>
                    <td>
                      <a>a-rate</a>
                    </td>
                    <td></td>
                  </tr>
                </table>
              </div>
            </dd>
            <dt>
              <code><dfn>type</dfn></code> of type <span class=
              "idlAttrType"><a><code>OscillatorType</code></a></span>
            </dt>
            <dd>
              The shape of the periodic waveform. It may directly be set to any
              of the type constant values except for "custom". <span class=
              "synchronous">Doing so MUST throw an
              <code>InvalidStateError</code> exception.</span> The
              <a data-link-for=
              "OscillatorNode"><code>setPeriodicWave()</code></a> method can be
              used to set a custom waveform, which results in this attribute
              being set to "custom". The default value is "sine". When this
              attribute is set, the phase of the oscillator MUST be conserved.
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Methods
          </h3>
          <dl class="methods" data-dfn-for="OscillatorNode" data-link-for=
          "OscillatorNode">
            <dt>
              <code><dfn>setPeriodicWave</dfn></code>
            </dt>
            <dd>
              Sets an arbitrary custom periodic waveform given a
              <a><code>PeriodicWave</code></a>.
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    periodicWave
                  </td>
                  <td class="prmType">
                    <a><code>PeriodicWave</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc"></td>
                </tr>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>OscillatorOptions</dfn>
          </h2>
          <p>
            This specifies the options to be used when constructing an
            <a><code>OscillatorNode</code></a>. All of the members are
            optional; if not specified, the normal default values are used for
            constructing the oscillator.
          </p>
          <pre class="idl">
dictionary OscillatorOptions : AudioNodeOptions {
             OscillatorType type = "sine";
             float          frequency = 440;
             float          detune = 0;
             PeriodicWave   periodicWave;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>OscillatorOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="OscillatorOptions"
            data-link-for="OscillatorOptions">
              <dt>
                <code><dfn>detune</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 0
              </dt>
              <dd>
                The initial detune value for the
                <a><code>OscillatorNode</code></a>.
              </dd>
              <dt>
                <code><dfn>frequency</dfn></code> of type <span class=
                "idlAttrType"><code>float</code></span>, defaulting to 440
              </dt>
              <dd>
                The initial frequency for the
                <a><code>OscillatorNode</code></a>.
              </dd>
              <dt>
                <code><dfn>periodicWave</dfn></code> of type <span class=
                "idlAttrType"><code>PeriodicWave</code></span>
              </dt>
              <dd>
                The <a><code>PeriodicWave</code></a> for the
                <a><code>OscillatorNode</code></a>. If this is specified, then
                any valid value for <a data-link-for=
                "OscillatorOptions"><code>type</code></a> is ignored; it is
                treated as if "custom" were specified.
              </dd>
              <dt>
                <code><dfn>type</dfn></code> of type <span class=
                "idlAttrType"><code>OscillatorType</code></span>, defaulting to
                "sine"
              </dt>
              <dd>
                The type of oscillator to be constructed. If this is set to
                "custom" without also specifying a <a data-link-for=
                "OscillatorOptions"><code>periodicWave</code></a>, then an
                <span class="synchronous"><code>InvalidStateError</code>
                exception MUST be thrown</span>. If <a data-link-for=
                "OscillatorOptions"><code>periodicWave</code></a> is specified,
                then any valid value for <a data-link-for=
                "OscillatorOptions"><code>type</code></a> is ignored; it is
                treated as if it were set to "custom".
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h2>
            Basic Waveform Phase
          </h2>
          <p>
            The idealized mathematical waveforms for the various oscillator
            types are defined here. In summary, all waveforms are defined
            mathematically to be an odd function with a positive slope at time
            0. The actual waveforms produced by the oscillator may differ to
            prevent aliasing affects.
          </p>
          <p>
            The oscillator MUST produce the same result as if a PeriodicWave
            with the appropriate <a href="#oscillator-coefficients">Fourier
            series</a> and with normalization enabled were used to create these
            basic waveforms.
          </p>
          <dl>
            <dt>
              "sine"
            </dt>
            <dd>
              The waveform for sine oscillator is:
              <pre class="nohighlight">
                $$
                  x(t) = \sin t
                $$.

</pre>
            </dd>
            <dt>
              "square"
            </dt>
            <dd>
              The waveform for the square wave oscillator is:
              <pre class="nohighlight">
                $$
                  x(t) = \begin{cases}
                         1 & \mbox{for } 0â‰¤ t &lt; \pi \\
                         -1 & \mbox{for } -\pi &lt; t &lt; 0.
                         \end{cases}
                $$
              </pre>
              <p>
                This is extended to all \(t\) by using the fact that the
                waveform is an odd function with period \(2\pi\).
              </p>
            </dd>
            <dt>
              "sawtooth"
            </dt>
            <dd>
              The waveform for the sawtooth oscillator is the ramp:
              <pre class="nohighlight">
                $$
                  x(t) = \frac{t}{\pi} \mbox{ for } -\pi &lt; t â‰¤ \pi;
                $$
              </pre>
              <p>
                This is extended to all \(t\) by using the fact that the
                waveform is an odd function with period \(2\pi\).
              </p>
            </dd>
            <dt>
              "triangle"
            </dt>
            <dd>
              The waveform for the triangle oscillator is:
              <pre class="nohighlight">
                $$
                  x(t) = \begin{cases}
                           \frac{2}{\pi} t & \mbox{for } 0 â‰¤ t â‰¤ \frac{\pi}{2} \\
                           1-\frac{2}{\pi} (t-\frac{\pi}{2}) & \mbox{for }
                           \frac{\pi}{2} &lt; t â‰¤ \pi.
                         \end{cases}
                $$
              </pre>
              <p>
                This is extended to all \(t\) by using the fact that the
                waveform is an odd function with period \(2\pi\).
              </p>
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h2>
          The <dfn>PeriodicWave</dfn> Interface
        </h2>
        <p>
          PeriodicWave represents an arbitrary periodic waveform to be used
          with an <a><code>OscillatorNode</code></a>.
        </p>
        <p>
          A <a>conforming implementation</a> MUST support <a>PeriodicWave</a>
          up to at least 8192 elements.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional PeriodicWaveOptions options)]
interface PeriodicWave {
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="PeriodicWave" data-link-for=
          "PeriodicWave">
            <dt>
              <code>PeriodicWave</code>
            </dt>
            <dd>
              <ol>
                <li>Let <var>p</var> be a new <a>PeriodicWave</a> object. Let
                <var>[[associated context]]</var> be a reference to the
                <a>BaseAudioContext</a> passed as first argument of this
                constructor.
                </li>
                <li>If the <var>real</var> and <var>imag</var> parameters of
                the <a>PeriodicWaveOptions</a> are not of the same length, an
                <code>IndexSizeError</code> exception MUST be thrown.
                </li>
                <li>If <var>options</var> has not been passed in, let
                <var>[[\real]]</var> and <var>[[\imag]]</var> be two internal
                slots of type <code>Float32Array</code> and length 2. Set the
                second element of the <var>[[\imag]]</var> array be 1.
                  <div class="note">
                    When setting this <a>PeriodicWave</a> on an
                    <a>OscillatorNode</a>, this is equivalent to using the
                    built-in type <code>"sine"</code>.
                  </div>
                </li>
                <li>Otherwise, let <var>[[\real]]</var> and
                <var>[[\imag]]</var> be two internal slots of type
                <code>Float32Array</code>, of length both equal to the maximum
                length of the <var>real</var> and <var>imag</var> of the
                attributes of the <a>PeriodicWaveOptions</a> passed in.
                  <a href="https://heycam.github.io/webidl/#dfn-get-buffer-source-copy">
                  Make a copy</a> of those arrays into their respective
                  internal slots.
                </li>
                <li>Let [[\normalize]] be an internal slot of the
                <a>PeriodicWave</a> the is initialized to the inverse of the
                <var>disableNormalization</var> attribute of the
                <a>PeriodicWaveConstraints</a> on the
                <a>PeriodicWaveOptions</a>.
                </li>
                <li>Return <var>p</var>.
                </li>
              </ol>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    <p>
                      The <a>BaseAudioContext</a> this new <a>PeriodicWave</a>
                      will be <a href="#associated">associated</a> with.
                    </p>
                    <p>
                      Unlike <a>AudioBuffer</a>, <a>PeriodicWave</a>s can't be
                      shared accross <a>AudioContext</a>s or
                      <a>OfflineAudioContext</a>s. It is associated with a
                      particular <a>BaseAudioContext</a>.
                    </p>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>PeriodicWaveOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>PeriodicWave</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>PeriodicWaveConstraints</dfn>
          </h2>
          <p>
            The <code>PeriodicWaveConstraints</code> dictionary is used to
            specify how the waveform is normalized.
          </p>
          <pre class="idl">
dictionary PeriodicWaveConstraints {
             boolean disableNormalization = false;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>PeriodicWaveConstraints</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="PeriodicWaveConstraints"
            data-link-for="PeriodicWaveConstraints">
              <dt>
                <code><dfn>disableNormalization</dfn></code> of type
                <span class="idlAttrType"><code>boolean</code></span>,
                defaulting to false
              </dt>
              <dd>
                Controls whether the periodic wave is normalized or not. If
                <code>true</code>, the waveform is not normalized; otherwise,
                the waveform is normalized.
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h2>
            <dfn>PeriodicWaveOptions</dfn>
          </h2>
          <p>
            The <code>PeriodicWaveOptions</code> dictionary is used to specify
            how the waveform is constructed. If only one of <code>real</code>
            or <code>imag</code> is specified. the other is treated as if it
            were an array of all zeroes of the same length, as specified below
            in <a href="#dictionary-periodicwaveoptions-members">description of
            the dictionary members</a>. If neither is given, a
            <a><code>PeriodicWave</code></a> is created that MUST be equivalent
            to an <a><code>OscillatorNode</code></a> with
            <code><a data-link-for="OscillatorNode">type</a></code> "sine". If
            both are given, the sequences must have the same length; otherwise
            an <span class="synchronous">error of type
            <code>NotSupportedError</code> MUST be thrown</span>.
          </p>
          <pre class="idl">
dictionary PeriodicWaveOptions : PeriodicWaveConstraints {
             sequence&lt;float&gt; real;
             sequence&lt;float&gt; imag;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>PeriodicWaveOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="PeriodicWaveOptions"
            data-link-for="PeriodicWaveOptions">
              <dt>
                <code><dfn>imag</dfn></code> of type <span class=
                "idlAttrType"><code>sequence&lt;float&gt;</code></span>
              </dt>
              <dd>
                <p>
                  The <a>imag</a> parameter represents an array of
                  <code>sine</code> terms. The first element (index 0) does not
                  exist in the Fourier series. Implementations MUST set it to
                  zero when computing the waveform. The second element (index
                  1) represents the fundamental frequency. The third element
                  represents the first overtone, and so on.
                </p>
                <p>
                  This defaults to a sequence of all zeroes of the same length
                  as <a><code>real</code></a> if <a><code>real</code></a> is
                  given.
                </p>
              </dd>
              <dt>
                <code><dfn>real</dfn></code> of type <span class=
                "idlAttrType"><code>sequence&lt;float&gt;</code></span>
              </dt>
              <dd>
                <p>
                  The <a>real</a> parameter represents an array of
                  <code>cosine</code> terms. The first element (index 0) is the
                  DC-offset of the periodic waveform. Implementations MUST set
                  it to zero when computing the waveform. The second element
                  (index 1) represents the fundamental frequency. The third
                  element represents the first overtone, and so on.
                </p>
                <p>
                  This defaults to a sequence of all zeroes of the same length
                  as <a><code>imag</code></a> if <a><code>imag</code></a> is
                  given.
                </p>
              </dd>
            </dl>
          </section>
        </section>
        <section>
          <h2>
            Waveform Generation
          </h2>
          <p>
            The <a data-link-for="BaseAudioContext">createPeriodicWave()</a>
            method takes two arrays to specify the Fourier coefficients of the
            PeriodicWave. Let \(a\) and \(b\) represent the real and imaginary
            arrays of length \(L\). Then the basic time-domain waveform,
            \(x(t)\), can be computed using:
          </p>
          <pre class="nohighlight">
            $$
              x(t) = \sum_{k=1}^{L-1} \left(a[k]\cos2\pi k t + b[k]\sin2\pi k t\right)
            $$
          </pre>
          <p>
            This is the basic (unnormalized) waveform.
          </p>
        </section>
        <section>
          <h2>
            Waveform Normalization
          </h2>
          <p>
            If the internal slot <var>[[\normalize]]</var> of this
            <a>PeriodicWave</a> is <code>true</code> (the default), the
            waveform defined in the previous section is normalized so that the
            maximum value is 1. The normalization is done as follows.
          </p>
          <p>
            Let
          </p>
          <pre class="nohighlight">
          $$
            \tilde{x}(n) = \sum_{k=1}^{L-1} \left(a[k]\cos\frac{2\pi k n}{N} + b[k]\sin\frac{2\pi k n}{N}\right)
          $$

</pre>
          <p>
            where \(N\) is a power of two. (Note: \(\tilde{x}(n)\) can
            conveniently be computed using an inverse FFT.) The fixed
            normalization factor \(f\) is computed as follows.
          </p>
          <pre class="nohighlight">
            $$
              f = \max_{n = 0, \ldots, N - 1} |\tilde{x}(n)|
            $$

</pre>
          <p>
            Thus, the actual normalized waveform \(\hat{x}(n)\) is:
          </p>
          <pre class="nohighlight">
            $$
              \hat{x}(n) = \frac{\tilde{x}(n)}{f}
            $$

</pre>
          <p>
            This fixed normalization factor MUST be applied to all generated
            waveforms.
          </p>
        </section>
        <section>
          <h2>
            Oscillator Coefficients
          </h2>
          <p>
            The builtin oscillator types are created using <a>PeriodicWave</a>
            objects. For completeness the coefficients for the PeriodicWave for
            each of the builtin oscillator types is given here. This is useful
            if a builtin type is desired but without the default normalization.
          </p>
          <p>
            In the following descriptions, let \(a\) be the array of real
            coefficients and \(b\) be the array of imaginary coefficients for
            <a data-link-for="BaseAudioContext">createPeriodicWave()</a>. In
            all cases \(a[n] = 0\) for all \(n\) because the waveforms are odd
            functions. Also, \(b[0] = 0\) in all cases. Hence, only \(b[n]\)
            for \(n \ge 1\) is specified below.
          </p>
          <dl>
            <dt>
              "sine"
            </dt>
            <dd>
              <pre class="nohighlight">
                  $$
                    b[n] = \begin{cases}
                             1 & \mbox{for } n = 1 \\
                             0 & \mbox{otherwise}
                           \end{cases}
                  $$

</pre>
            </dd>
            <dt>
              "square"
            </dt>
            <dd>
              <pre class="nohighlight">
                  $$
                    b[n] = \frac{2}{n\pi}\left[1 - (-1)^n\right]
                  $$

</pre>
            </dd>
            <dt>
              "sawtooth"
            </dt>
            <dd>
              <pre class="nohighlight">
                $$
                  b[n] = (-1)^{n+1} \dfrac{2}{n\pi}
                $$

</pre>
            </dd>
            <dt>
              "triangle"
            </dt>
            <dd>
              <pre class="nohighlight">
                  $$
                    b[n] = \frac{8\sin\dfrac{n\pi}{2}}{(\pi n)^2}
                  $$

</pre>
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h2 id="MediaStreamAudioSourceNode">
          The MediaStreamAudioSourceNode Interface
        </h2>
        <p>
          This interface represents an audio source from a
          <code>MediaStream</code>. The track that will be used as the source
          of audio and will be output from this node is the first
          <code>MediaStreamTrack</code> whose <code>kind</code> attribute has
          the value <code>"audio"</code>, when alphabetically sorting the
          tracks of this <code>MediaStream</code> by their <code>id</code>
          attribute. Those interfaces are described in
          [[!mediacapture-streams]].
        </p>
        <p class="note">
          The behaviour for picking the track to output is weird for legacy
          reasons. <a>MediaStreamTrackAudioSourceNode</a> should be used
          instead.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                0
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <p>
          The number of channels of the output corresponds to the number of
          channels of the <code>MediaStreamTrack</code>. If there is no valid
          audio track, then the number of channels output will be one silent
          channel.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, MediaStreamAudioSourceOptions options)]
interface MediaStreamAudioSourceNode : AudioNode {
    [SameObject] readonly        attribute MediaStream mediaStream;
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="MediaStreamAudioSourceNode"
          data-link-for="MediaStreamAudioSourceNode">
            <dt>
              <code><dfn>MediaStreamAudioSourceNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new <a>MediaStreamAudioSourceNode</a>
                object. <a href="#audionode-constructor-init">Initialize</a>
                <var>node</var>, and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new
                    <a>MediaStreamAudioSourceNode</a> will be <a href=
                    "#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>MediaStreamAudioSourceOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    Initial parameter values for this
                    <a>MediaStreamAudioSourceNode</a>. If the
                    <code>mediaStream</code> parameter does not reference a
                    <code>MediaStream</code> whose <code>kind</code> attribute
                    has the value <code>"audio"</code>, <span class=
                    "synchronous">an <code>InvalidStateError</code> MUST be
                    thrown</span>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="MediaStreamAudioSourceNode"
          data-link-for="MediaStreamAudioSourceNode">
            <dt>
              <code><dfn>mediaStream</dfn></code> of type <span class=
              "idlAttrType"><a><code>MediaStream</code></a></span>, readonly
            </dt>
            <dd>
              The <code>MediaStream</code> used when constructing this
              <a>MediaStreamAudioSourceNode</a>.
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>MediaStreamAudioSourceOptions</dfn>
          </h2>
          <p>
            This specifies the options for constructing a
            <a><code>MediaStreamAudioSourceNode</code></a>.
          </p>
          <pre class="idl">
dictionary MediaStreamAudioSourceOptions {
    required MediaStream mediaStream;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>MediaStreamAudioSourceOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for="MediaStreamAudioSourceOptions"
            data-link-for="MediaStreamAudioSourceOptions">
              <dt>
                <code><dfn>mediaStream</dfn></code> of type <span class=
                "idlAttrType"><code>MediaStream</code></span>, required
              </dt>
              <dd>
                The media stream that will act as a source. This MUST be
                specified.
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2 id="MediaStreamTrackAudioSourceNode">
          The MediaStreamTrackAudioSourceNode Interface
        </h2>
        <p>
          This interface represents an audio source from a
          <code>MediaStreamTrack</code>.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                0
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <p>
          The number of channels of the output corresponds to the number of
          channels of the <code>MediaStreamTrack</code>.
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (AudioContext context, MediaStreamTrackAudioSourceOptions options)]
interface MediaStreamTrackAudioSourceNode : AudioNode {
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="MediaStreamTrackAudioSourceNode"
          data-link-for="MediaStreamTrackAudioSourceNode">
            <dt>
              <code><dfn>MediaStreamTrackAudioSourceNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new
                <a>MediaStreamTrackAudioSourceNode</a> object. <a href=
                "#audionode-constructor-init">Initialize</a> <var>node</var>,
                and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new
                    <a>MediaStreamTrackAudioSourceNode</a> will be <a href=
                    "#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>MediaStreamTrackAudioSourceOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    Initial parameter value for this
                    <a>MediaStreamTrackAudioSourceNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>
            <dfn>MediaStreamTrackAudioSourceOptions</dfn>
          </h2>
          <p>
            This specifies the options for constructing a
            <a><code>MediaStreamTrackAudioSourceNode</code></a>. This is
            required.
          </p>
          <pre class="idl">
dictionary MediaStreamTrackAudioSourceOptions {
    required MediaStreamTrack mediaStreamTrack;
};
        </pre>
          <section>
            <h3>
              Dictionary <a>MediaStreamTrackAudioSourceOptions</a> Members
            </h3>
            <dl class="attributes" data-dfn-for=
            "MediaStreamTrackAudioSourceOptions" data-link-for=
            "MediaStreamTrackAudioSourceOptions">
              <dt>
                <code><dfn>mediaStreamTrack</dfn></code> of type <span class=
                "idlAttrType"><code>MediaStreamTrack</code></span>, readonly
              </dt>
              <dd>
                The audio media stream track that will act as a source.
              </dd>
            </dl>
          </section>
        </section>
      </section>
      <section>
        <h2>
          The MediaStreamAudioDestinationNode Interface
        </h2>
        <p>
          This interface is an audio destination representing a
          <code>MediaStream</code> with a single <code>MediaStreamTrack</code>
          whose <code>kind</code> is <code>"audio"</code>. This MediaStream is
          created when the node is created and is accessible via the
          <dfn>stream</dfn> attribute. This stream can be used in a similar way
          as a <code>MediaStream</code> obtained via
          <code>getUserMedia()</code>, and can, for example, be sent to a
          remote peer using the <code>RTCPeerConnection</code> (described in
          [[!webrtc]]) <code>addStream()</code> method.
        </p>
        <div class="node-info">
          <table>
            <tr>
              <th>
                Property
              </th>
              <th>
                Value
              </th>
              <th>
                Notes
              </th>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfInputs</a>
              </td>
              <td>
                1
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">numberOfOutputs</a>
              </td>
              <td>
                0
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCount</a>
              </td>
              <td>
                2
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelCountMode</a>
              </td>
              <td>
                "<a data-link-for="channelCountMode">explicit</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a data-link-for="AudioNode">channelInterpretation</a>
              </td>
              <td>
                "<a data-link-for="channelInterpretation">speakers</a>"
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                <a>tail-time</a> reference
              </td>
              <td>
                No
              </td>
              <td></td>
            </tr>
          </table>
        </div>
        <p>
          The number of channels of the input is by default 2 (stereo).
        </p>
        <pre class="idl">
[Exposed=Window,
 Constructor (BaseAudioContext context, optional AudioNodeOptions options)]
interface MediaStreamAudioDestinationNode : AudioNode {
    readonly        attribute MediaStream stream;
};
        </pre>
        <section>
          <h3>
            Constructors
          </h3>
          <dl class="methods" data-dfn-for="MediaStreamAudioDestinationNode"
          data-link-for="MediaStreamAudioDestinationNode">
            <dt>
              <code><dfn>MediaStreamAudioDestinationNode</dfn></code>
            </dt>
            <dd>
              <p>
                Let <var>node</var> be a new
                <a>MediaStreamAudioDestinationNode</a> object. <a href=
                "#audionode-constructor-init">Initialize</a> <var>node</var>,
                and return <var>node</var>.
              </p>
              <table class="parameters">
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    context
                  </td>
                  <td class="prmType">
                    <a><code>BaseAudioContext</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmDesc">
                    The <a>BaseAudioContext</a> this new
                    <a>MediaStreamAudioDestinationNode</a> will be <a href=
                    "#associated">associated</a> with.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    options
                  </td>
                  <td class="prmType">
                    <a><code>AudioNodeOptions</code></a>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">âœ˜</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">âœ”</span>
                  </td>
                  <td class="prmDesc">
                    Optional initial parameter value for this
                    <a>MediaStreamAudioDestinationNode</a>.
                  </td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h3>
            Attributes
          </h3>
          <dl class="attributes" data-dfn-for="MediaStreamAudioDestinationNode"
          data-link-for="MediaStreamAudioDestinationNode">
            <dt>
              <code><dfn>stream</dfn></code> of type <span class=
              "idlAttrType"><a><code>MediaStream</code></a></span>, readonly
            </dt>
            <dd>
              A MediaStream containing a single MediaStreamTrack with the same
              number of channels as the node itself, and whose
              <code>kind</code> attribute has the value <code>"audio"</code>.
            </dd>
          </dl>
        </section>
      </section>
    </section>
    <section>
      <h2>
        Processing model
      </h2>
      <section class="informative">
        <h3>
          Background
        </h3>
        <p>
          Real-time audio systems that require low latency are often
          implemented using <em>callback functions</em>, where the operating
          system calls the program back when more audio has to be computed in
          order for the playback to stay uninterrupted. Such callback is called
          on a high priority thread (often the highest priority on the system).
          This means that a program that deals with audio only executes code
          from this callback, as any buffering between a rendering thread and
          the callback would naturally add latency or make the system less
          resilient to glitches.
        </p>
        <p>
          For this reason, the traditional way of executing asynchronous
          operations on the Web Platform, the event loop, does not work here,
          as the thread is not <em>continuously executing</em>. Additionally, a
          lot of unnecessary and potentially blocking operations are available
          from traditional execution contexts (Windows and Workers), which is
          not something that is desirable to reach an acceptable level of
          performance.
        </p>
        <p>
          Additionally, the Worker model makes creating a dedicated thread
          necessary for a script execution context, while all <a>AudioNode</a>s
          usually share the same execution context.
        </p>
        <p class="note">
          This section specifies how the end result should look like, not how
          it should be implemented. In particular, instead of using message
          queue, implementors can use memory that is shared between threads, as
          long as the memory operations are not reordered.
        </p>
      </section>
      <section>
        <h3>
          Control thread and rendering thread
        </h3>
        <p>
          The Web Audio API MUST be implemented using a <a>control thread</a>,
          and a <a>rendering thread</a>.
        </p>
        <p>
          The <dfn>control thread</dfn> is the thread from which the
          <a>AudioContext</a> is instantiated, and from which authors
          manipulate the audio graph, that is, from where the operation on a
          <a>BaseAudioContext</a> are invoked. The <dfn>rendering thread</dfn>
          is the thread on which the actual audio output is computed, in
          reaction to the calls from the <a>control thread</a>. It can be a
          real-time, callback-based audio thread, if computing audio for an
          <a>AudioContext</a>, or a normal thread if rendering and audio graph
          offline using an <a>OfflineAudioContext</a>.
        </p>
        <p>
          The <a>control thread</a> uses a traditional event loop, as described
          in [[HTML]].
        </p>
        <p>
          The <a>rendering thread</a> uses a specialized rendering loop,
          described in the section <a href="#rendering-loop">Rendering an audio
          graph</a>
        </p>
        <p>
          Communication from the <a>control thread</a> to the <a>rendering
          thread</a> is done using <a>control message</a> passing.
          Communication in the other direction is done using regular event loop
          tasks.
        </p>
        <p>
          Each <a>AudioContext</a> has a single <dfn>control message
          queue</dfn>, that is a list of <dfn data-lt="control message">control
          messages</dfn> that are operations running on the <a>control
          thread</a>.
        </p>
        <p>
          <dfn id="queuing">Queuing a control message</dfn> means adding the
          message to the end of the <a>control message queue</a> of an
          <a>AudioContext</a>.
        </p>
        <p>
          <a>Control messages</a> in a <a>control message queue</a> are ordered
          by time of insertion. The <dfn>oldest message</dfn> is therefore the
          one at the front of the <a>control message queue</a>.
        </p>
        <p>
          <dfn data-lt="swap">Swapping</dfn> a <a>control message queue</a>
          <var>Q<sub>A</sub></var> with another <a>control message queue</a>
          <var>Q<sub>B</sub></var> means executing the following steps:
        </p>
        <ol>
          <li>Let <var>Q<sub>C</sub></var> be a new, empty <a>control message
          queue</a>.
          </li>
          <li>Move all the <a>control messages</a> <var>Q<sub>A</sub></var> to
          <var>Q<sub>C</sub></var>.
          </li>
          <li>Move all the <a>control messages</a> <var>Q<sub>B</sub></var> to
          <var>Q<sub>A</sub></var>.
          </li>
          <li>Move all the <a>control messages</a> <var>Q<sub>C</sub></var> to
          <var>Q<sub>B</sub></var>.
          </li>
        </ol>
        <p class="note">
          For example, successfuly calling <code>start()</code> on an
          <a>AudioBufferSourceNode</a> <code>source</code> adds a <a>control
          message</a> to the <a href="#control-message-queue">control message
          queue</a> of the <a>AudioContext</a> <code>source.context</code>.
        </p>
      </section>
      <section>
        <h3>
          Asynchronous operations
        </h3>
        <p>
          Calling methods on <a>AudioNode</a>s is effectively asynchronous, and
          MUST to be done in two phases, a synchronous part and an asynchronous
          part. For each method, some part of the execution happens on the
          <a>control thread</a> (for example, throwing an exception in case of
          invalid parameters), and some part happens on the <a>rendering
          thread</a> (for example, changing the value of an <a>AudioParam</a>).
        </p>
        <p>
          In the description of each operation on <a>AudioNode</a>s and
          <a>AudioContext</a>s, the synchronous section is marked with a âŒ›. All
          the other operations are executed <a href=
          "https://html.spec.whatwg.org/multipage/infrastructure.html#in-parallel">
          in parallel</a>, as described in [[HTML]].
        </p>
        <p>
          The synchronous section is executed on the <a>control thread</a>, and
          happens immediately. If it fails, the method execution is aborted,
          possibly throwing an exception. If it succeeds, a <a>control
          message</a>, encoding the operation to be executed on the
          <a>rendering thread</a> is enqueued on the <a>control message
          queue</a> of this <a>rendering thread</a>.
        </p>
        <p>
          The synchronous and asynchronous sections order with respect to other
          events MUST be the same: given two operation <var>A</var> and
          <var>B</var> with respective synchronous and asynchronous section
          <var>A<sub>Sync</sub></var> and <var>A<sub>Async</sub></var>, and
          <var>B<sub>Sync</sub></var> and <var>B<sub>Async</sub></var>, if
          <var>A</var> happens before <var>B</var>, then
          <var>A<sub>Sync</sub></var> happens before
          <var>B<sub>Sync</sub></var>, and <var>A<sub>Async</sub></var> happens
          before <var>B<sub>Async</sub></var>. In other words, synchronous and
          asynchronous sections can't be reordered.
        </p>
      </section>
      <section id="rendering-loop">
        <h3>
          Rendering an audio graph
        </h3>
        <p>
          Rendering an audio graph is done in blocks of 128 samples-frames. A
          block of 128 samples-frames is called a <dfn>render quantum</dfn>.
        </p>
        <p>
          Operations that happen <dfn data-lt="atomic">atomically</dfn> on a
          given thread can only be executed when no other <a>atomic</a>
          operation is running on another thread.
        </p>
        <p>
          The algorithm for rendering a block of audio from an
          <a>AudioContext</a> <em>G</em> with a <a href=
          "#control-message-queue">control message queue</a> <em>Q</em> is as
          follows.
        </p>
        <p>
          If the algorithm returns true then it MUST be executed again in the
          future, to render the next block of audio. Else, the <a>rendering
          thread</a> yields and the processing stops. The <a>control thread</a>
          can restart executing this algoritm if needed.
        </p>
        <div class="note">
          <p>
            In practice, the <a>AudioContext</a> <a>rendering thread</a> is
            often running off a system level audio callback, that executes in
            an isochronous fashion. This callback passes in a buffer that has
            to be filled with the audio that will be output. The size of the
            buffer is often larger than a rendering quantum. In this case,
            multiple invocations of the rendering algorithm will be called in a
            rapid succession, in the same callback, before returning. After
            some time, the underlying audio system will call the callback
            again, and the algorithm will be executed again. This is an
            implementation detail that should not be observable, apart from the
            latency implications.
          </p>
          <p>
            <a>OfflineAudioContext</a> will execute the algorithm continuously,
            until <var>length</var> (as passed in the
            <a>OfflineAudioContext</a> contructor) frames have been rendered.
          </p>
        </div>
        <ol>
          <li>Let <em>Q<sub>rendering</sub></em> be an empty <a>control message
          queue</a>. <a>Atomically</a> <a>swap</a>
          <em>Q<sub>rendering</sub></em> and <em>Q</em>
          </li>
          <li>While there are messages in <em>Q<sub>rendering</sub></em>,
          execute the following steps:
            <ol>
              <li>Execute the asynchronous section of the <a>oldest message</a>
              of <em>Q<sub>rendering</sub></em>.
              </li>
              <li>Remove the <a>oldest message</a> of
              <em>Q<sub>rendering</sub></em>.
              </li>
            </ol>
          </li>
          <li>If the <a>rendering thread state</a> of the <a>AudioContext</a>
          is not <code>running</code>, return false.
          </li>
          <li>Order the <a>AudioNode</a>s of the <a>AudioContext</a> to be
          processed.
            <ol>
              <li>Let <em>ordered</em> be an empty list of <a>AudioNode</a>s.
              It will contain an ordered list of <a>AudioNode</a>s when this
              ordering algorithm terminates.
              </li>
              <li>Let <em>nodes</em> be the set of all nodes created by this
              <a>AudioContext</a>, and still alive.
              </li>
              <li>Let <em>cycle breakers</em> be an empty set of
              <a>DelayNode</a>s. It will contain all the <a>DelayNode</a>s that
              are part of a cycle.
              </li>
              <li>For each <a>AudioNode</a> <em>node</em> in <em>nodes</em>
                <ol>
                  <li>If <em>node</em> is a <a>DelayNode</a> that is part of a
                  cycle, add it to <em>cycle breakers</em> and remove it from
                  <em>nodes</em>.
                  </li>
                </ol>
              </li>
              <li>If <em>nodes</em> contains cycles, <a href="#mute">mute</a>
              all the <a>AudioNode</a>s that are part of this cycle, and remove
              them from <em>nodes</em>.
              </li>
              <li>While there are unmarked <a>AudioNode</a>s in <em>nodes</em>:
                <ol>
                  <li>Choose an <a>AudioNode</a> <em>node</em> in
                  <em>nodes</em>
                  </li>
                  <li>
                    <a>Visit</a> <em>node</em>.
                  </li>
                </ol><dfn data-lt="Visit">Visiting a node</dfn> <em>node</em>
                mean performing the following steps:
                <ol>
                  <li>If <em>node</em> is marked, abort these steps.
                  </li>
                  <li>Mark <em>node</em>.
                  </li>
                  <li>For each <a>AudioNode</a> <em>input</em> connected to
                  <em>node</em>:
                    <ol>
                      <li>
                        <a>Visit</a> <em>input</em>.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>Add <em>node</em> to the beginning of <em>ordered</em>.
              </li>
            </ol>
          </li>
          <li>Reverse the order of <em>nodes</em>.
          </li>
          <li>For each <a>DelayNode</a> in a cycle, <a href="#available">make
          available for reading</a> a block of audio from the <a>DelayNode</a>
          buffer, available for reading.
          </li>
          <li>
            <a href="#computation-of-value">Compute the value(s)</a> of the
            <a>AudioListener</a>'s <a>AudioParam</a>s for this block.
          </li>
          <li>For each <a>AudioNode</a>, in the order determined previously:
            <ol>
              <li>For each <a>AudioParam</a> of this <a>AudioNode</a>, execute
              these steps:
                <ol>
                  <li>If this <a>AudioParam</a> has any <a>AudioNode</a>
                  connected to it, <a href="#SummingJunction">sum</a> the
                  buffers <a href="#available">made available for reading</a>
                  by all <a>AudioNode</a> connected to this <a>AudioParam</a>,
                  <a href="#down-mix">down mix</a> the resulting buffer down to
                  Mono, and call this buffer the <dfn id=
                  "input-audioparam-buffer">input <a>AudioParam</a>
                  buffer</dfn>.
                  </li>
                  <li>
                    <a href="#computation-of-value">Compute the value(s)</a> of
                    this <a>AudioParam</a> for this block.
                  </li>
                  <li>
                    <a href="#queue">Queue a control message</a> to set the
                    <var>[[current value]]</var> slot of this <a>AudioParam</a>
                    to the last value computed in the preceding step.
                  </li>
                </ol>
              </li>
              <li>If this <a>AudioNode</a> has any <a>AudioNode</a>s connected
              to its input, <a href="#SummingJunction">sum</a> the buffers
              <a href="#available">made available for reading</a> by all
              <a>AudioNode</a>s connected to this <a>AudioNode</a>. The
              resulting buffer is called the <dfn>input buffer</dfn>.
                <a href="#channel-up-mixing-and-down-mixing">Up or down-mix</a>
                it to match if number of input channels of this
                <a>AudioNode</a>.
              </li>
              <li>If this <a>AudioNode</a> is a <a>source node</a>, <a href=
              "computing">compute a block of audio</a>, and <a href=
              "#available">make it available for reading</a>.
              </li>
              <li>Else, if this <a>AudioNode</a> is a <a>destination node</a>,
              <a href="record">record the input</a> of this <a>AudioNode</a>.
              </li>
              <li>Else, <a>process</a> the <a>input buffer</a>, and <a href=
              "#available">make available for reading</a> the resulting buffer.
              </li>
            </ol>
          </li>
          <li>
            <a>Atomically</a> increment <a data-link-for=
            "BaseAudioContext">currentTime</a> by 128 / <a data-link-for=
            "BaseAudioContext">sampleRate</a>.
          </li>
          <li>Return true.
          </li>
        </ol>
        <ul>
          <li style="list-style: none; display: inline">
            <p>
              <dfn id="mute">Muting</dfn> an <a>AudioNode</a> means that its
              output MUST be silence for the rendering of this audio block.
            </p>
            <p>
              <dfn id="available">Making a buffer available for reading</dfn>
              from an <a>AudioNode</a> means putting it in a state where other
              <a>AudioNode</a>s connected to this <a>AudioNode</a> can safely
              read from it.
            </p>
            <p class="note">
              For example, implementations can choose to allocate a new buffer,
              or have a more elaborate mechanism, reusing an existing buffer
              that is now unused.
            </p>
            <p>
              <dfn id="record">Recording the input</dfn> of an <a>AudioNode</a>
              means copying the input data of this <a>AudioNode</a> for future
              usage.
            </p>
            <p>
              <dfn id="computing">Computing a block of audio</dfn> means
              running the algorithm for this <a>AudioNode</a> to produce 128
              sample-frames.
            </p>
            <p>
              <dfn data-lt="process">Processing an input buffer</dfn> means
              running the algorithm for an <a>AudioNode</a>, using an <a>input
              buffer</a> and the value(s) of the <a>AudioParam</a>(s) of this
              <a>AudioNode</a> as the input for this algorithm.
            </p>
          </li>
        </ul>
      </section>
    </section>
    <section class="informative">
      <h2>
        Mixer Gain Structure
      </h2>
      <h3 id="background">
        Background
      </h3>
      <p>
        One of the most important considerations when dealing with audio
        processing graphs is how to adjust the gain (volume) at various points.
        For example, in a standard mixing board model, each input bus has
        pre-gain, post-gain, and send-gains. Submix and master out busses also
        have gain control. The gain control described here can be used to
        implement standard mixing boards as well as other architectures.
      </p>
      <section>
        <h3 id="SummingJunction">
          Summing Inputs
        </h3>
        <p>
          The inputs to <a><code>AudioNode</code></a>s have the ability to
          accept connections from multiple outputs. The input then acts as a
          unity gain summing junction with each output signal being added with
          the others:
        </p>
        <figure>
          <img alt="unity gain summing junction" src=
          "images/unity-gain-summing-junction.png" width="442" height="198">
          <figcaption>
            A graph showing Source 1 and Source 2 output summed at the input of
            Destination
          </figcaption>
        </figure>
        <p>
          In cases where the channel layouts of the outputs do not match, a mix
          (usually up-mix) will occur according to the <a href=
          "#channel-up-mixing-and-down-mixing">mixing rules</a>.
        </p>
        <p>
          No clipping is applied at the inputs or outputs of the
          <a><code>AudioNode</code></a> to allow a maximum of dynamic range
          within the audio graph.
        </p>
      </section>
      <section>
        <h3>
          Gain Control
        </h3>
        <p>
          In many scenarios, it's important to be able to control the gain for
          each of the output signals. The <a><code>GainNode</code></a> gives
          this control:
        </p>
        <figure>
          <img alt="mixer architecture new" src=
          "images/mixer-architecture-new.png" width="455" height="198">
          <figcaption>
            A graph featuring volume control for each voice
          </figcaption>
        </figure>
        <p>
          Using these two concepts of unity gain summing junctions and
          GainNodes, it's possible to construct simple or complex mixing
          scenarios.
        </p>
      </section>
      <section>
        <h3 id="Example-mixer-with-send-busses">
          Example: Mixer with Send Busses
        </h3>
        <p>
          In a routing scenario involving multiple sends and submixes, explicit
          control is needed over the volume or "gain" of each connection to a
          mixer. Such routing topologies are very common and exist in even the
          simplest of electronic gear sitting around in a basic recording
          studio.
        </p>
        <p>
          Here's an example with two send mixers and a main mixer. Although
          possible, for simplicity's sake, pre-gain control and insert effects
          are not illustrated:
        </p>
        <figure>
          <img alt="mixer gain structure" src="images/mixer-gain-structure.png"
          width="710" height="634">
          <figcaption>
            A graph showing a full mixer with send busses.
          </figcaption>
        </figure>
        <p>
          This diagram is using a shorthand notation where "send 1", "send 2",
          and "main bus" are actually inputs to <a><code>AudioNode</code></a>s,
          but here are represented as summing busses, where the intersections
          g2_1, g3_1, etc. represent the "gain" or volume for the given source
          on the given mixer. In order to expose this gain, a
          <a><code>GainNode</code></a> is used:
        </p>
        <p>
          Here's how the above diagram could be constructed in JavaScript:
        </p>
        <pre class="example">

  var context = 0;
  var compressor = 0;
  var reverb = 0;
  var delay = 0;
  var s1 = 0;
  var s2 = 0;

  var source1 = 0;
  var source2 = 0;
  var g1_1 = 0;
  var g2_1 = 0;
  var g3_1 = 0;
  var g1_2 = 0;
  var g2_2 = 0;
  var g3_2 = 0;

  // Setup routing graph
  function setupRoutingGraph() {
      context = new AudioContext();

      compressor = context.createDynamicsCompressor();

      // Send1 effect
      reverb = context.createConvolver();
      // Convolver impulse response may be set here or later

      // Send2 effect
      delay = context.createDelay();

      // Connect final compressor to final destination
      compressor.connect(context.destination);

      // Connect sends 1 & 2 through effects to main mixer
      s1 = context.createGain();
      reverb.connect(s1);
      s1.connect(compressor);

      s2 = context.createGain();
      delay.connect(s2);
      s2.connect(compressor);

      // Create a couple of sources
      source1 = context.createBufferSource();
      source2 = context.createBufferSource();
      source1.buffer = manTalkingBuffer;
      source2.buffer = footstepsBuffer;

      // Connect source1
      g1_1 = context.createGain();
      g2_1 = context.createGain();
      g3_1 = context.createGain();
      source1.connect(g1_1);
      source1.connect(g2_1);
      source1.connect(g3_1);
      g1_1.connect(compressor);
      g2_1.connect(reverb);
      g3_1.connect(delay);

      // Connect source2
      g1_2 = context.createGain();
      g2_2 = context.createGain();
      g3_2 = context.createGain();
      source2.connect(g1_2);
      source2.connect(g2_2);
      source2.connect(g3_2);
      g1_2.connect(compressor);
      g2_2.connect(reverb);
      g3_2.connect(delay);

      // We now have explicit control over all the volumes g1_1, g2_1, ..., s1, s2
      g2_1.gain.value = 0.2;  // For example, set source1 reverb gain

      // Because g2_1.gain is an "AudioParam",
      // an automation curve could also be attached to it.
      // A "mixing board" UI could be created in canvas or WebGL controlling these gains.
  }


</pre>
      </section>
    </section>
    <section>
      <h2 id="DynamicLifetime">
        Dynamic Lifetime
      </h2>
      <section>
        <h3>
          Background
        </h3>
        <p class="norm">
          <em>This section is non-normative. Please see <a href=
          "#lifetime-AudioContext">AudioContext lifetime</a> and <a href=
          "#lifetime-AudioNode">AudioNode lifetime</a> for normative
          requirements.</em>
        </p>
        <p>
          In addition to allowing the creation of static routing
          configurations, it should also be possible to do custom effect
          routing on dynamically allocated voices which have a limited
          lifetime. For the purposes of this discussion, let's call these
          short-lived voices "notes". Many audio applications incorporate the
          ideas of notes, examples being drum machines, sequencers, and 3D
          games with many one-shot sounds being triggered according to game
          play.
        </p>
        <p>
          In a traditional software synthesizer, notes are dynamically
          allocated and released from a pool of available resources. The note
          is allocated when a MIDI note-on message is received. It is released
          when the note has finished playing either due to it having reached
          the end of its sample-data (if non-looping), it having reached a
          sustain phase of its envelope which is zero, or due to a MIDI
          note-off message putting it into the release phase of its envelope.
          In the MIDI note-off case, the note is not released immediately, but
          only when the release envelope phase has finished. At any given time,
          there can be a large number of notes playing but the set of notes is
          constantly changing as new notes are added into the routing graph,
          and old ones are released.
        </p>
        <p>
          The audio system automatically deals with tearing-down the part of
          the routing graph for individual "note" events. A "note" is
          represented by an <a><code>AudioBufferSourceNode</code></a>, which
          can be directly connected to other processing nodes. When the note
          has finished playing, the context will automatically release the
          reference to the <a><code>AudioBufferSourceNode</code></a>, which in
          turn will release references to any nodes it is connected to, and so
          on. The nodes will automatically get disconnected from the graph and
          will be deleted when they have no more references. Nodes in the graph
          which are long-lived and shared between dynamic voices can be managed
          explicitly. Although it sounds complicated, this all happens
          automatically with no extra handling required.
        </p>
      </section>
      <section>
        <h3>
          Example
        </h3>
        <figure>
          <img alt="dynamic allocation" src="images/dynamic-allocation.png"
          width="671" height="221">
          <figcaption>
            A graph featuring a subgraph that will be releases early.
          </figcaption>
        </figure>
        <p>
          The low-pass filter, panner, and second gain nodes are directly
          connected from the one-shot sound. So when it has finished playing
          the context will automatically release them (everything within the
          dotted line). If there are no longer any references to the one-shot
          sound and connected nodes, then they will be immediately removed from
          the graph and deleted. The streaming source, has a global reference
          and will remain connected until it is explicitly disconnected. Here's
          how it might look in JavaScript:
        </p>
        <pre class="example">

var context = 0;
var compressor = 0;
var gainNode1 = 0;
var streamingAudioSource = 0;

// Initial setup of the "long-lived" part of the routing graph
function setupAudioContext() {
    context = new AudioContext();

    compressor = context.createDynamicsCompressor();
    gainNode1 = context.createGain();

    // Create a streaming audio source.
    var audioElement = document.getElementById('audioTagID');
    streamingAudioSource = context.createMediaElementSource(audioElement);
    streamingAudioSource.connect(gainNode1);

    gainNode1.connect(compressor);
    compressor.connect(context.destination);
}

// Later in response to some user action (typically mouse or key event)
// a one-shot sound can be played.
function playSound() {
    var oneShotSound = context.createBufferSource();
    oneShotSound.buffer = dogBarkingBuffer;

    // Create a filter, panner, and gain node.
    var lowpass = context.createBiquadFilter();
    var panner = context.createPanner();
    var gainNode2 = context.createGain();

    // Make connections
    oneShotSound.connect(lowpass);
    lowpass.connect(panner);
    panner.connect(gainNode2);
    gainNode2.connect(compressor);

    // Play 0.75 seconds from now (to play immediately pass in 0)
    oneShotSound.start(context.currentTime + 0.75);
}
</pre>
      </section>
    </section>
    <section>
      <h2>
        Channel up-mixing and down-mixing
      </h2>
      <p class="norm">
        This section is normative.
      </p>
      <p>
        <a href="#mixer-gain-structure"></a> describes how an input to an
        <a><code>AudioNode</code></a> can be connected from one or more outputs
        of an <a><code>AudioNode</code></a>. Each of these connections from an
        output represents a stream with a specific non-zero number of channels.
        An input has <em>mixing rules</em> for combining the channels from all
        of the connections to it. As a simple example, if an input is connected
        from a mono output and a stereo output, then the mono connection will
        usually be up-mixed to stereo and summed with the stereo connection.
        But, of course, it's important to define the exact <em>mixing
        rules</em> for every input to every <a><code>AudioNode</code></a>. The
        default mixing rules for all of the inputs have been chosen so that
        things "just work" without worrying too much about the details,
        especially in the very common case of mono and stereo streams. Of
        course, the rules can be changed for advanced use cases, especially
        multi-channel.
      </p>
      <p>
        To define some terms, <em>up-mixing</em> refers to the process of
        taking a stream with a smaller number of channels and converting it to
        a stream with a larger number of channels. <em>down-mixing</em> refers
        to the process of taking a stream with a larger number of channels and
        converting it to a stream with a smaller number of channels.
      </p>
      <p>
        An <a><code>AudioNode</code></a> input use three basic pieces of
        information to determine how to mix all the outputs connected to it. As
        part of this process it computes an internal value
        <code><dfn>computedNumberOfChannels</dfn></code> representing the
        actual number of channels of the input at any given time:
      </p>
      <p>
        The <a><code>AudioNode</code></a> attributes involved in channel
        up-mixing and down-mixing rules are defined <a href=
        "#the-audionode-interface">above</a>. The following is a more precise
        specification on what each of them mean.
      </p>
      <ul>
        <li>
          <a data-link-for="AudioNode"><code>channelCount</code></a> is used to
          help compute <a><code>computedNumberOfChannels</code></a>.
        </li>
        <li>
          <a data-link-for="AudioNode"><code>channelCountMode</code></a>
          determines how <a><code>computedNumberOfChannels</code></a> will be
          computed. Once this number is computed, all of the connections will
          be up or down-mixed to that many channels. For most nodes, the
          default value is "<a data-link-for="ChannelCountMode">max</a>".
          <ul>
            <li>"<a data-link-for="ChannelCountMode">max</a>":
            <a><code>computedNumberOfChannels</code></a> is computed as the
            maximum of the number of channels of all connections. In this mode
            <a data-link-for="AudioNode"><code>channelCount</code></a> is
            ignored.
            </li>
            <li>"<a data-link-for="ChannelCountMode">clamped-max</a>": same as
            â€œmaxâ€ up to a limit of the <a data-link-for=
            "AudioNode"><code>channelCount</code></a>
            </li>
            <li>"<a data-link-for="ChannelCountMode">explicit</a>":
            <a><code>computedNumberOfChannels</code></a> is the exact value as
            specified in <a data-link-for=
            "AudioNode"><code>channelCount</code></a>
            </li>
          </ul>
        </li>
        <li>
          <a data-link-for="AudioNode"><code>channelInterpretation</code></a>
          determines how the individual channels will be treated. For example,
          will they be treated as speakers having a specific layout, or will
          they be treated as simple discrete channels? This value influences
          exactly how the up and down mixing is performed. The default value is
          "speakers".
          <ul>
            <li>"<a data-link-for="ChannelInterpretation">speakers</a>": use
            <a href="#ChannelLayouts">up-down-mix equations for
            mono/stereo/quad/5.1</a>. In cases where the number of channels do
            not match any of these basic speaker layouts, revert to "discrete".
            </li>
            <li>"<a data-link-for="ChannelInterpretation">discrete</a>": up-mix
            by filling channels until they run out then zero out remaining
            channels. down-mix by filling as many channels as possible, then
            dropping remaining channels
            </li>
          </ul>
        </li>
      </ul>
      <p>
        For each input of an <a><code>AudioNode</code></a>, an implementation
        MUST:
      </p>
      <ol>
        <li>Compute <a><code>computedNumberOfChannels</code></a>.
        </li>
        <li>For each connection to the input:
          <ul>
            <li>up-mix or down-mix the connection to
            <a><code>computedNumberOfChannels</code></a> according to
            <a data-link-for=
            "AudioNode"><code>channelInterpretation</code></a>.
            </li>
            <li>Mix it together with all of the other mixed streams (from other
            connections). This is a straight-forward mixing together of each of
            the corresponding channels from each connection.
            </li>
          </ul>
        </li>
      </ol>
      <section>
        <h3 id="ChannelLayouts">
          Speaker Channel Layouts
        </h3>
        <p>
          When <a data-link-for=
          "AudioNode"><code>channelInterpretation</code></a> is
          "<a data-link-for="ChannelInterpretation">speakers</a>" then the
          up-mixing and down-mixing is defined for specific channel layouts.
        </p>
        <p>
          Mono (one channel), stereo (two channels), quad (four channels), and
          5.1 (six channels) MUST be supported. Other channel layouts may be
          supported in future version of this specification.
        </p>
      </section>
      <section>
        <h4 id="ChannelOrdering">
          Channel ordering
        </h4>
        <p>
          Channel ordering is defined by the following table. Individual
          multichannel formats MAY not support all intermediate channels.
          Implementations MUST present the channels provided in the order
          defined below, skipping over those channels not present.
        </p>
        <table class="channels">
          <tr>
            <th>
              Order
            </th>
            <th>
              Label
            </th>
            <th>
              Mono
            </th>
            <th>
              Stereo
            </th>
            <th>
              Quad
            </th>
            <th>
              5.1
            </th>
          </tr>
          <tr>
            <td>
              0
            </td>
            <td>
              SPEAKER_FRONT_LEFT
            </td>
            <td>
              0
            </td>
            <td>
              0
            </td>
            <td>
              0
            </td>
            <td>
              0
            </td>
          </tr>
          <tr>
            <td>
              1
            </td>
            <td>
              SPEAKER_FRONT_RIGHT
            </td>
            <td></td>
            <td>
              1
            </td>
            <td>
              1
            </td>
            <td>
              1
            </td>
          </tr>
          <tr>
            <td>
              2
            </td>
            <td>
              SPEAKER_FRONT_CENTER
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td>
              2
            </td>
          </tr>
          <tr>
            <td>
              3
            </td>
            <td>
              SPEAKER_LOW_FREQUENCY
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td>
              3
            </td>
          </tr>
          <tr>
            <td>
              4
            </td>
            <td>
              SPEAKER_BACK_LEFT
            </td>
            <td></td>
            <td></td>
            <td>
              2
            </td>
            <td>
              4
            </td>
          </tr>
          <tr>
            <td>
              5
            </td>
            <td>
              SPEAKER_BACK_RIGHT
            </td>
            <td></td>
            <td></td>
            <td>
              3
            </td>
            <td>
              5
            </td>
          </tr>
          <tr>
            <td>
              6
            </td>
            <td>
              SPEAKER_FRONT_LEFT_OF_CENTER
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              7
            </td>
            <td>
              SPEAKER_FRONT_RIGHT_OF_CENTER
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              8
            </td>
            <td>
              SPEAKER_BACK_CENTER
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              9
            </td>
            <td>
              SPEAKER_SIDE_LEFT
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              10
            </td>
            <td>
              SPEAKER_SIDE_RIGHT
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              11
            </td>
            <td>
              SPEAKER_TOP_CENTER
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              12
            </td>
            <td>
              SPEAKER_TOP_FRONT_LEFT
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              13
            </td>
            <td>
              SPEAKER_TOP_FRONT_CENTER
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              14
            </td>
            <td>
              SPEAKER_TOP_FRONT_RIGHT
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              15
            </td>
            <td>
              SPEAKER_TOP_BACK_LEFT
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              16
            </td>
            <td>
              SPEAKER_TOP_BACK_CENTER
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              17
            </td>
            <td>
              SPEAKER_TOP_BACK_RIGHT
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
        </table>
      </section>
      <section>
        <h4 id="UpMix-sub">
          Up Mixing speaker layouts
        </h4>
        <pre>
Mono up-mix:

    1 -&gt; 2 : up-mix from mono to stereo
        output.L = input;
        output.R = input;

    1 -&gt; 4 : up-mix from mono to quad
        output.L = input;
        output.R = input;
        output.SL = 0;
        output.SR = 0;

    1 -&gt; 5.1 : up-mix from mono to 5.1
        output.L = 0;
        output.R = 0;
        output.C = input; // put in center channel
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Stereo up-mix:

    2 -&gt; 4 : up-mix from stereo to quad
        output.L = input.L;
        output.R = input.R;
        output.SL = 0;
        output.SR = 0;

    2 -&gt; 5.1 : up-mix from stereo to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Quad up-mix:

    4 -&gt; 5.1 : up-mix from quad to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = input.SL;
        output.SR = input.SR;
</pre>
      </section>
      <section>
        <h4 id="down-mix">
          Down Mixing speaker layouts
        </h4>
        <p>
          A down-mix will be necessary, for example, if processing 5.1 source
          material, but playing back stereo.
        </p>
        <pre>
  Mono down-mix:

      2 -&gt; 1 : stereo to mono
          output = 0.5 * (input.L + input.R);

      4 -&gt; 1 : quad to mono
          output = 0.25 * (input.L + input.R + input.SL + input.SR);

      5.1 -&gt; 1 : 5.1 to mono
          output = sqrt(0.5) * (input.L + input.R) + input.C + 0.5 * (input.SL + input.SR)


  Stereo down-mix:

      4 -&gt; 2 : quad to stereo
          output.L = 0.5 * (input.L + input.SL);
          output.R = 0.5 * (input.R + input.SR);

      5.1 -&gt; 2 : 5.1 to stereo
          output.L = L + sqrt(0.5) * (input.C + input.SL)
          output.R = R + sqrt(0.5) * (input.C + input.SR)

  Quad down-mix:

      5.1 -&gt; 4 : 5.1 to quad
          output.L = L + sqrt(0.5) * input.C
          output.R = R + sqrt(0.5) * input.C
          output.SL = input.SL
          output.SR = input.SR


</pre>
      </section>
      <section class="informative">
        <h3 id="ChannelRules-section">
          Channel Rules Examples
        </h3>
        <pre class="example">
  // Set gain node to explicit 2-channels (stereo).
  gain.channelCount = 2;
  gain.channelCountMode = "explicit";
  gain.channelInterpretation = "speakers";

  // Set "hardware output" to 4-channels for DJ-app with two stereo output busses.
  context.destination.channelCount = 4;
  context.destination.channelCountMode = "explicit";
  context.destination.channelInterpretation = "discrete";

  // Set "hardware output" to 8-channels for custom multi-channel speaker array
  // with custom matrix mixing.
  context.destination.channelCount = 8;
  context.destination.channelCountMode = "explicit";
  context.destination.channelInterpretation = "discrete";

  // Set "hardware output" to 5.1 to play an HTMLAudioElement.
  context.destination.channelCount = 6;
  context.destination.channelCountMode = "explicit";
  context.destination.channelInterpretation = "speakers";

  // Explicitly down-mix to mono.
  gain.channelCount = 1;
  gain.channelCountMode = "explicit";
  gain.channelInterpretation = "speakers";

</pre>
      </section>
    </section>
    <section>
      <h2 id="audio-sample-values">
        Audio Signal Values
      </h2>
      <p>
        The range of all audio signals at a destination node of any audio graph
        is nominally [-1, 1]. The audio rendition of signal values outside this
        range, or of the values <code>NaN</code>, positive infinity or negative
        infinity, is undefined by this specification.
      </p>
    </section>
    <section>
      <h2 id="Spatialization">
        <dfn>Spatialization/Panning</dfn>
      </h2>
      <section>
        <h3 id="Spatialization-background">
          Background
        </h3>
        <p>
          A common feature requirement for modern 3D games is the ability to
          dynamically spatialize and move multiple audio sources in 3D space.
          Game audio engines such as OpenAL, FMOD, Creative's EAX, Microsoft's
          XACT Audio, etc. have this ability.
        </p>
        <p>
          Using an <a><code>PannerNode</code></a>, an audio stream can be
          spatialized or positioned in space relative to an
          <a><code>AudioListener</code></a>. An
          <a><code>AudioContext</code></a> will contain a single
          <a><code>AudioListener</code></a>. Both panners and listeners have a
          position in 3D space using a right-handed cartesian coordinate
          system. The units used in the coordinate system are not defined, and
          do not need to be because the effects calculated with these
          coordinates are independent/invariant of any particular units such as
          meters or feet. <a><code>PannerNode</code></a> objects (representing
          the source stream) have an <em>orientation</em> vector representing
          in which direction the sound is projecting. Additionally, they have a
          <em>sound cone</em> representing how directional the sound is. For
          example, the sound could be omnidirectional, in which case it would
          be heard anywhere regardless of its orientation, or it can be more
          directional and heard only if it is facing the listener.
          <a><code>AudioListener</code></a> objects (representing a person's
          ears) have an <em>orientation</em> and <em>up</em> vector
          representing in which direction the person is facing.
        </p>
        <p>
          During rendering, the <a><code>PannerNode</code></a> calculates an
          <em>azimuth</em> and <em>elevation</em>. These values are used
          internally by the implementation in order to render the
          spatialization effect. See the <a href=
          "#Spatialization-panning-algorithm">Panning Algorithm</a> section for
          details of how these values are used.
        </p>
      </section>
      <section id="azimuth-elevation">
        <h3>
          Azimuth and Elevation
        </h3>
        <p>
          The following algorithm MUST be used to calculate the
          <em>azimuth</em> and <em>elevation</em> for the
          <a><code>PannerNode</code></a>:
        </p>
        <pre>
  // Calculate the source-listener vector.
  let listener = context.listener;
  let sourcePosition =
    new Vec3(panner.positionX, panner.positionY, panner.positionZ);
  let listenerPosition =
    new Vec3(listener.positionX, listener.positionY, listener.positionZ);
  let sourceListener = sourcePosition.diff(listenerPosition).normalize();

  if (sourceListener.magnitude == 0) {
      // Handle degenerate case if source and listener are at the same point.
      azimuth = 0;
      elevation = 0;
      return;
  }

  // Align axes.
  let listenerFront =
    new Vec3(listener.orientationX, listener.orientationY, listener.orientationZ);
  let listenerUp =
    new Vec3(listener.upX, listener.upY, listener.upZ);
  let listenerRight = listenerFront.cross(listenerUp).normalize();
  let listenerFrontNorm = listenerFront.normalize();
  let up = listenerRight.cross(listenerFrontNorm);
  let upProjection = sourceListener.dot(up);
  let projectedSource = sourceListener.diff(up.scale(upProjection)).normalize();

  azimuth = 180 * Math.acos(projectedSource.dot(listenerRight)) / PI;

  // Source in front or behind the listener.
  let frontBack = projectedSource.dot(listenerFrontNorm);
  if (frontBack &lt; 0)
      azimuth = 360 - azimuth;

  // Make azimuth relative to "front" and not "right" listener vector.
  if ((azimuth &gt;= 0) &amp;& (azimuth &lt;= 270))
      azimuth = 90 - azimuth;
  else
      azimuth = 450 - azimuth;

  elevation = 90 - 180 * Math.acos(sourceListener.dot(up)) / PI;

  if (elevation &gt; 90)
      elevation = 180 - elevation;
  else if (elevation &lt; -90)
      elevation = -180 - elevation;

</pre>
      </section>
      <section>
        <h3 id="Spatialization-panning-algorithm">
          Panning Algorithm
        </h3>
        <p>
          <em>Mono-to-stereo</em> and <em>stereo-to-stereo</em> panning MUST be
          supported. <em>Mono-to-stereo</em> processing is used when all
          connections to the input are mono. Otherwise
          <em>stereo-to-stereo</em> processing is used.
        </p>
        <section>
          <h4 id="Spatialzation-equal-power-panning">
            PannerNode "equalpower" Panning
          </h4>
          <p>
            This is a simple and relatively inexpensive algorithm which
            provides basic, but reasonable results. It is used for the for the
            <a><code>PannerNode</code></a> when the <a data-link-for=
            "PannerNode"><code>panningModel</code></a> attribute is set to
            <code>"equalpower"</code>, in which case the <em>elevation</em>
            value is ignored. This algorithm MUST be implemented using
            <a>a-rate</a> parameters.
          </p>
          <ol>
            <li>For each sample to be computed by this <a>AudioNode</a>:
              <ol>
                <li>
                  <p>
                    Let <em>azimuth</em> be the value computed in the <a href=
                    "#azimuth-elevation">azimuth and elevation</a> section.
                  </p>
                </li>
                <li>
                  <p>
                    The <em>azimuth</em> value is first contained to be within
                    the range [-90, 90] according to:
                  </p>
                  <pre>
  // First, clamp azimuth to allowed range of [-180, 180].
  azimuth = max(-180, azimuth);
  azimuth = min(180, azimuth);

  // Then wrap to range [-90, 90].
  if (azimuth &lt; -90)
    azimuth = -180 - azimuth;
  else if (azimuth &gt; 90)
    azimuth = 180 - azimuth;
</pre>
                </li>
                <li>
                  <p>
                    A normalized value <em>x</em> is calculated from
                    <em>azimuth</em> for a mono input as:
                  </p>
                  <pre>
  x = (azimuth + 90) / 180;
</pre>
                  <p>
                    Or for a stereo input as:
                  </p>
                  <pre>
  if (azimuth &lt;= 0) { // -90 -&gt; 0
    // Transform the azimuth value from [-90, 0] degrees into the range [-90, 90].
    x = (azimuth + 90) / 90;
  } else { // 0 -&gt; 90
    // Transform the azimuth value from [0, 90] degrees into the range [-90, 90].
    x = azimuth / 90;
  }
</pre>
                </li>
                <li>
                  <p>
                    Left and right gain values are calculated as:
                  </p>
                  <pre>
    gainL = cos(x * Math.PI / 2);
    gainR = sin(x * Math.PI / 2);
</pre>
                </li>
                <li>
                  <p>
                    For mono input, the stereo output is calculated as:
                  </p>
                  <pre>
    outputL = input * gainL;
    outputR = input * gainR;
</pre>
                  <p>
                    Else for stereo input, the output is calculated as:
                  </p>
                  <pre>
    if (azimuth &lt;= 0) {
      outputL = inputL + inputR * gainL;
      outputR = inputR * gainR;
    } else {
      outputL = inputL * gainL;
      outputR = inputR + inputL * gainR;
    }
</pre>
                </li>
              </ol>
            </li>
          </ol>
        </section>
        <section>
          <h4>
            PannerNode "HRTF" Panning (stereo only)
          </h4>
          <p>
            This requires a set of <a href=
            "https://en.wikipedia.org/wiki/Head-related_transfer_function">HRTF</a>
            (Head-related Transfer Function) impulse responses recorded at a
            variety of azimuths and elevations. The implementation requires a
            highly optimized convolution function. It is somewhat more costly
            than "equalpower", but provides more perceptually spatialized
            sound.
          </p>
          <figure>
            <img alt="HRTF panner" src="images/HRTF_panner.png" width="644"
            height="419">
            <figcaption>
              A diagram showing the process of panning a source using HRTF.
            </figcaption>
          </figure>
        </section>
        <section>
          <h4 id="stereopanner-algorithm">
            StereoPannerNode Panning
          </h4>
          <p>
            For a <a><code>StereoPannerNode</code></a>, the following algorithm
            MUST be implemented.
          </p>
          <ol>
            <li>For each sample to be computed by this <a>AudioNode</a>
              <ol>
                <li>
                  <p>
                    Let <em>pan</em> be the <a>computedValue</a> of the
                    <code>pan</code> <a>AudioParam</a> of this
                    <a><code>StereoPannerNode</code></a>.
                  </p>
                </li>
                <li>
                  <p>
                    Clamp <em>pan</em> to [-1, 1].
                  </p>
                  <pre>
    pan = max(-1, pan);
    pan = min(1, pan);
</pre>
                </li>
                <li>
                  <p>
                    Calculate <em>x</em> by normalizing <em>pan</em> value to
                    [0, 1]. For mono input:
                  </p>
                  <pre>
    x = (pan + 1) / 2;
</pre>
                  <p>
                    For stereo input:
                  </p>
                  <pre>
    if (pan &lt;= 0)
      x = pan + 1;
    else
      x = pan;
</pre>
                </li>
                <li>
                  <p>
                    Left and right gain values are calculated as:
                  </p>
                  <pre>
    gainL = cos(x * Math.PI / 2);
    gainR = sin(x * Math.PI / 2);
</pre>
                </li>
                <li>
                  <p>
                    For mono input, the stereo output is calculated as:
                  </p>
                  <pre>
    outputL = input * gainL;
    outputR = input * gainR;
</pre>
                  <p>
                    Else for stereo input, the output is calculated as:
                  </p>
                  <pre>
    if (pan &lt;= 0) {
      outputL = inputL + inputR * gainL;
      outputR = inputR * gainR;
    } else {
      outputL = inputL * gainL;
      outputR = inputR + inputL * gainR;
    }
</pre>
                </li>
              </ol>
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h3 id="Spatialization-distance-effects">
          Distance Effects
        </h3>
        <p>
          Sounds which are closer are louder, while sounds further away are
          quieter. Exactly <em>how</em> a sound's volume changes according to
          distance from the listener depends on the <em>distanceModel</em>
          attribute.
        </p>
        <p>
          During audio rendering, a <em>distance</em> value will be calculated
          based on the panner and listener positions according to:
        </p>
        <pre>
function distance(panner) {
  let pannerPosition = new Vec3(panner.positionX, panner.positionY, panner.positionZ);
  let listener = context.listener;
  let listenerPosition = new Vec3(listener.positionX, listener.positionY, listener.positionZ);
  return pannerPosition.diff(listenerPosition).magnitude;
}  
</pre>
        <p>
          <em>distance</em> will then be used to calculate
          <em>distanceGain</em> which depends on the <em>distanceModel</em>
          attribute. See the <a data-link-for=
          "DistanceModelType">DistanceModelType</a> section for details of how
          this is calculated for each distance model. The value computed by the
          <a data-link-for="DistanceModelType">DistanceModelType</a> equations
          are to be clamped to [0, 1].
        </p>
        <p>
          As part of its processing, the <a><code>PannerNode</code></a>
          scales/multiplies the input audio signal by <em>distanceGain</em> to
          make distant sounds quieter and nearer ones louder.
        </p>
      </section>
      <section>
        <h3 id="Spatialization-sound-cones">
          Sound Cones
        </h3>
        <p>
          The listener and each sound source have an orientation vector
          describing which way they are facing. Each sound source's sound
          projection characteristics are described by an inner and outer "cone"
          describing the sound intensity as a function of the source/listener
          angle from the source's orientation vector. Thus, a sound source
          pointing directly at the listener will be louder than if it is
          pointed off-axis. Sound sources can also be omni-directional.
        </p>
        <p>
          The following algorithm MUST be used to calculate the gain
          contribution due to the cone effect, given the source (the
          <a><code>PannerNode</code></a>) and the listener:
        </p>
        <pre>
function coneGain() {
  let sourceOrientation = new Vec3(source.orientationX, source.orientationY, source.orientationZ);
  if (sourceOrientation.magnitude == 0 || ((source.coneInnerAngle ==
      360) &amp;& (source.coneOuterAngle == 360)))
    return 1; // no cone specified - unity gain

  // Normalized source-listener vector
  let sourcePosition =
    new Vec3(panner.positionX, panner.positionY, panner.positionZ);
  let listenerPosition =
    new Vec3(listener.positionX, listener.positionY, listener.positionZ);
  let sourceToListener = sourcePosition.diff(listenerPosition).normalize();

  let normalizedSourceOrientation = sourceOrientation.normalize();

  // Angle between the source orientation vector and the source-listener vector
  let angle = 180 * Math.acos(sourceToListener.dot(normalizedSourceOrientation)) / Math.PI;
  let absAngle = Math.abs(angle);

  // Divide by 2 here since API is entire angle (not half-angle)
  let absInnerAngle = Math.abs(source.coneInnerAngle) / 2;
  let absOuterAngle = Math.abs(source.coneOuterAngle) / 2;
  let gain = 1;

  if (absAngle &lt;= absInnerAngle) {
    // No attenuation
    gain = 1;
  } else if (absAngle &gt;= absOuterAngle) {
    // Max attenuation
    gain = source.coneOuterGain;
  } else {
    // Between inner and outer cones
    // inner -&gt; outer, x goes from 0 -&gt; 1
    var x = (absAngle - absInnerAngle) / (absOuterAngle - absInnerAngle);
    gain = (1 - x) + source.coneOuterGain * x;
  }

  return gain;
}
</pre>
      </section>
    </section>
    <section>
      <h2 id="Performance">
        Performance Considerations
      </h2>
      <section class="informative">
        <h3>
          Latency
        </h3>
        <figure>
          <img alt="latency" src="images/latency.png" width="700" height="201">
          <figcaption>
            Use cases in which the latency can be important
          </figcaption>
        </figure>
        <p>
          For web applications, the time delay between mouse and keyboard
          events (keydown, mousedown, etc.) and a sound being heard is
          important.
        </p>
        <p>
          This time delay is called latency and is caused by several factors
          (input device latency, internal buffering latency, DSP processing
          latency, output device latency, distance of user's ears from
          speakers, etc.), and is cumulative. The larger this latency is, the
          less satisfying the user's experience is going to be. In the extreme,
          it can make musical production or game-play impossible. At moderate
          levels it can affect timing and give the impression of sounds lagging
          behind or the game being non-responsive. For musical applications the
          timing problems affect rhythm. For gaming, the timing problems affect
          precision of gameplay. For interactive applications, it generally
          cheapens the users experience much in the same way that very low
          animation frame-rates do. Depending on the application, a reasonable
          latency can be from as low as 3-6 milliseconds to 25-50 milliseconds.
        </p>
        <p>
          Implementations will generally seek to minimize overall latency.
        </p>
        <p>
          Along with minimizing overall latency, implementations will generally
          seek to minimize the difference between an
          <a><code>AudioContext</code></a>'s <code>currentTime</code> and an
          <a><code>AudioProcessingEvent</code></a>'s <code>playbackTime</code>.
          Deprecation of <a><code>ScriptProcessorNode</code></a> will make this
          consideration less important over time.
        </p>Additionally, some <a>AudioNode</a>s can add latency to some paths
        of the audio graph, notably:
        <ul>
          <li>The <a>AudioWorkletNode</a> can run a script that buffers
          internally, adding delay to the signal path.
          </li>
          <li>The <a>DelayNode</a>, whose role is to add controlled latency
          time.
          </li>
          <li>The <a>BiquadFilterNode</a> and <a>IIRFilterNode</a> filter
          design can delay incoming samples, as a natural consequence of the
          causal filtering process.
          </li>
          <li>The <a>ConvolverNode</a> depending on the impulse, can delay
          incoming samples, as a natural result of the convolution operation.
          </li>
          <li>The <a>DynamicsCompressorNode</a> has a look ahead algorithm that
          causes delay in the signal path.
          </li>
          <li>The <a>MediaStreamAudioSourceNode</a>,
          <a>MediaStreamTrackAudioSourceNode</a> and
          <a>MediaStreamAudioDestinationNode</a>, depending on the
          implementation, can add buffers internally that add delays.
          </li>
          <li>The <a>ScriptProcessorNode</a> can have buffers between the
          control thread and the rendering thread.
          </li>
          <li>The <a>WaveShaperNode</a>, when oversampling, and depending on
          the oversampling technique, add delays to the signal path.
          </li>
        </ul>
      </section>
      <section>
        <h3>
          Audio Buffer Copying
        </h3>
        <p>
          When an <a href="#acquire-the-content">acquire the content</a>
          operation is performed on an <a>AudioBuffer</a>, the entire operation
          can usually be implemented without copying channel data. In
          particular, the last step SHOULD be performed lazily at the next
          <a data-link-for="AudioBuffer"><code>getChannelData</code></a> call.
          That means a sequence of consecutive <a href=
          "#acquire-the-content">acquire the contents</a> operations with no
          intervening <a data-link-for=
          "AudioBuffer"><code>getChannelData</code></a> (e.g. multiple
          <a><code>AudioBufferSourceNode</code></a>s playing the same
          <a><code>AudioBuffer</code></a>) can be implemented with no
          allocations or copying.
        </p>
        <p>
          Implementations can perform an additional optimization: if
          <a data-link-for="AudioBuffer">getChannelData</a> is called on an
          <a>AudioBuffer</a>, fresh <code>ArrayBuffer</code>s have not yet been
          allocated, but all invokers of previous <a href=
          "#acquire-the-content">acquire the content</a> operations on an
          <a>AudioBuffer</a> have stopped using the <a>AudioBuffer</a>'s data,
          the raw data buffers can be recycled for use with new
          <a>AudioBuffer</a>s, avoiding any reallocation or copying of the
          channel data.
        </p>
      </section>
      <section class="informative">
        <h3>
          AudioParam Transitions
        </h3>
        <p>
          While no automatic smoothing is done when directly setting the
          <a data-link-for="AudioParam"><code>value</code></a> attribute of an
          <a><code>AudioParam</code></a>, for certain parameters, smooth
          transition are preferable to directly setting the value.
        </p>
        <p>
          Using the <a data-link-for=
          "AudioParam"><code>setTargetAtTime</code></a> method with a low
          <code>timeConstant</code> allows authors to perform a smooth
          transition.
        </p>
      </section>
      <section>
        <h3>
          Audio Glitching
        </h3>
        <p>
          Audio glitches are caused by an interruption of the normal continuous
          audio stream, resulting in loud clicks and pops. It is considered to
          be a catastrophic failure of a multi-media system and MUST be
          avoided. It can be caused by problems with the threads responsible
          for delivering the audio stream to the hardware, such as scheduling
          latencies caused by threads not having the proper priority and
          time-constraints. It can also be caused by the audio DSP trying to do
          more work than is possible in real-time given the CPU's speed.
        </p>
      </section>
    </section>
    <section class="informative">
      <h2 id="Security-Privacy-Considerations">
        Security and Privacy Considerations
      </h2>
      <p>
        The W3C TAG is developing a <a href=
        "https://w3ctag.github.io/security-questionnaire/">Self-Review
        Questionnaire: Security and Privacy</a> for editors of specifications
        to informatively answer.
      </p>
      <p>
        Per the <a href=
        "https://w3ctag.github.io/security-questionnaire/#questions">Questions
        to Consider</a>
      </p>
      <ol class="seclist">
        <li>
          <p>
            Does this specification deal with personally-identifiable
            information?
          </p>
          <!-- assuming the audio context does not expose detailed information
         on audio device inputs and outputs; revisit this question after the
         fingerprinting analysis is done -->
          <p>
            No.
          </p>
        </li>
        <li>
          <p>
            Does this specification deal with high-value data?
          </p>
          <p>
            No. Credit card information and the like is not used in Web Audio.
            It is possible to use Web Audio to process or analyze voice data,
            which might be a privacy concern, but access to the user's
            microphone is permission-based via getUserMedia.
          </p>
        </li>
        <li>
          <p>
            Does this specification introduce new state for an origin that
            persists across browsing sessions?
          </p>
          <p>
            No. AudioWorklet does not persist across browsing sessions.
            <em>right?</em>
          </p>
        </li>
        <li>
          <p>
            Does this specification expose persistent, cross-origin state to
            the web?
          </p>
          <p>
            <em>Not sure. If audio sample data is loaded cross-origin, it
            exposes state (whether that sample data resolves or not) to the
            script origin.</em>
          </p>
        </li>
        <li>
          <p>
            Does this specification expose any other data to an origin that it
            doesnâ€™t currently have access to?
          </p>
          <p>
            Yes. When giving various information on available
            <a><code>AudioNode</code></a>s, the Web Audio API potentially
            exposes information on characteristic features of the client (such
            as audio hardware sample-rate) to any page that makes use of the
            <a><code>AudioNode</code></a> interface. Additionally, timing
            information can be collected through the
            <a><code>AnalyserNode</code></a> or
            <a><code>ScriptProcessorNode</code></a> interface. The information
            could subsequently be used to create a fingerprint of the client.
          </p>
        </li>
        <li>
          <p>
            Does this specification enable new script execution/loading
            mechanisms?
          </p>
          <p>
            No. However, it does use the worker script execution method,
            defined in that specification.
          </p>
        </li>
        <li>
          <p>
            Does this specification allow an origin access to a userâ€™s
            location?
          </p>
          <p>
            No.
          </p>
        </li>
        <li>
          <p>
            Does this specification allow an origin access to sensors on a
            userâ€™s device?
          </p>
          <p>
            Not directly. Currently audio input is not specified in this
            document, but it will involve gaining access to the client
            machine's audio input or microphone. This will require asking the
            user for permission in an appropriate way, probably via the
            <a href="https://w3c.github.io/mediacapture-main/#dom-mediadevices-getusermedia">
            getUserMedia() API</a>.
          </p>
        </li>
        <li>
          <p>
            Does this specification allow an origin access to aspects of a
            userâ€™s local computing environment?
          </p>
          <p>
            <em>Not sure. Does it allow probing of supported sample rates?
            Supported audio codecs? We should mention denial of service attack
            by consuming CPU cycles.</em>
          </p>
        </li>
        <li>
          <p>
            Does this specification allow an origin access to other devices?
          </p>
          <p>
            No.
          </p>
        </li>
        <li>
          <p>
            Does this specification allow an origin some measure of control
            over a user agentâ€™s native UI?
          </p>
          <p>
            No?. <em>Though it could be used to emulate system sounds to make
            an attack seem more like a local system event?</em>
          </p>
        </li>
        <li>
          <p>
            Does this specification expose temporary identifiers to the web?
          </p>
          <p>
            No.
          </p>
        </li>
        <li>
          <p>
            Does this specification distinguish between behavior in first-party
            and third-party contexts?
          </p>
          <p>
            No.
          </p>
        </li>
        <li>
          <p>
            How should this specification work in the context of a user agentâ€™s
            "incognito" mode?
          </p>
          <p>
            No differently.
          </p>
        </li>
        <li>
          <p>
            Does this specification persist data to a userâ€™s local device?
          </p>
          <p>
            <em>Maybe? Cached impulses or audio sample data stored
            locally?</em>
          </p>
        </li>
        <li>
          <p>
            Does this specification have a "Security Considerations" and
            "Privacy Considerations" section?
          </p>
          <p>
            Yes.
          </p>
        </li>
        <li>
          <p>
            Does this specification allow downgrading default security
            characteristics?
          </p>
          <p>
            No.
          </p>
        </li>
      </ol>
    </section>
    <section>
      <h2 id="requirements">
        Requirements and Use Cases
      </h2>
      <p>
        Please see [[webaudio-usecases]].
      </p>
    </section>
    <section>
      <h2>
        Common Definitions for Specification Code
      </h2>
      <p>
        This section describes common functions and classes employed by
        JavaScript code used within this specification.
      </p>
      <pre>
// Three dimensional vector class.
class Vec3 {
  // Construct from 3 coordinates.
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }

  // Dot product with another vector.
  dot(v) {
    return (this.x * v.x) + (this.y * v.y) + (this.z * v.z);
  }

  // Cross product with another vector.
  cross(v) {
    return new Vec3((this.y * v.z) - (this.z * v.y),
                    (this.z * v.x) - (this.x * v.z),
                    (this.x * v.y) - (this.y * v.x));
  }

  // Difference with another vector.
  diff(v) {
    return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
  }

  // Get the magnitude of this vector.
  get magnitude() {
    return Math.sqrt(dot(this));
  }

  // Get a copy of this vector multiplied by a scalar.
  scale(s) {
    return new Vec3(this.x * s, this.y * s, this.z * s);
  }

  // Get a normalized copy of this vector.
  normalize() {
    let m = magnitude;
    if (m == 0) {
      return new Vec3(0, 0, 0);
    }
    return scale(1 / m);
  }
}

      </pre>
    </section>
    <section class="appendix">
      <h2>
        Acknowledgements
      </h2>
      <p>
        This specification is the collective work of the W3C <a href=
        "http://www.w3.org/2011/audio/">Audio Working Group</a>.
      </p>
      <p>
        Members of the Working Group are (at the time of writing, and by
        alphabetical order):<br>
        Adenot, Paul (Mozilla Foundation) - Specification Co-editor; Akhgari,
        Ehsan (Mozilla Foundation); Berkovitz, Joe (Hal Leonard/Noteflight) â€“
        WG Chair; Bossart, Pierre (Intel Corporation); Carlson, Eric (Apple,
        Inc.); Choi, Hongchan (Google, Inc.); Geelnard, Marcus (Opera
        Software); Goode, Adam (Google, Inc.); Gregan, Matthew (Mozilla
        Foundation); Hofmann, Bill (Dolby Laboratories); JÃ¤genstedt, Philip
        (Opera Software); Kalliokoski, Jussi (Invited Expert); Lilley, Chris
        (W3C Staff); Lowis, Chris (Invited Expert. WG co-chair from December
        2012 to September 2013, affiliated with British Broadcasting
        Corporation); Mandyam, Giridhar (Qualcomm Innovation Center, Inc);
        Noble, Jer (Apple, Inc.); O'Callahan, Robert(Mozilla Foundation);
        Onumonu, Anthony (British Broadcasting Corporation); Paradis, Matthew
        (British Broadcasting Corporation) - WG Chair; Raman, T.V. (Google,
        Inc.); Schepers, Doug (W3C/MIT); Shires, Glen (Google, Inc.); Smith,
        Michael (W3C/Keio); Thereaux, Olivier (British Broadcasting
        Corporation); Toy, Raymond (Google, Inc.); Verdie, Jean-Charles (MStar
        Semiconductor, Inc.); Wilson, Chris (Google,Inc.) - Specification
        Co-editor; ZERGAOUI, Mohamed (INNOVIMAX)
      </p>
      <p>
        Former members of the Working Group and contributors to the
        specification include:<br>
        Caceres, Marcos (Invited Expert); Cardoso, Gabriel (INRIA); Chen, Bin
        (Baidu, Inc.); MacDonald, Alistair (W3C Invited Experts) â€” WG co-chair
        from March 2011 to July 2012; Michel, Thierry (W3C/ERCIM); Rogers,
        Chris (Google, Inc.) â€“ Specification Editor until August 2013; Wei,
        James (Intel Corporation);
      </p>
    </section>
    <section id="idl-index" class="appendix">
      <!-- Auto-generated IDL index goes here -->
    </section>
  </body>
</html>
